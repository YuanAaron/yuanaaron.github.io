---
layout: post 
author: oshacker
title: 【分布式缓存系列】本系列概述
category: database
tags: [geek,database]
excerpt: 分布式缓存系列（一）
---


## 为什么要学习分布式缓存？

第一次用到缓存是在Hibernat中，它是一个持久层框架，会经常访问物理数据库。为了降低应用程序对物理数据库访问的频次，提高程序的运行性能，于是用到了它的一级缓存和二级缓存，发现缓存对数据库查询的性能有巨大提升。

随着互联网全面的普及，用户量呈现了爆发式的增长，这对于系统的稳定性造成了很大的影响。于是一时间出现了多种形式的缓存，在web端出现了页面缓存，在移动端出现了App缓存，在服务端出现了数据库缓存、平台级缓存、应用级缓存等，极大缓解了大用户量对系统造成的冲击。在这么多缓存出现后，对于缓存的使用已经不是仅仅存储数据这么简单了，该如何做缓存框架的选型、究竟哪种框架更适合自己的现状，缓存使用时可能存在的缓存穿透、雪崩等现象，以及分布式环境下的缓存一致性问题（特别是在金融类项目中，缓存与数据库不一致会造成非常严重的生产事故，毕竟与钱相关啊），这些都是将会面并需要解决的难题。因此，我们需要深入了解并掌握分布式缓存的用法，以便帮助我们更好的进行架构设计，提升系统整体的并发能力和稳定性。

缓存学习的关键点：
+ 对缓存框架的原理有深入的了解。理解缓存框架在集群环境上的意义，缓存框架是如何同步数据的?
+ 如何才能熟练的使用缓存框架？比如每次往缓存框架中存放多大的数据，才不会影响缓存的性能；缓存框架中某些命令是不是有坑，如何避免？
+ 缓存在不同场景下是如何使用的？虽然我们会用缓存，但并不是在所有业务场景下用法都一样，需要在不同场景下灵活使用。

本系列文章文章的写作思路总体上是理论与实践相结合，对缓存框架的原理，缓存框架自身如何做集群部署等进行系统分析。然后通过大量缓存框架的使用案例来介绍如何应用缓存，如何避免常见的坑，如何利用缓存框架来实现缓存数据之外的功能。最后，将缓存与具体业务场景相关联，结合多个场景案例来灵活运用缓存使用的技巧。

## 内容综述

![](https://www.coderap.cn/assets/images/2020/06/cache1.png)

## 缓存可以用于解决哪些问题？

### 什么是缓存？

缓存最通用的解释是可以进行高速数据交换的存储器。

![](https://www.coderap.cn/assets/images/2020/06/cache2.png)

上图是一个应用级缓存，用户A从硬盘中读取数据，然后将数据存储到缓存中，用户B就可以直接从缓存中读取用户A存放到缓存中的数据，这样可以减少用户和硬盘之间的交互，提升了效率。

![](https://www.coderap.cn/assets/images/2020/06/cache3.png)

上图是一个系统级缓存（机械硬盘缓存），其实它是硬盘主板上的一块内存芯片，如图中的64M的DDR2缓存，它之所以存在是因为硬盘也需要有缓存来快速存取数据，这关系到硬盘的传输速度，能够大幅度提高硬盘的整体性能。如果没有该缓存，硬盘在读取零散数据的时候，就需要不断地在硬盘和内存之间做数据交换；如果存在该缓存，只需要将数据暂存到这里，然后统一刷新到内存中即可。

![](https://www.coderap.cn/assets/images/2020/06/cache4.png)

上图也是一个系统级缓存（CPU（英特尔系列）缓存），CPU缓存是位于CPU和内存之间的一个临时数据交换器，容量远小于内存，但交换速度非常快。上图是一个CPU三级缓存，它包括L1、L2、L3三级缓存，他们的作用都是作为CPU和主存之间的缓冲区，数字越小越靠近CPU core，交换速度也越快，即L1的交换速度最快。CPU会先从L1中查找数据，如果查不到才会去L2中查找，如果还是查不到才会去L3中查找，如果三级缓存都没有才会去主存中查找。其中L1缓存又分为数据缓存(L1d cache)和指令缓存(L1i cache)。

所以说，对于系统级来说，尤其是对于硬件来说，它也是大量地在使用这种缓存的机制。

### 缓存和内存的异同？

初学者一般会认为缓存和内存是同等的，其实的异同点如下：
+ 掉电是否丢数据：两者的存储方式相同，掉电都会丢失数据。
+ 物理结构是否相同：缓存会使用部分内存，此外它还可以第三方的缓存框架；内存一般指物理内存条，在本机中使用。
+ 部署方式：缓存可以在所在主机中部署或独立部署，而内存由于是指内存条，所以在所在主机中部署。

服务器长时间运行，我们会不断地向缓存或内存中存放数据，但他们的容量都是有限的，即存在缓存容量满的时候，那这时候缓存就有几种淘汰策略：
+ 先进先出算法（FIFO）：如果一个缓存最先进入缓存，则应该最早淘汰掉；
+ 最近最少用（Least Recently Used，LRU）: 判断数据最近使用的时间，时间最远的数据优先被淘汰。
+ 最不经常使用的（Least Frequently Used，LFU）：在一段时间内，数据被使用的次数最少，优先被淘汰；

这几种缓存淘汰策略的存在保证了缓存不会被占满、挤爆，而且还可以不断向缓存中添加新的数据。

### 缓存的应用场景

当我们的应用扛不住用户并发量的时候，才会大量使用缓存。

**场景一：将数据库部分数据加入到缓存中**

用户量比较大或数据量比较大时，我们会把一些经常访问的数据放到缓存中，然后让用户直接去访问。

**场景二：列表排序分页等场景**

有时候一些数据会经常改变，我们经常会对一些数据进行分页，或者把一些数据库的数据拿出来做排序，这种时候可能会将数据加入到缓存中，然后在缓存中当中进行分页、排序等，这样能提升效率。

**场景三：计数器**

并发计数或访问计数等，一般会用缓存。

**场景四：详情内容数据缓存**

比如在做电商时，会把详情页面放到缓存中，这样当请求量比较大的时候，直接从缓存当中把详情页加载出来，然后供用户去访问。

**场景五：分布式session**

当我们在做集群或微服务时，一定会涉及到用户权限、用户登陆的问题，当我们把应用程序部署成多份时，就一定会涉及到session共享的问题，一般都会用redis或memcached来做分布式session。

**场景六：热点数据排名**

比如，评价系统，积分排名系统，这些可以借助缓存，在缓存中做热点数据的排名，把那些最热的数据放到前面，一些访问次数少的放到后面，然后不断更新这个排名。

**场景七：发布订阅**

比如MQ系统中，一方发布消息，另一方订阅消息。其实一些缓存框架也是支持的，比如redis就支持比较轻量级的发布订阅模式，如果对消息要求不是很高，那么也可以使用redis来发布消息、订阅消息。

**场景八：分布式锁**

分布式锁的实现方式：数据库、ZooKeeper、Consul、etcd、Redis。

