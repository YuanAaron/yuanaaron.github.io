---
layout: post 
author: oshacker
title: 深入理解MySQL索引
category: database
tags: [database,MySQL,索引]
excerpt: MySQL索引那些事
---


## 前言

当提到MySQL数据库的时候，我们的脑海中会想起几个关键字：索引、事务、数据库锁等，索引是MySQL的灵魂，是平时进行查询时的利器，也是面试的重中之重。

可能你了解索引的底层是b+树，能够加快查询，也会在表中建立索引，但这是远远不够的，这里列举几个面试常见的面试题：
1. 索引为什么要用b+树这种数据结构？
2. 聚焦索引和非聚焦索引的区别？
3. 索引什么时候会失效，最左匹配原则是什么？

当遇到这些问题的时候，可能会发现自己对索引还是一知半解，今天我们就学习MySQL的索引。

## 一条查询语句是如何执行的？

首先来看，在MySQL数据库中，一条查询语句是如何执行的，索引出现在哪个环节，起到了什么作用。

**1. 应用程序发送SQL到服务端**

当执行SQL语句时，应用程序会连接到相应的数据库服务器，然后服务器对SQL进行处理。

**2. 查询缓存**

接着数据库服务器会先去查询是否有该SQL语句的缓存（查询过的SQL会以key/value键值对的形式进行缓存，其中key是查询的语句，value是查询的结果），如果你的查询能够直接命中，就会直接从缓存中拿出value返回给客户端。

注：查询不会被解析、不会生成执行计划、不会被执行。

**3. 查询优化处理，生成执行计划**

如果没有命中缓存，则开始第三步：
+ 解析SQL：生成解析树，验证关键字（如select、where、left join等）是否正确；
+ 预处理：进一步检查解析树是否合法（如检查数据表和列是否存在，验证用户权限等）；
+ 优化SQL: 决定使用哪个索引，或者在多个表相关联的时候决定表的连接顺序。紧接着，将SQL语句转成执行计划。

**4. 将查询结果返回客户端**

最后，数据库服务器将查询结果返回给客户端。（如果查询可以缓存，MySQL也会将结果放到缓存中）

![](https://www.coderap.cn/assets/images/2020/05/query.png)

以上就是一条查询语句的执行流程，可以看到索引出现在优化SQL的步骤中，接下来了解索引到底是什么？

## 索引概述

索引是帮助数据库高效获取数据的数据结构。

### 2.1 索引的分类
+ 从存储结构上来划分
  + BTree索引（B+Tree，B-Tree）
  + 哈希索引
  + full-index全文索引
  + RTree
+ 从应用层次上来划分
  + 普通索引：一个索引只包含单个列，一个表可以有多个单列索引；
  + 唯一索引：索引列的值必须唯一，但允许有空值；
  + 复合索引：一个索引包含多个列。
+ 从表记录的排列顺序和索引的排列顺序是否一致来划分
  + 聚集索引：表记录的排列顺序和索引的排列顺序一致；
  + 非聚集索引：表记录的排列顺序和索引的排列顺序不一致。

### 2.2 聚集索引和非聚集索引

简单说，聚集索引就是以主键创建的索引；非聚集索引是以非主键创建的索引（也叫二级索引）。

**两者的区别：**
+ 聚集索引在叶子节点存储的是表中的数据
+ 非聚集索引在叶子节点存储的是主键和索引列。
+ 聚集索引的表记录的排列顺序和索引的排列顺序一致，所以查询效率快，因为只要找到第一个索引值的记录，其余连续性的记录在物理表中也会连续存放，一起就可以查询到；缺点是新增比较慢，因为为了保证表中记录的物理顺序和索引顺序一致，在记录插入的时候，会对数据页(存放记录的页)重新排序。
+ 非聚集索引的索引的逻辑顺序与磁盘上行的物理存储顺序不同，非聚集索引在叶子节点存储的是主键和索引列，当我们使用非聚集索引查询数据时，需要拿到叶子节点上的主键(搜索对应字段的B+树)再去表中查询到想要查找的数据（搜索主键B+树），这个过程就是我们所说的**回表**。

**举例说明：**

比如,汉语字典想要查「阿」字，只需要翻到字典前几页，a开头的位置，接着「啊」「爱」都会出来。也就是说，字典的正文部分本身就是一个目录，不需要再去查其他目录来查询想要查找的内容。我们把这种正文内容本身就是一种按照一定规则排列的目录称为聚集索引。

如果遇到不认识的字，只能根据“偏旁部首”进行查找，然后根据这个字后的页码直接翻到某页来找到要找的字，这种结合部首目录和检字表而查到的字的排序并不是真正的正文的排序方法。

![](https://www.coderap.cn/assets/images/2020/05/zidian.png)

比如,要查“玉”字，可以看到在查部首之后的检字表中“玉”的页码是587页，然后是珏，是251页。很显然，在字典中这两个字并没有挨着，现在看到的连续的“玉、珏、莹”三字实际上就是他们在非聚集索引中的排序，是字典正文中的字在非聚集索引中的映射。通过这种方式找到所需要的字要经过两个过程：先找到目录中的结果，然后再翻到结果所对应的页码。我们把这种目录纯粹是目录，正文纯粹是正文的排序方式称为非聚集索引。

### 2.3 MySQL如何添加索引

1、添加PRIMARY KEY（主键索引）
```sql
ALTER TABLE `table_name` ADD PRIMARY KEY (`column`);

```

2、添加UNIQUE（唯一索引）
```sql
ALTER TABLE `table_name` ADD UNIQUE (`column`);
```

3、添加INDEX（普通索引）
```sql
ALTER TABLE `table_name` ADD INDEX index_name (`column`);
```

4、添加FULLTEXT（全文索引）
```sql
ALTER TABLE `table_name` ADD FULLTEXT (`column`);
```

5、添加多列索引
```sql
ALTER TABLE `table_name` ADD INDEX index_name (`column1`,`column2`,`column3`);
```

## 索引底层数据结构

了解了索引的基本概念后，可能最好奇的就是索引的底层是怎么实现的？为什么索引可以如此高效地进行数据的查找？如何设计数据结构可以满足我们的要求？按照一般程序员的思维想一下，如果是我们来设计索引，要如何设计来达到索引的效果。

### 3.1 哈希索引

可能直接想到就是哈希表来实现快速查找，就像我们平时用的hashmap一样，value=get(key)，时间复杂度为O(1)，一步到位，确实，哈希索引是一种方式。

**定义**

哈希索引就是采用一定的哈希算法，只需一次哈希算法就能立刻定位到相应的位置，速度非常快。本质上就是把键换算成哈希值，然后根据这个哈希值来定位。

![](https://www.coderap.cn/assets/images/2020/05/hash.png)

**局限性**
+ 哈希索引没办法利用索引完成排序；
+ 不能进行多字段查询；
+ 在有大量重复键值的情况下，哈希索引的效率也是极低的（哈希碰撞）；
+ 不支持范围查询。

**应用**

在MySQL常用的InnoDB存储引擎中，主流的还是使用B+树索引比较多。但是当某些查询语句不涉及多字段查询、范围查询时，这时候哈希索引还是最快的，所以InnoDB是自适应哈希索引的（哈希索引的创建又InnoDb存储引擎自动优化创建，我们干预不了，即InnoDB自己判断使用哈希索引还是别的数据结构）。

### 3.2 如何设计索引的数据结构呢？

比如数据为：6、10、15、23、27、33、42。设计的数据结构为二叉查找树+链表，如下图：

![](https://www.coderap.cn/assets/images/2020/05/tree1.png)

**查找区间[7,30]之间的数据**

假设要查询某个区间的数据，我们只需要拿到区间的起始值，然后在树中进行查找。当查找到叶子节点10后，再顺着链表进行遍历，直到链表中的节点数据大于区间的终止值为止。所有遍历到的数据，就是符合区间值的所有数据。

![](https://www.coderap.cn/assets/images/2020/05/tree2.png)

**还可以怎么优化呢？**

利用二叉查找树，区间查询的功能已经实现了，但为了节省内存，我们只能把树存储在硬盘中，那么每个节点的读取都对应一次硬盘IO操作。

每次查询数据时磁盘IO的次数即树的高度（也叫IO渐进复杂度）。所以，我们要减少磁盘IO操作的次数，也就是要降低树的高度。

结构优化过程如下：

![](https://www.coderap.cn/assets/images/2020/05/tree3.png)

![](https://www.coderap.cn/assets/images/2020/05/tree4.png)

这里将二叉树变为了M叉树，降低了树的高度，那么这个M应该选择多少才合适呢？也就是说，对于相同个数的数据构建M叉树索引，M叉树中的m越大，那么树的高度就越小，那M是不是越大越好呢？

不管是内存中的数据还是磁盘中的数据，操作系统都是按页来读取的（通常，一页的大小为4kb，这个值可以通过getconfig(PAGE_SIZE)命令查看），一次只会读取一页的数据。**如果要读取的数据超过了一页的大小，就会触发多次IO操作**。所以，在选择M大小的时候，要尽量让每个节点（存储多个索引）的大小等于一页的大小。

一般实际应用中，出度M是非常大的数字，通常超过100；树的高度h非常小，通常不超过3。

### 3.3 B树

顺着解决问题的思路直到了我们想要的数据结构是什么。目前，索引常用的数据结构是B+树，下面先介绍一下什么是B树，即B-树，如下图所示：

![](https://www.coderap.cn/assets/images/2020/05/b-tree.png)

**B树的特点：**
+ 关键字分布在整棵树的所有节点；
+ 任何一个关键字出现且只出现在一个节点中；
+ 搜索有可能在非叶子节点结束；
+ 其搜索性能等价于在关键字全集内做一次二分查找。

**B树的缺点：**
+ B树可能在非叶子节点就停止查找，查询效率不够稳定；
+ B树的范围查询比较慢，不像B+树叶子节点用链表连接。

### 3.4 B+树

了解了B树，再来看B+树，也是MySQL索引大部分情况下所使用的数据结构。一个M=3的B+树如下图：

![](https://www.coderap.cn/assets/images/2020/05/b+tree.png)

**B+树的特点：**
+ 非叶子节点的子树指针与关键字个数相同；
+ 非叶子节点的子树指针P[i]，指向关键字属于[k[i],k[i+1])的子树，注意左闭右开。如P1指向关键字属于[15,56)的子树
+ 为所有叶子节点增加了一个指针；
+ 所有关键字都在叶子节点出现。

这些基本特点都是为了满足以下的特性。

**相比B树，B+树的特性**
+ 所有关键字都出现在叶子节点的链表中，且链表中的关键字是有序的；
+ 搜索只会在叶子节点命中；
+ 非叶子节点相当于是叶子节点的索引层，叶子节点是存储关键字数据的数据层。

**相对B树，B+树做索引的优势**
+ B+树的磁盘读写代价更低。B+树的内部没有指向关键字具体信息的指针，所以其内部节点相对B树更小，如果把所有关键字存放在同一块盘中，那么盘中所能容纳的关键字数量更多，一次性读入内存的需要查找的关键字也就越多，相应的，IO读写次数就降低了；
+ 树的查询效率更加稳定。B+树所有数据都存在于叶子节点，所有关键字查询的路径长度相同，每次数据的查询效率相当。而B树可能在非叶子节点就停止查找了，所以查询效率不够稳定。
+ B+树只需要去遍历叶子节点就可以实现整棵树的遍历。

### 3.5 MongoDB的索引为什么选择B树，而MySQL的索引是B+树？

因为MongoDB不是传统的关系型数据库，而是以Json格式作为存储的NoSQL非关系型数据库，目的就是高性能、高可用、易扩展。摆脱了关系模型，所以范围查询和遍历查询的需求就没那么强烈了。

### 3.6 MyISAM存储引擎和InnoDB存储引擎的索引有什么区别？

**MyISAM存储引擎**

MyISAM存储引擎分为三个文件：.frm（用于存储表的定义）、.MDY（用于存放数据）、.MYI（用于存放表索引）。

![](https://www.coderap.cn/assets/images/2020/05/myisam.png)

主键索引
+ MyISAM的索引文件（.MYI）和数据文件（.MDY）文件是分离的，索引文件仅保存记录所在页的指针（物理位置），通过这些指针来读取页，进而读取被索引的行。
+ 树中的叶子节点保存的是对应行的物理位置，通过该值，存储引擎能顺利地进行回表，得到一行完整记录。同时，每个叶子节点也保存了下一个叶子的指针，从而方便叶子节点的范围遍历。

辅助索引
+ 在MyISAM中，主键索引和辅助索引在结构上没有任何区别，只是**主键索引要求key是唯一的，而辅助索引的key可以重复**。

**InnoDB存储引擎**

主键索引

![](https://www.coderap.cn/assets/images/2020/05/innodb1.png)

InnoDB主键索引中，既存储了主键值，又存储了行数据。

辅助索引

![](https://www.coderap.cn/assets/images/2020/05/innodb2.png)

对于辅助索引，InnoDB采用的方式是在叶子节点中保存主键值，通过这个主键值来回表查询到一条完整记录，因此按辅助索引检索其实进行了二次查询，效率是没有主键索引高的。

## MySQL索引失效

在上一节中了解了索引的多种数据结构，以及B树和B+树的对比等，大家应该对索引的底层实现有了初步的了解。这一节从应用层的角度出发，看一下如何建索引更能满足我们的需求，以及MySQL索引什么时候会失效的问题。

### 4.1 多个单列索引

先来思考一个小问题：当查询条件为2或2个以上时，是创建多个单例索引还是创建一个联合索引好呢？他们之间的区别是什么？哪个效率更高呢？

比如，你可以建立一些单列索引进行测试，比如在表t_mobilesms_11中建立了三个单例索引userid(userid)、mobile(mobile)、billMonth(billMonth)，然后进行多列查询。
```sql
explain select * from `t_mobilesms_11` where userid = '1' and mobile = '13504679876' and billMonth = '1998-03';
```

![](https://www.coderap.cn/assets/images/2020/05/index_out.png)

我们发现查询时只用到了userid这一个单列索引，这是为什么呢？

这取决于MySQL优化器的优化策略。当多条件联合查询时，优化器会评估哪个条件的索引效率高，它会选择最佳的索引去使用。也就是说，此处三个索引列都可能被用到，只不过优化器判断只需要使用userid这一个索引就能完成本次查询，所以最终explain展示的key为userid。

**总结：**
+ 多个单索引在多条件查询时，优化器会优先选择最优索引策略，可能只用一个索引，也可能将多个索引都用上；
+ 多个单列索引底层会建立多个B+索引树，比较占用空间，也会浪费搜索效率，所以多条件联合查询时最好建联合索引。

### 4.2 联合索引失效问题

联合索引就可以三个条件都用上了吗？会出现索引失效的问题吗？

![](https://www.coderap.cn/assets/images/2020/05/union_index_out.png)

创建user表，然后建立name、age、pos、phone四个字段的联合索引
```sql
mysql> show create table `user` \G;
*************************** 1. row ***************************
       Table: user
Create Table: CREATE TABLE `user` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `name` varchar(20) DEFAULT NULL,
  `age` int(10) DEFAULT '0',
  `pos` varchar(30) DEFAULT NULL,
  `phone` varchar(11) DEFAULT NULL,
  `created_time` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_name_age_pos_phone` (`name`,`age`,`pos`,`phone`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
```

**全值匹配（索引最佳）**

![](https://www.coderap.cn/assets/images/2020/05/union_index.png)

交换索引的位置，发现和索引顺序无关，MySQL底层优化器会进行优化，调整索引的顺序。那什么时候会失效呢？

**1）违反最左匹配原则**

最左匹配原则：最左优先，以最左边的为起点，任何连续的索引都能匹配上，如不连续则匹配不上。

如：建立索引为（a,b）的联合索引，那么只查where b=2则不生效。也就是说，如果建立的索引是（a,b,c），则只有（a）、（a,b）、（a,b,c)三种

**2）在索引列上做任何操作**


**3）使用不等于（!=、<>）**

**4）like中以通配符开头（'%abc'）**

**5）字符串不加单引号索引失效**

**6）or连接**

**7）order by**

**8）group by**


参考：
+ https://www.cnblogs.com/yixinjishu/p/12515935.html
+ https://segmentfault.com/a/1190000021464570