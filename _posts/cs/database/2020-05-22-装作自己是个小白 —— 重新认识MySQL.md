---
layout: post 
author: oshacker
title: 装作自己是个小白 —— 重新认识MySQL
category: database
tags: [database,MySQL]
excerpt: MySQL是怎样运行的系列(一)
---


# 初识MySQL

## MySQL的客户端／服务器架构

以我们平时使用的微信为例，它其实是由两部分组成的，一部分是客户端程序，一部分是服务器程序。客户端可能有很多种形式，比如手机APP，电脑软件或者是网页版微信，每个客户端都有一个唯一的用户名，就是你的微信号，另一方面，腾讯公司在他们的机房里运行着一个服务器软件，我们平时操作微信其实都是用客户端来和这个服务器来打交道。比如狗哥用微信给猫爷发了一条消息的过程其实是这样的：
1.  消息被客户端包装了一下，添加了发送者和接受者信息，然后从狗哥的微信客户端传送给微信服务器；   
2.  微信服务器从消息里获取到它的发送者和接收者，根据消息的接收者信息把这条消息送达到猫爷的微信客户端，猫爷的微信客户端里就显示出狗哥给他发了一条消息。
    
`MySQL`的使用过程跟这个是一样的，<font color="red">它的服务器程序直接和我们存储的数据打交道</font>，然后可以有好多客户端程序连接到这个服务器程序，发送增删改查的请求，然后服务器就响应这些请求，从而操作它维护的数据。和微信一样，`MySQL`的每个客户端都需要提供用户名密码才能登录，登录之后才能给服务器发请求来操作某些数据。我们日常使用`MySQL`的情景一般是这样的：
1. 启动`MySQL`服务器程序。
2. 启动`MySQL`客户端程序并连接到服务器程序。
3. 在客户端程序中输入一些命令语句作为请求发送到服务器程序，服务器程序收到这些请求后，会根据请求的内容来操作具体的数据并向客户端返回操作结果。

我们知道计算机很牛逼，在一台计算机上可以同时运行多个程序，比如微信、QQ、音乐播放器、文本编辑器啥的，每一个运行着的程序也被称为一个`进程`。我们的`MySQL`服务器程序和客户端程序本质上都算是计算机上的一个`进程`，这个代表着`MySQL`服务器程序的进程也被称为`MySQL数据库实例`，简称`数据库实例`。

每个进程都有一个唯一的编号，称为`进程ID`，英文名叫`PID`，这个编号是在我们启动程序的时候由操作系统随机分配的，操作系统会保证在某一时刻同一台机器上的进程号不重复。比如你打开了计算机中的QQ程序，那么操作系统会为它分配一个唯一的进程号，如果你把这个程序关掉了，那操作系统就会把这个进程号回收，之后可能会重新分配给别的进程。当我们下一次再启动QQ程序的时候，分配的就可能是另一个编号。每个进程都有一个名称，这个名称是编写程序的人自己定义的，比如我们启动的`MySQL`服务器进程的默认名称为`mysqld`， 而我们常用的`MySQL`客户端进程的默认名称为`mysql`。

## MySQL的安装

我这里使用的操作系统和`MySQL`版本为：`Centos7` + `MySQL 5.7`。

具体安装过程略

通过`yum`安装MySQL后的几个默认目录如下：
+ `/usr/bin`：客户端程序和脚本
+ `/usr/sbin`：`MySQL`服务器
+ `/var/lib/mysql`：日志文件，数据库文件
+ `/usr/share/mysql`：错误消息和字符集文件
+ `/etc/my.cnf`：配置文件

启动MySQL服务器程序：systemctl start mysqld

关闭MySQL服务器程序：systemctl stop mysqld

启动MySQL客户端程序：mysql -h主机名  -u用户名 -p密码

各个参数的意义如下：
+ `-h`：表示服务器进程所在计算机的域名或者IP地址，如果服务器进程就运行在本机的话，可以省略这个参数，或者填`localhost`或者`127.0.0.1`。也可以写作 `--host=主机名`的形式。
+ `-u`：表示用户名。也可以写作 `--user=用户名`的形式。
+ `-p`：表示密码。也可以写作 `--password=密码`的形式。
> 小贴士： 像 h、u、p 这样名称只有一个英文字母的参数称为短形式的参数，使用时前边需要加单短划线，像 host、user、password 这样大于一个英文字母的参数称为长形式的参数，使用时前边需要加双短划线。后边会详细讨论这些参数的使用方式的，稍安勿躁～

如果我们想断开客户端与服务器的连接并且关闭客户端的话，可以在`mysql>`提示符后输入任意一个命令：`quit`，或`exit`，或`\q`

**连接注意事项**
1. 最好不要在一行命令中输入密码：我们直接在黑框框里输入密码很可能被别人看到，这和你当着别人的面输入银行卡密码没啥区别，所以我们在执行`mysql`连接服务器的时候可以不显式的写出密码，就像这样：mysql -hlocahhost -uroot -p，点击回车之后再输入密码；
2. 如果你非要在一行命令中显式的把密码输出来，那`-p`和密码值之间不能有空白字符（其他参数名之间可以有空白字符）；
3. `mysql`的各个参数的摆放顺序没有硬性规定，也就是说你也可以这么写：mysql -p  -u root -h localhost
    
## 客户端与服务器连接的过程

我们现在已经知道如何启动`MySQL`的服务器程序，以及如何启动客户端程序来连接到这个服务器程序。运行着的服务器程序和客户端程序本质上都是计算机上的一个进程，所以客户端进程向服务器进程发送请求并得到回复的过程本质上是一个进程间通信的过程！`MySQL`支持下面三种客户端进程和服务器进程的通信方式。

### TCP/IP

真实环境中，数据库服务器进程和客户端进程可能运行在不同的主机中，它们之间必须通过网络来进行通讯。`MySQL`采用`TCP`作为服务器和客户端之间的网络通信协议。在网络环境下，每台计算机都有一个唯一的`IP地址`，如果某个进程有需要采用`TCP`协议进行网络通信方面的需求，可以向操作系统申请一个`端口号`，这是一个整数值，它的取值范围是`0~65535`。这样在网络中的其他进程就可以通过`IP地址 + 端口号`的方式来与这个进程连接，这样进程之间就可以通过网络进行通信了。

`MySQL`服务器启动的时候会默认申请`3306`端口号，之后就在这个端口号上等待客户端进程进行连接，用书面一点的话来说，`MySQL`服务器会默认监听`3306`端口。

如果`3306`端口号已经被别的进程占用了，或者我们单纯的想自定义该数据库实例监听的端口号，我们可以修改/etc/my.cnf配置文件，在mysqld下面添加port=3307（以3307为例），这样`MySQL`服务器在启动时就会去监听我们指定的端口号`3307`。

如果客户端进程想要使用`TCP/IP`网络来连接到服务器进程，比如我们在使用`mysql`来启动客户端程序时，在`-h`参数后必须跟随`IP地址`来作为需要连接的服务器进程所在主机的主机名，如果客户端进程和服务器进程在一台计算机中的话，我们可以使用`127.0.0.1`来代表本机的`IP地址`。另外，如果服务器进程监听的端口号不是默认的3306，我们也可以在使用mysql启动客户端程序时使用-P参数（大写的P，小写的p是用来指定密码的）来指定需要连接到的端口号。如：mysql -h127.0.0.1 -uroot -P3307 -p。

### Unix域套接字文件

如果我们的服务器进程和客户端进程都运行在同一台操作系统为类`Unix`的机器上的话，我们可以使用`Unix域套接字文件`来进行进程间通信。`MySQL`服务器程序默认监听的`Unix`域套接字文件路径为`/var/lib/mysql/mysql.sock`，客户端程序使用`mysql -uroot -p`默认连接到这个`Unix`域套接字文件。当数据库实例启动后，用户可以通过`SHOW VARIABLE LIKE 'socket';`命令来进行Unix域套接字文件的查找。

如果我们想改变这个默认路径，可以修改`/etc/my.cnf`配置文件，修改mysqld下的`socket`值，比如修改为`/tmp/mysql.sock`。这样服务器启动后便会监听`/tmp/mysql.sock`。在服务器改变了默认的`UNIX`域套接字文件后，如果客户端程序想通过`UNIX`域套接字文件进行通信的话，也需要显式的指定连接到的`UNIX`域套接字文件路径，就像这样：`mysql -uroot -S /tmp/mysql.sock -p`，这样该客户端进程和服务器进程就可以通过路径为`/tmp/mysql.sock`的`Unix`域套接字文件进行通信了。

### 命名管道和共享内存

命名管道和共享内存是Windows操作系统中的两种进程间通信方式，这里不做介绍～

## 服务器处理客户端请求

其实不论客户端进程和服务器进程是采用哪种方式进行通信，最后实现的效果都是：客户端进程向服务器进程发送一段文本（MySQL语句），服务器进程处理后再向客户端进程发送一段文本（处理结果）。那服务器进程对客户端进程发送的请求做了什么处理，才能产生最后的处理结果呢？客户端可以向服务器发送增删改查各类请求，我们这里以比较复杂的查询请求为例来画个图展示一下大致的过程：

![](https://www.coderap.cn/assets/images/2020/05/db1.png)

从图中我们可以看出，服务器程序处理来自客户端的查询请求大致需要经过三个部分，分别是`连接管理`、`解析与优化`、`存储引擎`。下边我们来详细看一下这三个部分都干了什么。

### 连接管理

客户端进程可以采用我们上边介绍的`TCP/IP`、`命名管道或共享内存`(只适用于Windows)、`Unix域套接字`这几种方式之一来与服务器进程建立连接，每当有一个客户端进程连接到服务器进程时，服务器进程都会创建一个线程来专门处理与这个客户端的交互，当该客户端退出时会与服务器断开连接，服务器并不会立即把与该客户端交互的线程销毁掉，而是把它缓存起来，在另一个新的客户端再进行连接时，把这个缓存的线程分配给该新客户端。这样就起到了不频繁创建和销毁线程的效果，从而节省开销。从这一点大家也能看出，`MySQL`服务器会为每一个连接进来的客户端分配一个线程，但是线程分配的太多了会严重影响系统性能，所以我们也需要限制一下可以同时连接到服务器的客户端数量，至于怎么限制我们后边再说哈～

在客户端程序发起连接的时候，需要携带主机信息、用户名、密码，服务器程序会对客户端程序提供的这些信息进行认证，如果认证失败，服务器程序会拒绝连接。另外，如果客户端程序和服务器程序不运行在一台计算机上，我们还可以采用使用了`SSL`（安全套接字）的网络连接进行通信，来保证数据传输的安全性。

当连接建立后，与该客户端关联的服务器线程会一直等待客户端发送过来请求，`MySQL`服务器接收到的请求只是一个文本消息，该文本消息还要经过各种处理，预知后事如何，继续往下看哈～

### 解析与优化

到现在为止，`MySQL`服务器已经获得了文本形式的请求，接着还要经过九九八十一难的处理，其中的几个比较重要的部分分别是`查询缓存`、`语法解析`和`查询优化`，下边我们详细来看。

**查询缓存**

如果我问你`9+8×16-3×2×17`的值是多少，你可能会用计算器去算一下，或者牛逼一点用心算，最终得到了结果`35`，如果我再问你一遍`9+8×16-3×2×17`的值是多少，你还用再傻呵呵的算一遍么？我们刚刚已经算过了，直接说答案就好了。`MySQL`服务器程序处理查询请求的过程也是这样，会把刚刚处理过的查询请求和结果`缓存`起来，如果下一次有一模一样的请求过来，直接从缓存中查找结果就好了，就不用再傻呵呵的去底层的表中查找了。这个查询缓存可以在不同客户端之间共享，也就是说如果客户端A刚刚查询了一个语句，而客户端B之后发送了同样的查询请求，那么客户端B的这次查询就可以直接使用查询缓存中的数据。

当然，`MySQL`服务器并没有人聪明，<font color="red">如果两个查询请求在任何字符上不同（例如：空格、注释、大小写），都会导致缓存不会命中</font>。另外，<font color="red">如果查询请求中包含某些系统函数、用户自定义变量和函数、一些系统表，如mysql、information_schema、performance_schema数据库中的表，那这个请求就不会被缓存</font>。以某些系统函数举例，可能同样的函数的两次调用会产生不一样的结果，比如函数`NOW`，每次调用都会产生最新的当前时间，如果在一个查询请求中调用了这个函数，即使查询请求的文本信息都一样，那不同时间的两次查询也应该得到不同的结果，如果在第一次查询时就缓存了，那第二次查询的时候直接使用第一次查询的结果就是错误的！

不过既然是缓存，那就有它缓存失效的时候。<font color="red">MySQL的缓存系统会监测涉及到的每张表，只要该表的结构或者数据被修改，如对该表使用了`INSERT`、 `UPDATE`、`DELETE`、`TRUNCATE TABLE`、`ALTER TABLE`、`DROP TABLE`或 `DROP DATABASE`语句，那使用该表的所有高速缓存查询都将变为无效，并从高速缓存中删除</font>！
> 小贴士： 虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，比如每次都要去查询缓存中检索，查询请求处理完需要更新查询缓存，维护该查询缓存对应的内存区域。从MySQL5.7.20开始，不推荐使用查询缓存，并在MySQL8.0中删除。

**语法解析**

如果查询缓存没有命中，接下来就需要进入正式的查询阶段了。因为客户端程序发送过来的请求只是一段文本而已，所以`MySQL`服务器程序首先要对这段文本做分析，判断请求的语法是否正确，然后从文本中将要查询的表、各种查询条件都提取出来放到`MySQL`服务器内部使用的一些数据结构上来。
> 小贴士： 这个从指定的文本中提取出我们需要的信息本质上算是一个编译过程，涉及词法解析、语法分析、语义分析等阶段，这些问题不属于我们讨论的范畴，大家只要了解在处理请求的过程中需要这个步骤就好了。

**查询优化**

语法解析之后，服务器程序获得到了需要的信息，比如要查询的列是哪些，表是哪个，搜索条件是什么等等，但光有这些是不够的，因为我们写的`MySQL`语句执行起来效率可能并不是很高，`MySQL`的优化程序会对我们的语句做一些优化，如外连接转换为内连接、表达式简化、子查询转为连接吧啦吧啦的一堆东西。优化的结果就是生成一个执行计划，这个执行计划表明了应该使用哪些索引进行查询，表之间的连接顺序是啥样的。我们可以使用`EXPLAIN`语句来查看某个语句的执行计划，关于查询优化这部分的详细内容我们后边会仔细唠叨，现在你只需要知道在`MySQL`服务器程序处理请求的过程中有这么一个步骤就好了。

### 存储引擎

截止到服务器程序完成了查询优化为止，还没有真正的去访问真实的数据表，`MySQL`服务器把数据的存储和提取操作都封装到了一个叫`存储引擎`的模块里。我们知道`表`是由一行一行的记录组成的，但这只是一个逻辑上的概念，物理上如何表示记录，怎么从表中读取数据，怎么把数据写入具体的物理存储器上，这都是`存储引擎`负责的事情。为了实现不同的功能，`MySQL`提供了各式各样的`存储引擎`，不同`存储引擎`管理的表具有的存储结构可能不同，采用的存取算法也可能不同。

> 小贴士： 为什么叫`引擎`呢？因为这个名字更拉风～ 其实这个存储引擎以前叫做`表处理器`，后来可能人们觉得太土，就改成了`存储引擎`的叫法，它的功能就是接收上层传下来的指令，然后对表中的数据进行提取或写入操作。

为了管理方便，人们把`连接管理`、`查询缓存`、`语法解析`、`查询优化`这些并不涉及真实数据存储的功能划分为`MySQL server`的功能，把真实存取数据的功能划分为`存储引擎`的功能。各种不同的存储引擎向上边的`MySQL server`层提供统一的调用接口（也就是存储引擎API），包含了几十个底层函数，像"读取索引第一条内容"、"读取索引下一条内容"、"插入记录"等等。

所以在`MySQL server`完成了查询优化后，只需按照生成的执行计划调用底层存储引擎提供的API，获取到数据后返回给客户端就好了。

## 常用存储引擎

`MySQL`支持非常多种存储引擎，我这先列举一些：
+ `ARCHIVE`：用于数据存档（行被插入后不能再修改）
+ `BLACKHOLE`：丢弃写操作，读操作会返回空内容
+ `CSV`：在存储数据时，以逗号分隔各个数据项
+ `FEDERATED`：用来访问远程表
+ `InnoDB`：具备外键支持功能的事务存储引擎
+ `MEMORY`：置于内存的表
+ `MERGE`：用来管理多个MyISAM表构成的表集合
+ `MyISAM`：主要的非事务处理存储引擎
+ `NDB`：MySQL集群专用存储引擎

这么多我们怎么挑啊，哈哈，你多虑了，其实我们最常用的就是`InnoDB`和`MyISAM`，有时会提一下`Memory`。其中`InnoDB`是`MySQL`默认的存储引擎，我们之后会详细唠叨这个存储引擎的各种功能，现在先看一下一些存储引擎对于某些功能的支持情况：

![](https://www.coderap.cn/assets/images/2020/05/db2.png)

密密麻麻列了这么多，看的头皮都发麻了。其实这些东西大家没必要立即就给记住，我列出来的目的是想说明不同的存储引擎支持不同的功能，有些重要的功能我们会在后边的唠叨中慢慢让大家理解的～

## 关于存储引擎的一些操作

### 查看当前服务器程序支持的存储引擎

我们可以用下边这个命令来查看当前服务器程序支持的存储引擎：

![](https://www.coderap.cn/assets/images/2020/05/db3.png)

其中的`Support`列表示该存储引擎是否可用，`DEFAULT`值代表是当前服务器程序的默认存储引擎。`Comment`列是对存储引擎的一个描述。`Transactions`列代表该存储引擎是否支持事务处理。`XA`列代表着该存储引擎是否支持分布式事务。`Savepoints`代表着该引擎是否支持部分事务回滚。

### 设置表的存储引擎

我们前边说过，存储引擎是负责对表中的数据进行提取和写入工作的，我们可以为不同的表设置不同的存储引擎，也就是说不同的表可以有不同的物理存储结构，不同的提取和写入方式。

**创建表时指定存储引擎**

我们之前创建表的语句都没有指定表的存储引擎，那就会使用默认的存储引擎`InnoDB`（当然这个默认的存储引擎也是可以修改的，我们在后边的章节中再说怎么改）。如果我们想显式的指定一下表的存储引擎，那可以这么写：
```sql
CREATE TABLE 表名(
    建表语句;
) ENGINE = 存储引擎名称;
```

比如我们想创建一个存储引擎为MyISAM的表可以这么写：
```sql
CREATE TABLE engine_demo_table(
    i int UNSIGNED AUTO_INCREMENT PRIMARY KEY;
) ENGINE = MyISAM;
```

**修改表的存储引擎**

如果表已经建好了，我们也可以使用下边这个语句来修改表的存储引擎：
```sql
ALTER TABLE 表名 ENGINE = 存储引擎名称;
```

比如我们修改一下engine_demo_table表的存储引擎：
```sql
ALTER TABLE engine_demo_table ENGINE = InnoDB;
```

最后，我们再查看一下表结构：SHOW CREATE TABLE engine_demo_table \G;
```sql
mysql> SHOW CREATE TABLE engine_demo_table \G;
*************************** 1. row ***************************
       Table: engine_demo_table
Create Table: CREATE TABLE `engine_demo_table` (
  `i` int(10) unsigned NOT NULL AUTO_INCREMENT,
  PRIMARY KEY (`i`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

可以看到该表的存储引擎已经改为`InnoDB`了。

参考：https://juejin.im/book/5bffcbc9f265da614b11b731