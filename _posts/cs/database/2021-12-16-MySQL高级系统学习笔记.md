---
layout: post 
author: oshacker
title: MySQL高级系统学习笔记
category: database
tags: [cs,datebase]
excerpt: 流水账，不喜勿喷😄

---

## 前言

### 必备基础知识

MySQL软件下载和安装（我使用5.7.30）

熟悉MySQL工具和基本SQL操作

+ windows：MySQL WorkBench、Navicat、SQLyog
+ Linux：MySQL WorkBench、Navicat
+ Mac：Navicat、Sequel Pro

熟悉主键、外键、非空、唯一等约束

熟悉索引、事务概念和基本使用

### 主要学习内容

MySQL架构原理和存储机制

+ MySQL体系结构（内存结构、磁盘结构）、SQL运行机制、存储引擎、Undo/Redo Log等

MySQL索引存储机制和工作原理

+ 索引存储结构、索引查询原理、索引分析和优化、查询优化等

MySQL事务和锁工作原理

+ 事务隔离级别、事务并发处理、锁机制和实战等

MySQL集群架构及相关原理

+ 集群架构设计理念、主动架构、双主架构、分库分表等

互联网海量数据处理实战

+ ShardingSphere、MyCat中间件实战操作、分库分表实战

MySQL第三方工具实战

+ 同步工具、运维工具、监控工具等

### MySQL起源和分支

MySQL 是最流行的关系型数据库软件之一，由于其体积小、速度快、开源免费、简单易用、维护成本低等，在集群架构中易于扩展、高可用，因此深受开发者和企业的欢迎。

Oracle和MySQL是世界市场占比最高的两种数据库。 

+ Oracle:垄断，有钱的大企业采用，互联网企业之外使用第一。
+  MySQL:互联网高速发展，互联网企业使用第一。

> IOE: IBM的服务器，Oracle数据库，EMC存储设备。都是有钱的公司产品采购，例如银行、电信、石油、证券等大企业。

MySQL发展历程如下：

![image-20220104101544950](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104101544950.png)

MySQL主流分支如下图：

![image-20220104102214521](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104102214521.png)

MySQL从最初的1.0、3.1到后来的8.0，发生了各种各样的变化。被Oracle收购后，MySQL的版本演化出了多个分支，除了需要付费的MySQL企业版本，还有很多MySQL社区版本。

+ 其中一条非常流行的开源分支版本叫Percona Server，它是MySQL的技术支持公司Percona推出的，也是在实际工作中经常碰到的。Percona Server在MySQL官方版本的基础上做了一些补丁和优化，同时推出了一些工具。
+ 另外一个非常不错的版本叫MariaDB，它是MySQL的公司被Oracle收购后，MySQL的创始人Monty先生按原来的思路重新写的一套新数据库，同时也把 InnoDB 引擎作为主要存储引擎，也算 MySQL 的 分支。

### MySQL应用架构演变

业务系统架构的演变过程：随着用户增多，网站的访问量不断增长，整个系统的架构也会从最初的单体架构演变为垂直架构，再到后来的分布式SOA架构和分布式微服务架构，且在这些架构中可以使用集群来提升系统对请求处理的的高并发和高可用，比如应用服务器集群、微服务集群等。

为了提升系统对高并发请求的处理能力，除了前面提到的集群外，数据库的存储和访问也是性能优化非常关键的环节，因为用户的请求发送过来后，需要应用服务器、业务服务器和存储服务器共同配合来完成请求的响应。因此，这里介绍网站在不同的并发访问量级和数据量级下，MySQL应用架构的演变过程。

**架构v1.0-单机单库**

一台服务器安装一个MySQL instance（忽略掉了数据备份的实例），在这个MySQL中存储了系统的所有数据，系统通过数据访问层完成对这台服务器中的数据库的读写操作。适用于简单的小型网站或应用。

![image-20220104184938633](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104184938633.png)

架构v1.0存在的问题：

+ 数据库存储了所有的数据，数据量太大，超出一台服务器的承受能力
+ 读写操作量太大（用户访问量很大），超出一台服务器承受能力
+ 一台服务器挂了，应用也会挂掉（可用性差）

**架构v2.0-主从架构**

3台机器各安装一个MySQL instance，一个主库2个从库，通过主从结构（双主结构也属于特殊的主从）解决了架构v1.0下的高可用和读扩展问题。

+ 主库宕机时，可以把从库会切换成主库来保证高可用；

+ 通过给Instance挂载从库（可以更多）解决读取的压力，主库抗写压力，从库分担读压力，即读写分离。对于写少读多的应用，v2.0主从架构完全能够胜任。

![image-20220104185241609](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104185241609.png)

架构v2.0存在的问题：

+ 数据量太大（虽然采用了主从结构，但是每个数据库存储的仍然是完整数据），超出一台服务器的承受能力
+ 写操作量太大，超出一台M服务器的承受能力

**架构v3.0-分库分表**

架构v1.0和v2.0遇到写入瓶颈和存储瓶颈时，可以通过水平拆分来解决。如下图所示，将UserInfo拆分为3个Sharding，每个Sharding持有总量的1/3数据，3个Sharding数据的总和等于一份完整数据。

> 水平拆分和垂直拆分的区别：垂直拆分后，每一个实例都拥有全部数据；水平拆分后，任何实例都只有全量数据的1/n。

![image-20220104185315742](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104185315742.png)

这种架构的复杂性比较高，需要考虑以下问题：

+ 数据如何路由，即一个请求应该分发给哪个服务器上的数据库；
+ 一个表的数据如何拆分，一般可以采用范围拆分，list拆分，hash拆分等；
+ 如何保持数据的一致性

**架构v4.0-云数据库**

云数据库（云计算）是公司节约成本的一个突破口，对于数据存储的MySQL来说，如何让其成为一个Sass（Software as a service）是关键点。MySQL作为一个Sass服务，服务提供商负责解决可配置性、可扩展性、多用户存储结构设计等疑难问题。

![image-20220104185442848](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104185442848.png)

## MySQL0架构原理

### MySQL体系结构

![image-20220104223151509](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104223151509.png)

MySQL Server自顶向下大致可以分为四层：

+ 网络连接层

  + 客户端连接器（Client Connectors）：提供与MySQL服务器建立连接的支持。目前，支持几乎所有主流的服务端编程语言，比如Java、C、Python等，它们通过各自API与MySQL服务器建立连接。

+ 服务层：MySQL Server的核心，主要包含以下六部分。

  + 连接池（Connection Pool）：负责存储和管理客户端与数据库的连接，一个线程负责管理一个连接（这里还提到了线程池，后续再深入）。

  + 系统管理和控制工具（Management Services & Utilities)：比如备份恢复、安全管理、集群管理等

  + SQL接口（SQL Interface）：用于接受客户端发送的各种SQL命令，并且返回用户查询的结果。比如DML、DDL、存储过程、视图、触发器等。

  + 解析器（Parser）：负责将请求的SQL生成一个“解析树”（词法分析、语法分析），然后根据一些MySQL规则进一步检查解析树是否合法。

  + 查询优化器（Optimizer）：当解析树通过解析器语法检查后，将交给优化器将其转化成执行计划，然后与存储引擎交互。

    > 类似于寻找最优路径，那么究竟是如何优化？
    >
    > 对于select uid,name from user where gender=1;，它会按照选取->投影->联接的策略进行优化。
    >
    > + 先根据where语句进行选取，而不是查询出所有数据再过滤；
    > + 根据uid和name进行属性投影，而不是取出所有字段；
    > + 将两个查询条件联接起来最终生成查询结果。

  + 缓存（Cache&Buffer）：缓存机制是由一系列小缓存组成的。比如表缓存、记录缓存、权限缓存、引擎缓存等。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。

+ 存储引擎层

  + 存储引擎负责MySQL中数据的存储与提取，与底层系统文件进行交互。
  + MySQL的存储引擎是插件式的，服务器中的【查询执行引擎】通过接口与【存储引擎】进行通信，接口屏蔽了不同引擎之间的差异。常见的存储引擎有InnoDB和MyISAM。
  + 存储引擎是针对表的，而不是针对库的，即一个库中的两个表可以使用不同的存储引擎。

+ 系统文件层：负责将数据库的数据和日志存储在文件系统上，并完成与存储引擎的交互，是文件的物理存储层，主要包含以下几部分。

  + 日志文件

    + 错误日志（Error log）： 默认开启，show variables like '%log_err%';
    + 通用查询日志（General query log）：记录一般查询语句，show variables like '%general%';
    + 二进制日志（binary log）：记录了对MySQL数据库执行的更改操作，并且记录了语句的发生时间、执行时长，但它不记录select、show等不修改数据库的SQL。主要用于数据库恢复和主从复制。
      + Show variables like '%log_bin%'; //是否开启
      + Show variables like '%binlog%'; //参数查看
      + Show binary logs; //查看日志文件
    + 慢查询日志（Slow query log）：记录所有执行时间超时的查询SQL，默认为10s。
      + Show variables like '%slow_query%'; //是否开启
      + Show variables like '%long_query_time%'; //时长
      + set long_query_time = 5; //修改时长，其他类似

  + 配置文件

    + 用于存放MySQL所有的配置信息，比如my.cnf、my.ini等。

  + 数据文件：

    + show variables like '%datadir%';  //查看数据文件路径

    + db.opt文件：记录这个库默认使用的字符集和校验规则；

    + frm文件：存储和表相关的元数据（meta）信息，包括表结构的定义信息等，每张表都会有一个.frm文件。

    + MYD文件、MYI文件：MyISAM存储引擎专用，前者用于存放MyISAM表的数据，每张表都会有一个.MYD文件；后者存放MyISAM表的索引相关信息，每一张MyISAM表对应一个.MYI文件。

    + idb文件和IBDATA文件：存放InnoDB的数据文件（包括索引）。

      > InnoDB存储引擎有两种表空间方式：独享表空间和共享表空间（系统表空间）。
      >
      > 独享表空间使用.ibd文件来存放数据，且每一张InnoDB表对应一个.ibd文件；共享表空间使用.ibdata文件，所有表共同使用一个/多个（自行配置）.ibdata文件。

    + ibdata1文件：系统表空间数据文件，用于存储表元数据、Undo日志等；

    + ib_logfile0、ib_logfile1文件：Redo log日志文件。

  + pid文件

    + pid文件是mysqld应用程序在Unix/Linux环境下的一个进程文件，和其他Unix/Linux服务端程序一样，它存放着自己的进程id。

  + socket文件

    + socket文件也是在Unix/Linux环境下才有的，用户在Unix/Linux环境下客户端可以不通过TCP/IP而直接使用Unix Socket来连接MySQL。
    + mysql的服务端和客户端在同一host（物理服务器）上的时候，使用unix socket做为通讯协议的载体，它比tcp快。

### MySQL运行机制

![image-20220105171113016](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220105171113016.png)

建立连接（Connectors & Connection Pool）

+ 客户端通过C/S通信协议与MySQL建立连接，MySQL客户端与服务器的通信方式是“半双工”。对于每一个MySQL连接，时刻都有一个线程状态来标识这个连接正在做什么。

  > 通信机制：
  >
  > + 全双工：客户端（或服务器）能同时发送和接收数据，例如平时打电话；
  > + 半双工：某一时刻，要么发送数据，要么接受数据，不能同时，比例早期的对讲机。
  > + 单工：只能发送数据或只能接收数据，比如单行道。
  >
  > 线程状态：
  >
  > + Show processlist; //查看正在运行的线程信息（查看谁连接了MySQL服务端，连接状态什么样），其中root用户可以查看所有线程，其他用户只能查看自己的
  > + 各个参数具体介绍：
  >   + id：线程ID，可以使用kill xx将其杀掉
  >   + user：启动这个线程的用户
  >   + Host：发送请求的客户端IP和端口
  >   + db：当前命令在哪个库执行
  >   + Command：该线程正在执行的操作命令
  >     + Create DB：正在创建库
  >     + Drop DB：正在删除库
  >     + Execute：正在执行一个PreparedStatement
  >     + Close Stmt：正在关闭一个PreparedStatement
  >     + Query：正在执行一个语句
  >     + Sleep：正在等待客户端发送语句
  >     + quit：该线程正在退出
  >     + Shutdown：正在关闭服务器
  >   + Time：该线程处于当前状态的时间，单位是秒
  >   + State：线程状态
  >     + Updating：正在搜索匹配记录，进行修改
  >     + Sleeping：正在等待客户端发送新请求
  >     + Starting：正在进行请求处理
  >     + Checking table：正在检查数据表
  >     + Closing table：正在将表中数据刷到磁盘中
  >     + Locked：被其他查询锁住了记录
  >     + Sending Data：正在处理select查询，同时将结果发送给客户端
  >   + Info：一般记录线程执行的语句，默认显示前100个字符，想查看完整的使用show full processlist。
  > + show status like '%Threads%'; 查询连接当前MySQL服务器的客户端数量

+ 查询缓存（Cache&Buffer）：MySQL对查询的优化，如果开启了查询缓存且查询到完全相同的SQL，则将查询结果直接返回给客户端；如果没有开启查询缓存或没有查询到完全相同的SQL，就会由解析器进行语法语义分析，并生成“解析树”。

  + 缓存select查询的结果和SQL语句

  + 执行select查询时，先查询缓存，要求完全相同（包括参数），这样才会命中缓存数据。

  + 即使开启查询缓存，以下SQL也不能缓存

    1. 查询语句使用SQL_NO_CACHE

    2. 查询的结果大于query_cache_limit设置
    3. 查询中有一些不确定的参数，比如now()。

  + Show variables like '%query_cache%'; //查看缓存是否开启，空间大小等

  + Show status like 'Qcache%'; //查看更详细的缓存参数，可用缓存空间，缓存块等

+ 解析器（Parser)：将客户端发送的SQL进行词法、语法分析，生成“解析树”。预处理器根据一些MySQL规则进一步检查“解析树”是否合法，比如检查数据表和数据列是否存在，还会解析名字和别名，看看它们是否有歧义，最后生成新的“解析树”。

+ 查询优化器（Optimizer）：根据“解析树”生成最优的执行计划，使用的优化策略可以分为两类：静态优化（编译时优化）、动态优化（运行时优化）。

  + 等价变换策略
    + 5=5 and a > 5 改成 a > 5；
    + a < b and a = 5 改成 b > 5 and a = 5；
    + 基于联合索引，调整条件顺序等。
  + 优化count、min、max等函数
    + InnoDB引擎min函数只需要找索引最左边，max函数只需要找索引最右边；
    + MyISAM引擎count(*)不需要计算，直接返回。
  + 提前终止查询：使用了limit查询，获取到limit所需的数据后，就不再继续遍历后面的数据。
  + in的优化：先进行排序，再采用二分法查找数据。比如where id in (2,1,3) 改成 where id in (1,2,3)。

+ 查询执行引擎：负责执行SQL语句，查询执行引擎会根据SQL中表的存储引擎类型，通过对应的API接口与底层存储引擎或物理文件进行交互，得到查询结果并返回给客户端。如果返回结果过多，采用增量模式返回（有点分页的味道）。

  > 如果开启查询缓存，会将SQL和结果完整地保存到查询缓存（Cache & Buffer）中，再将查询结果返回给客户端。这样如果以后有相同的SQL语句执行，则直接返回结果。

### MySQL存储引擎

存储引擎在MySQL的体系架构中位于第三层，负责MySQL中数据的存储和提起，是与文件打交道的子系统，它是根据MySQL提供的【文件访问层抽象接口】定制的一种文件访问机制，这种机制就叫存储引擎。

使用show engines命令可以查看当前数据库支持的引擎信息。

![image-20220107164506010](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220107164506010.png)

> MySQL5.5之前默认采用MyISAM存储引擎，从MySQL5.5开始采用InnoDB存储引擎。

各存储引擎特点：

+ InnoDB：支持事务，具有提交、回滚和崩溃恢复能力，即事务安全
+ MyISAM：不支持事务和外键，访问速度快，适合查询多的场景
+ Memory：利用内存创建表，因为数据在内存，默认使用Hash索引，所以访问速度非常快。但一旦关闭，数据就会丢失。
+ Archive：归档类型引擎，仅能支持insert和select语句。
+ Csv：以CSV文件进行数据存储，由于文件限制，所有列必须强制指定not null，另外CSV引擎也不支持索引和分区，适合做数据交换的中间表。
+ BlackHole：黑洞，只进不出，进来消失，所有插入的数据都不会保存，但binlog中会有操作记录。搞不懂有啥用！
+ Federated：用来访问远端MySQL数据库中的表。本地表不保存数据，访问远程表内容。
+ MRG_MyISAM：一组MyISAM表的组合，这些MyISAM表必须结构相同，MRG表本身没有数据，但对MRG表的操作就可以对一组MyISAM表进行操作。

#### InnoDB和MyISAM对比

InnoDB和MyISAM是MySQL中最常用的两种存储引擎，两者的区别如下：

+ 事务和外键

  + InnoDB支持事务和外键，通过事务保证了数据的安全性和完整性，适合大量insert或update操作；
  + MyISAM不支持事务和外键，提供高速存储和检索，适合大量的select操作。

+ 锁机制

  + InnoDB支持行级锁，锁定指定记录。基于索引来加锁实现（不是太理解！）；
  + MyISAM支持表级锁，锁定整张表。

+ 索引结构

  + InnoDB使用聚簇索引，索引和记录在一起存储，既缓存索引值，也缓存记录；
  + MyISAM使用非聚簇索引，索引和记录分开。

+ 并发处理能力

  + MyISAM使用表锁，会导致写操作并发率低，读之间并不阻塞，读写阻塞；

  + InnoDB读写阻塞范围与隔离级别有关，可以采用多版本并发控制（MVCC）来支持高并发

+ 存储文件

  + InnoDB表对应两个文件：一个.frm表结构文件，一个.ibd数据文件。InnoDB表最大支持64TB；
  + MyISAM表对应三个文件：一个.frm表结构文件，一个.MYD表数据文件，一个.MYI索引文件。MySQL5..0开始默认限制256TB。



两种存储引擎的适用场景：

+ MyISAM
  + 不需要事务支持
  + 并发相对较低（表锁）
  + 数据修改相对较少，以读为主
  + 数据一致性要求不高
+ InnoDB
  + 需要事务支持
  + 行级锁对高并发有很好的适应能力
  + 数据更新较为频繁的场景
  + 数据一致性要求较高
  + 硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存利用率，减少磁盘IO。



两种引擎该如何选择？

+ 是否需要事务？有，InnoDB
+ 是否存在并发修改？有，InnoDB
+ 是否追求快速查询，且数据修改少？是，MyISAM，当然也可以选择InnoDB
+ 在绝大多数情况下，推荐使用InnoDB。



各个存储引擎特性对比如下图：

![image-20220107165735605](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220107165735605.png)

#### InnoDB存储结构

从MySQL5.5开始默认使用InnoDB作为存储引擎，它擅长事务处理，具有自动崩溃恢复的特性。下面是官网提供的InnoDB引擎架构图，主要分为内存结构和磁盘结构两大部分。

![image-20220107184350645](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220107184350645.png)

##### InnoDB内存结构

如上图所示，InnoDB的内存结构主要包括Buffer Pool、Change Buffer、Adaptive Hash Index和Log Buffer四大组件。

**Buffer Pool**

缓存池，简称BP，BP以page（页，默认大小为16K）为单位，底层采用链表管理Page。在InnoDB访问表记录和索引时会在page页中缓存（优化读操作），以后使用可以减少IO操作，提升效率。

1. page管理机制

   + Page根据状态可以分为三种类型：

     + free page：空闲page，未被使用；
     + clean page：被使用page，数据没被修改过；
     + dirty page：脏页，被使用的page，数据被修改过，页中数据和磁盘中的数据不一致

   + 针对上述三种page类型，InnoDB通过三种链表结构来维护和管理：

     + free list：表示空闲缓冲区，管理free page；
     + flush list：表示需要刷新到磁盘的缓冲区，管理dirty page，内部page按修改时间排序(最新修改的page在flush list的头部，最早修改的page在flush list的尾部，刷盘时从尾部开始)。
     + lru list：表示正在使用的缓冲区，管理clean page和dirty page。该缓冲区以midpoint为基点，前面链表称为new列表区，存放经常访问的数据，占63%；后面的链表称为old列表区，存放使用较少的数据，占37%。

     > 注意：
     >
     > + 脏页（dirty page）既存在于flush链表，也在lru链表中，但是两种互不影响，lru链表负责管理page的可用性和释放，而flush链表负责管理脏页的刷盘操作。
     > + 两者也是有联系的：当触发刷盘操作时，会把对应page从lru list移除；当某些page淘汰时，也会触发对应page的刷盘操作。

   + 通过show engine innodb status \G;可以查看innnodb引擎的状态，如下：

     ```mysql
     ----------------------
     BUFFER POOL AND MEMORY
     ----------------------
     Total large memory allocated 140836864
     Dictionary memory allocated 131981
     Buffer pool size   8191 // Buffer Pool共有8191个page 
     Free buffers       7907 // free page的数量
     Database pages     284 // clean page + dirty page的数量，即lru list管理的page
     Old database pages 0 // lru list中old区的page数量
     Modified db pages  0 // dirty page的数量
     Pending reads      0
     Pending writes: LRU 0, flush list 0, single page 0
     Pages made young 0, not young 0
     0.00 youngs/s, 0.00 non-youngs/s
     Pages read 215, created 69, written 187
     0.00 reads/s, 0.00 creates/s, 0.00 writes/s
     No buffer pool page gets since the last printout
     Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
     LRU len: 284, unzip_LRU len: 0
     I/O sum[0]:cur[0], unzip sum[0]:cur[0]
     ```

     从上面可知，Buffer pool size.= Free buffers + Database pages，但也可能大于，因为BP中的某些page可能会分配给Adaptive Hash Index和Change Buffer。

2. page空间释放（改进型LRU算法）
   + 普通lru：末尾淘汰法，新数据从链表头部加入，释放空间时从末尾淘汰；
   + 改性lru：链表分为new和old两个部分，加入元素时并不是从链表头部插入，而是从中间midpoint位置插入。如果数据数据很快被访问，那么page就会向new列表头部移动；如果数据没有被访问，page会逐步向old尾部移动，等待淘汰。释放空间时依然从尾部淘汰。
   + 每当有新的page数据读取到buffer pool时，InnoDB引擎会判断空闲页是否足够，如果有，就将free page从free list列表删除，放入到lru链表中；如果没有空闲页，就会根据lru算法淘汰掉lru链表末尾的页，将内存空间释放分配给新的页。

3. Buffer Pool配置参数

   + show variables like '%innodb_page_size%'; //查看page页大小

     > 对于确定的参数，可以使用select @@innodb_page_size/1.24;来查看。

   + show variables like '%innodb_old%'; //查看lru list中old列表所占比例

   + show variables like '%innodb_buffer%'; //查看buffer pool参数

     > 具体关系是innnodb_buffer_pool_size分为几个innnodb_buffer_pool_instances，每个innodb_buffer_pool_instances分为几个innodb_buffer_pool_chunk_size，每个innodb_buffer_pool_chunk_size分为几个innodb_page_size。

   > 建议：将innnodb_buffer_pool_size设置为总内存大小的60%-80%，innodb_buffer_pool_instances可以设置为多个，这样当较多数据加载到内存时，使用多个实例可以降低缓存竞争。

**Change Buffer**

写缓冲区，简称CB。在进行DML操作时，如果BP没有相应的page数据，并不会立刻将磁盘页加载到缓冲池BP，而是在CB记录缓冲变更，等将来数据被读取时，再将数据合并恢复到BP中（优化写操作）。

+ Change buffer占用Buffer Pool空间，默认为25%，最大允许占50%，可以根据读写业务量来进行调整（写多读少时增大该参数），参数为innodb_change_buffer_max_size;

+ 当更新一条记录时，会存在以下两种情况：

  + 如果该记录在Buffer Pool中存在，直接在BP中修改，一次内存操作；
  + 如果该记录在Buffer Pool中不存在（没有命中），会直接在Change Buffer进行一次内存操作，不用再去磁盘查询数据，避免一次磁盘IO。当下次查询记录时，会先进行磁盘读取，然后再从CB中读取信息合并，最终载入Buffer Pool中。
  
  > 【注意】：写缓冲区仅适用于非唯一的普通索引页！
  >
  > 如果给索引设置唯一性，在进行修改时，InnoDB必须要做唯一性校验，因此必须查询磁盘，做一次IO操作。即直接将记录查询到Buffer Pool中，并在缓冲池BP中修改，而不会在写缓冲Change Buffer中操作。

**Adaptive Hash Index**

自适应哈希索引，用于优化对BP数据的查询。InnoDB存储引擎会监控对表上二级索引（索引页）的查找，如果发现某二级索引被频繁访问，建立哈希索引可以带来速度的提升，就会建立哈希索引（key是频繁访问的索引键值，value为该索引键值匹配的完整记录所在的数据页编号和页偏移量），所以称之为自适应，即InnoDB存储引擎会自动根据访问的频率和模式为某些数据页建立哈希索引。

![image-20220110102832502](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220110102832502.png)

**Log Buffer**

日志缓冲区，用来保存要写入到磁盘上的日志文件（Redo Log）的数据，日志缓冲区的内容定期刷新到磁盘上的日志文件中。

+ Log Buffer主要用于记录DML操作时InnoDB引擎产生的Redo日志。

+ Log Buffer空间满了，会自动刷新到磁盘。

+ 当遇到BLOB或多行更新的大事务操作时，通过增加日志缓冲区（innodb_log_buffer_size）可以减少磁盘IO。（ 但不要设置过大，否则一旦mysql服务器宕机，恢复的时间太长，一般设置为16M。）

+ Innodb_flush_log_at_trx_commit参数控制日志刷新行为，默认为1

  + 0：每隔1s写日志文件和刷盘，即最多丢失1s数据；
  + 1：事务提交，立刻写日志文件和刷盘，数据不丢失，但是会频繁IO操作；
  + 2：事务提交，立刻写日志文件，每隔1s进行一次刷盘操作

  > 注意：写日志文件指从Log Buffer到OS cache，刷盘指从OS cache到磁盘文件。（与此不同的是，Buffer Pool中的数据通过O_DIRECT可以直接写入到磁盘，而无需先写入到OS_cache）
  
+ 通过show variables like 'innodb_log%'; 和 show variables like 'innodb_flush_log%';可以看到更多参数。

##### InnoDB磁盘结构

**表空间**（Tablespaces）：用来存储表结构和数据。

+ 系统表空间（System Tablespace）：是下面四部分的存储区域，还包含用户在系统表空间中创建的表和索引数据（如果有）。它是一个被多个表共享的表空间，该空间的数据文件通过参数innodb_data_file_path控制，默认值是ibdata1:12M:autoextend。

  + 数据字典（InnoDB Data Dictionary）

    InnoDB数据字典由内部系统表组成，这些表包含用于查找表、索引和表字段等对象的元数据，这些元数据实际上存放在InnoDB系统表空间中，但由于历史原因，这些元数据在一定程度上与InnoDB表元数据文件(.frm)中存储的信息重叠。

  + 双写缓冲区（Doublewrite Buffer）

    位于系统表空间的一个存储区域。在Buffer Pool的page刷新到磁盘上的真正表文件前，会先将数据存放到Doublewrite缓冲区（这不也是写磁盘吗？怎为什么比写表文件快？）。如果在page写入过程中出现操作系统、存储子系统或mysql进程崩溃，InnoDB可以在崩溃恢复期间从Doublewrite缓冲区找到page的一个备份。在大多数情况下，默认启动双写缓冲区，禁用Doublewrite缓冲区只需将innodb_doublewrite设置为0。

    > 注意：使用Doublewrite缓冲区时建议将innodb_flush_method设置为O_DIRECT。
    >
    > MySQL的innodb_flush_method参数控制着innnodb数据文件及redo log的打开、刷写模式，可能的取值有三个：
    >
    > + fdatasync：默认，先写入操作系统缓存OS_Cache，再调用fsync()函数异步将数据文件与redo log的缓存到磁盘文件。
    > + O_DIRECT：数据文件写入操作会通知操作系统不要缓存数据，也不要预读，直接从Innodb Buffer写到磁盘文件。
    > + O_DSYNC

  + 写缓冲区（Change Buffer）

  + 撤销日志（Undo Logs）

    指事务开始前保存的被修改数据的备份，用于回滚事务。

    撤销日志属于逻辑日志，记录每行记录的改变，存在于系统表空间、临时表空间和撤销表空间。

+ 独立表空间（File-Per-Table Tablespaces）

  当Innodb_file_per_table选项开启时（默认开启），表将被创建于独立表空间中，否则将被创建于系统表空间中。每个表的独立表空间由一个.ibd数据文件代表，该文件默认创建于对应数据库目录中。

  在独立表空间中创建的表使用Barracuda文件格式，这种文件格式支持动态和压缩行格式。（搞不懂，后续研究！）

+ 通用表空间（General Tablespaces）

  指通过create tablespace语法创建的共享表空间，它可以创建于数据目录data之外，可以容纳多张表，且支持所有的行格式。

  注：很少使用，了解即可。

  ```sql
  # 创建通用表空间ts1(ts1.ibd默认会放到data目录，当然可以指定到其他目录)
  create tablespace ts1 add datafile 'ts1.ibd' engine=innodb;
  # 创建表t1并添加到ts1表空间
  create table t1(a int primary key tablespace ts1;
  # 删除表
  drop table t1;
  # 删除表空间
  drop tablespace ts1;
  ```

+ 临时表空间（Temporary Tablespaces）

  临时表空间分为session和global临时表空间两种。session临时表空间存储的是用户创建的临时表和优化程序创建的内部临时表，global临时表空间存储的是用户临时表的回滚段（rollback segments）。mysql服务器正常关闭或异常终止时，临时表空间将被移除，每次启动时会被重新创建。(搞不太懂，后续研究！)

+ 撤销表空间（Undo Tablespaces）

  Undo空间包含很多undo日志，在MySQL5.7之前undo日志占用System Tablespace，从MySQL5.7开始可以将undo日志从System Table分离出来，这由innodb_undo_tablespaces选项进行控制，默认为0，表示使用系统表空间。如果该参数大于0，表示使用Undo表空间undo_001、undo_002等。

**重做日志**（Redo Log）

重做日志是一种基于磁盘的数据结构，用于崩溃恢复期间更正不完整事务写入的数据。MySQL将重做日志以循环方式写入文件，记录了InnoDB中所有对Buffer Pool修改的日志。

当出现实例故障，比如断电，导致数据未能更新到数据文件，那么数据库重启时就会重做redo文件中的操作，然后重新把数据更新到数据文件。

读写事务在执行过程中，都会不断产生redo log，默认情况下，重做日志在磁盘上由ib_logfile0和ib_logfile1文件物理表示（读事务也会产生redo log？）。

##### InnoDB结构演变

![image-20220107185732954](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220107185732954.png)

MySQL5.7版本

+ 通过修改innodb_undo_tablespaces选项可以将Undo表空间从System表空间中分离出来，可以在安装MySQL时由用户自行指定文件大小和数量；
+ 增加了temporary临时表空间，里面存储着临时表和临时查询结果集数据；
+ Buffer Pool大小可以动态修改，无需重启数据库实例。

MySQL8.0版本

+ 将InnoDB表的数据字典和Undo Logs都从System表空间ibdata1彻底分离出来，以前需要System表空间ibdata1中的数据字典与独立表空间ibd文件中的的数据字典(.frm???)一致才行，8.0版本就不要了。
+ 将Doublewrite Buffer从System表空间中分离出来了。
+ 用户可以像Oracle一样设置一些表空间，每个表空间对应多个物理文件，每个表空间可以给多个表使用，但是一个表只能存储在一个表空间中。

#### InnoDB线程模型

#### InnoDB数据文件

![image-20220109200204005](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220109200204005.png)

![image-20220109200502486](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220109200502486.png)

#### Undo Log

#### Redo Log和Binlog

## MySQL索引原理

### 索引类型

### 索引原理

### 索引分析与优化

### 查询优化

## MySQL事务和锁

### ACID特性

### 事务控制的演进

#### 并发事务

#### 排队

#### 排他锁

#### 读写锁

#### MVCC

### 事务隔离级别

### 锁机制和实战

## MySQL集群架构



