---
layout: post 
author: oshacker
title: MySQL高级系统学习笔记
category: database
tags: [cs,datebase]
excerpt: 流水账，不喜勿喷😄

---

## 前言

### 必备基础知识

MySQL软件下载和安装（我使用5.7.30）

熟悉MySQL工具和基本SQL操作

+ windows：MySQL WorkBench、Navicat、SQLyog
+ Linux：MySQL WorkBench、Navicat
+ Mac：Navicat、Sequel Pro

熟悉主键、外键、非空、唯一等约束

熟悉索引、事务概念和基本使用

### 主要学习内容

MySQL架构原理和存储机制

+ MySQL体系结构（内存结构、磁盘结构）、SQL运行机制、存储引擎、Undo/Redo Log等

MySQL索引存储机制和工作原理

+ 索引存储结构、索引查询原理、索引分析和优化、查询优化等

MySQL事务和锁工作原理

+ 事务隔离级别、事务并发处理、锁机制和实战等

MySQL集群架构及相关原理

+ 集群架构设计理念、主动架构、双主架构、分库分表等

互联网海量数据处理实战

+ ShardingSphere、MyCat中间件实战操作、分库分表实战

MySQL第三方工具实战

+ 同步工具、运维工具、监控工具等

### MySQL起源和分支

MySQL 是最流行的关系型数据库软件之一，由于其体积小、速度快、开源免费、简单易用、维护成本低等，在集群架构中易于扩展、高可用，因此深受开发者和企业的欢迎。

Oracle和MySQL是世界市场占比最高的两种数据库。 

+ Oracle:垄断，有钱的大企业采用，互联网企业之外使用第一。
+  MySQL:互联网高速发展，互联网企业使用第一。

> IOE: IBM的服务器，Oracle数据库，EMC存储设备。都是有钱的公司产品采购，例如银行、电信、石油、证券等大企业。

MySQL发展历程如下：

![image-20220104101544950](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104101544950.png)

MySQL主流分支如下图：

![image-20220104102214521](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104102214521.png)

MySQL从最初的1.0、3.1到后来的8.0，发生了各种各样的变化。被Oracle收购后，MySQL的版本演化出了多个分支，除了需要付费的MySQL企业版本，还有很多MySQL社区版本。

+ 其中一条非常流行的开源分支版本叫Percona Server，它是MySQL的技术支持公司Percona推出的，也是在实际工作中经常碰到的。Percona Server在MySQL官方版本的基础上做了一些补丁和优化，同时推出了一些工具。
+ 另外一个非常不错的版本叫MariaDB，它是MySQL的公司被Oracle收购后，MySQL的创始人Monty先生按原来的思路重新写的一套新数据库，同时也把 InnoDB 引擎作为主要存储引擎，也算 MySQL 的 分支。

### MySQL应用架构演变

业务系统架构的演变过程：随着用户增多，网站的访问量不断增长，整个系统的架构也会从最初的单体架构演变为垂直架构，再到后来的分布式SOA架构和分布式微服务架构，且在这些架构中可以使用集群来提升系统对请求处理的的高并发和高可用，比如应用服务器集群、微服务集群等。

为了提升系统对高并发请求的处理能力，除了前面提到的集群外，数据库的存储和访问也是性能优化非常关键的环节，因为用户的请求发送过来后，需要应用服务器、业务服务器和存储服务器共同配合来完成请求的响应。因此，这里介绍网站在不同的并发访问量级和数据量级下，MySQL应用架构的演变过程。

**架构v1.0-单机单库**

一台服务器安装一个MySQL instance（忽略掉了数据备份的实例），在这个MySQL中存储了系统的所有数据，系统通过数据访问层完成对这台服务器中的数据库的读写操作。适用于简单的小型网站或应用。

![image-20220104184938633](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104184938633.png)

架构v1.0存在的问题：

+ 数据库存储了所有的数据，数据量太大，超出一台服务器的承受能力
+ 读写操作量太大（用户访问量很大），超出一台服务器承受能力
+ 一台服务器挂了，应用也会挂掉（可用性差）

**架构v2.0-主从架构**

3台机器各安装一个MySQL instance，一个主库2个从库，通过主从结构（双主结构也属于特殊的主从）解决了架构v1.0下的高可用和读扩展问题。

+ 主库宕机时，可以把从库会切换成主库来保证高可用；

+ 通过给Instance挂载从库（可以更多）解决读取的压力，主库抗写压力，从库分担读压力，即读写分离。对于写少读多的应用，v2.0主从架构完全能够胜任。

![image-20220104185241609](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104185241609.png)

架构v2.0存在的问题：

+ 数据量太大（虽然采用了主从结构，但是每个数据库存储的仍然是完整数据），超出一台服务器的承受能力
+ 写操作量太大，超出一台M服务器的承受能力

**架构v3.0-分库分表**

架构v1.0和v2.0遇到写入瓶颈和存储瓶颈时，可以通过水平拆分来解决。如下图所示，将UserInfo拆分为3个Sharding，每个Sharding持有总量的1/3数据，3个Sharding数据的总和等于一份完整数据。

> 水平拆分和垂直拆分的区别：垂直拆分后，每一个实例都拥有全部数据；水平拆分后，任何实例都只有全量数据的1/n。

![image-20220104185315742](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104185315742.png)

这种架构的复杂性比较高，需要考虑以下问题：

+ 数据如何路由，即一个请求应该分发给哪个服务器上的数据库；
+ 一个表的数据如何拆分，一般可以采用范围拆分，list拆分，hash拆分等；
+ 如何保持数据的一致性

**架构v4.0-云数据库**

云数据库（云计算）是公司节约成本的一个突破口，对于数据存储的MySQL来说，如何让其成为一个Sass（Software as a service）是关键点。MySQL作为一个Sass服务，服务提供商负责解决可配置性、可扩展性、多用户存储结构设计等疑难问题。

![image-20220104185442848](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104185442848.png)

## MySQL0架构原理

### MySQL体系结构

![image-20220104223151509](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104223151509.png)

MySQL Server自顶向下大致可以分为四层：

+ 网络连接层

  + 客户端连接器（Client Connectors）：提供与MySQL服务器建立连接的支持。目前，支持几乎所有主流的服务端编程语言，比如Java、C、Python等，它们通过各自API与MySQL服务器建立连接。

+ 服务层：MySQL Server的核心，主要包含以下六部分。

  + 连接池（Connection Pool）：负责存储和管理客户端与数据库的连接，一个线程负责管理一个连接（这里还提到了线程池，后续再深入）。

  + 系统管理和控制工具（Management Services & Utilities)：比如备份恢复、安全管理、集群管理等

  + SQL接口（SQL Interface）：用于接受客户端发送的各种SQL命令，并且返回用户查询的结果。比如DML、DDL、存储过程、视图、触发器等。

  + 解析器（Parser）：负责将请求的SQL生成一个“解析树”（词法分析、语法分析），然后根据一些MySQL规则进一步检查解析树是否合法。

  + 查询优化器（Optimizer）：当解析树通过解析器语法检查后，将交给优化器将其转化成执行计划，然后与存储引擎交互。

    > 类似于寻找最优路径，那么究竟是如何优化？
    >
    > 对于select uid,name from user where gender=1;，它会按照选取->投影->联接的策略进行优化。
    >
    > + 先根据where语句进行选取，而不是查询出所有数据再过滤；
    > + 根据uid和name进行属性投影，而不是取出所有字段；
    > + 将两个查询条件联接起来最终生成查询结果。

  + 缓存（Cache&Buffer）：缓存机制是由一系列小缓存组成的。比如表缓存、记录缓存、权限缓存、引擎缓存等。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。

+ 存储引擎层

  + 存储引擎负责MySQL中数据的存储与提取，与底层系统文件进行交互。
  + MySQL的存储引擎是插件式的，服务器中的【查询执行引擎】通过接口与【存储引擎】进行通信，接口屏蔽了不同引擎之间的差异。常见的存储引擎有InnoDB和MyISAM。
  + 存储引擎是针对表的，而不是针对库的，即一个库中的两个表可以使用不同的存储引擎。

+ 系统文件层：负责将数据库的数据和日志存储在文件系统上，并完成与存储引擎的交互，是文件的物理存储层，主要包含以下几部分。

  + 日志文件

    + 错误日志（Error log）： 默认开启，show variables like '%log_err%';
    + 通用查询日志（General query log）：记录一般查询语句，show variables like '%general%';
    + 二进制日志（binary log）：记录了对MySQL数据库执行的更改操作，并且记录了语句的发生时间、执行时长，但它不记录select、show等不修改数据库的SQL。主要用于数据库恢复和主从复制。
      + Show variables like '%log_bin%'; //是否开启
      + Show variables like '%binlog%'; //参数查看
      + Show binary logs; //查看日志文件
    + 慢查询日志（Slow query log）：记录所有执行时间超时的查询SQL，默认为10s。
      + Show variables like '%slow_query%'; //是否开启
      + Show variables like '%long_query_time%'; //时长
      + set long_query_time = 5; //修改时长，其他类似

  + 配置文件

    + 用于存放MySQL所有的配置信息，比如my.cnf、my.ini等。

  + 数据文件：

    + show variables like '%datadir%';  //查看数据文件路径

    + db.opt文件：记录这个库默认使用的字符集和校验规则；

    + frm文件：存储和表相关的元数据（meta）信息，包括表结构的定义信息等，每张表都会有一个.frm文件。

    + MYD文件、MYI文件：MyISAM存储引擎专用，前者用于存放MyISAM表的数据，每张表都会有一个.MYD文件；后者存放MyISAM表的索引相关信息，每一张MyISAM表对应一个.MYI文件。

    + idb文件和IBDATA文件：存放InnoDB的数据文件（包括索引）。

      > InnoDB存储引擎有两种表空间方式：独享表空间和共享表空间（系统表空间）。
      >
      > 独享表空间使用.ibd文件来存放数据，且每一张InnoDB表对应一个.ibd文件；共享表空间使用.ibdata文件，所有表共同使用一个/多个（自行配置）.ibdata文件。

    + ibdata1文件：系统表空间数据文件，用于存储表元数据、Undo日志等；

    + ib_logfile0、ib_logfile1文件：Redo log日志文件。

  + pid文件

    + pid文件是mysqld应用程序在Unix/Linux环境下的一个进程文件，和其他Unix/Linux服务端程序一样，它存放着自己的进程id。

  + socket文件

    + socket文件也是在Unix/Linux环境下才有的，用户在Unix/Linux环境下客户端可以不通过TCP/IP而直接使用Unix Socket来连接MySQL。

### MySQL运行机制

![image-20220105171113016](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220105171113016.png)

建立连接（Connectors & Connection Pool）

+ 客户端通过C/S通信协议与MySQL建立连接，MySQL客户端与服务器的通信方式是“半双工”。对于每一个MySQL连接，时刻都有一个线程状态来标识这个连接正在做什么。

  > 通信机制：
  >
  > + 全双工：客户端（或服务器）能同时发送和接收数据，例如平时打电话；
  > + 半双工：某一时刻，要么发送数据，要么接受数据，不能同时，比例早期的对讲机。
  > + 单工：只能发送数据或只能接收数据，比如单行道。
  >
  > 线程状态：
  >
  > + Show processlist; //查看正在运行的线程信息（查看谁连接了MySQL服务端，连接状态什么样），其中root用户可以查看所有线程，其他用户只能查看自己的
  > + 各个参数具体介绍：
  >   + id：线程ID，可以使用kill xx将其杀掉
  >   + user：启动这个线程的用户
  >   + Host：发送请求的客户端IP和端口
  >   + db：当前命令在哪个库执行
  >   + Command：该线程正在执行的操作命令
  >     + Create DB：正在创建库
  >     + Drop DB：正在删除库
  >     + Execute：正在执行一个PreparedStatement
  >     + Close Stmt：正在关闭一个PreparedStatement
  >     + Query：正在执行一个语句
  >     + Sleep：正在等待客户端发送语句
  >     + quit：该线程正在退出
  >     + Shutdown：正在关闭服务器
  >   + Time：该线程处于当前状态的时间，单位是秒
  >   + State：线程状态
  >     + Updating：正在搜索匹配记录，进行修改
  >     + Sleeping：正在等待客户端发送新请求
  >     + Starting：正在进行请求处理
  >     + Checking table：正在检查数据表
  >     + Closing table：正在将表中数据刷到磁盘中
  >     + Locked：被其他查询锁住了记录
  >     + Sending Data：正在处理select查询，同时将结果发送给客户端
  >   + Info：一般记录线程执行的语句，默认显示前100个字符，想查看完整的使用show full processlist。

+ 查询缓存（Cache&Buffer）：MySQL对查询的优化，如果开启了查询缓存且查询到完全相同的SQL，则将查询结果直接返回给客户端；如果没有开启查询缓存或没有查询到完全相同的SQL，就会由解析器进行语法语义分析，并生成“解析树”。

  + 缓存select查询的结果和SQL语句

  + 执行select查询时，先查询缓存，要求完全相同（包括参数），这样才会命中缓存数据。

  + 即使开启查询缓存，以下SQL也不能缓存

    1. 查询语句使用SQL_NO_CACHE

    2. 查询的结果大于query_cache_limit设置
    3. 查询中有一些不确定的参数，比如now()。

  + Show variables like '%query_cache%'; //查看缓存是否开启，空间大小等

  + Show status like 'Qcache%'; //查看更详细的缓存参数，可用缓存空间，缓存块等

+ 解析器（Parser)：将客户端发送的SQL进行词法、语法分析，生成“解析树”。预处理器根据一些MySQL规则进一步检查“解析树”是否合法，比如检查数据表和数据列是否存在，还会解析名字和别名，看看它们是否有歧义，最后生成新的“解析树”。

+ 查询优化器（Optimizer）：根据“解析树”生成最优的执行计划，使用的优化策略可以分为两类：静态优化（编译时优化）、动态优化（运行时优化）。

  + 等价变换策略
    + 5=5 and a > 5 改成 a > 5；
    + a<b and a=5 改成 b > 5 and a = 5；
    + 基于联合索引，调整条件顺序等。
  + 优化count、min、max等函数
    + InnoDB引擎min函数只需要找索引最左边，max函数只需要找索引最右边；
    + MyISAM引擎count(*)不需要计算，直接返回。
  + 提前终止查询：使用了limit查询，获取到limit所需的数据后，就不再继续遍历后面的数据。
  + in的优化：先进行排序，再采用二分法查找数据。比如where id in (2,1,3) 改成 where id in (1,2,3)。

+ 查询执行引擎：负责执行SQL语句，查询执行引擎会根据SQL中表的存储引擎类型，通过对应的API接口与底层存储引擎或物理文件进行交互，得到查询结果并返回给客户端。如果返回结果过多，采用增量模式返回（有点分页的味道）。

  > 如果开启查询缓存，会将SQL和结果完整地保存到查询缓存（Cache & Buffer）中，再将查询结果返回给客户端。这样如果以后有相同的SQL语句执行，则直接返回结果。

### MySQL存储引擎

存储引擎在MySQL的体系架构中位于第三层，负责MySQL中数据的存储和提起，是与文件打交道的子系统，它是根据MySQL提供的【文件访问层抽象接口】定制的一种文件访问机制，这种机制就叫存储引擎。

使用show engines命令可以查看当前数据库支持的引擎信息。

![image-20220107164506010](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220107164506010.png)

> MySQL5.5之前默认采用MyISAM存储引擎，从MySQL5.5开始采用InnoDB存储引擎。

各存储引擎特点：

+ InnoDB：支持事务，具有提交、回滚和崩溃恢复能力，即事务安全
+ MyISAM：不支持事务和外键，访问速度快，适合查询多的场景
+ Memory：利用内存创建表，因为数据在内存，默认使用Hash索引，所以访问速度非常快。但一旦关闭，数据就会丢失。
+ Archive：归档类型引擎，仅能支持insert和select语句。
+ Csv：以CSV文件进行数据存储，由于文件限制，所有列必须强制指定not null，另外CSV引擎也不支持索引和分区，适合做数据交换的中间表。
+ BlackHole：黑洞，只进不出，进来消失，所有插入的数据都不会保存，但binlog中会有操作记录。搞不懂有啥用！
+ Federated：用来访问远端MySQL数据库中的表。本地表不保存数据，访问远程表内容。
+ MRG_MyISAM：一组MyISAM表的组合，这些MyISAM表必须结构相同，MRG表本身没有数据，但对MRG表的操作就可以对一组MyISAM表进行操作。

#### InnoDB和MyISAM对比

InnoDB和MyISAM是MySQL中最常用的两种存储引擎，两者的区别如下：

+ 事务和外键

  + InnoDB支持事务和外键，通过事务保证了数据的安全性和完整性，适合大量insert或update操作；
  + MyISAM不支持事务和外键，提供高速存储和检索，适合大量的select操作。

+ 锁机制

  + InnoDB支持行级锁，锁定指定记录。基于索引来加锁实现（不是太理解！）；
  + MyISAM支持表级锁，锁定整张表。

+ 索引结构

  + InnoDB使用聚簇索引，索引和记录在一起存储，既缓存索引值，也缓存记录；
  + MyISAM使用非聚簇索引，索引和记录分开。

+ 并发处理能力

  + MyISAM使用表锁，会导致写操作并发率低，读之间并不阻塞，读写阻塞；

  + InnoDB读写阻塞范围与隔离级别有关，可以采用多版本并发控制（MVCC）来支持高并发

+ 存储文件

  + InnoDB表对应两个文件：一个.frm表结构文件，一个.ibd数据文件。InnoDB表最大支持64TB；
  + MyISAM表对应三个文件：一个.frm表结构文件，一个.MYD表数据文件，一个.MYI索引文件。MySQL5..0开始默认限制256TB。



两种存储引擎的适用场景：

+ MyISAM
  + 不需要事务支持
  + 并发相对较低（表锁）
  + 数据修改相对较少，以读为主
  + 数据一致性要求不高
+ InnoDB
  + 需要事务支持
  + 行级锁对高并发有很好的适应能力
  + 数据更新较为频繁的场景
  + 数据一致性要求较高
  + 硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存利用率，减少磁盘IO。



两种引擎该如何选择？

+ 是否需要事务？有，InnoDB
+ 是否存在并发修改？有，InnoDB
+ 是否追求快速查询，且数据修改少？是，MyISAM，当然也可以选择InnoDB
+ 在绝大多数情况下，推荐使用InnoDB。



各个存储引擎特性对比如下图：

![image-20220107165735605](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220107165735605.png)

#### InnoDB存储结构

从MySQL5.5开始默认使用InnoDB作为存储引擎，它擅长事务处理，具有自动崩溃恢复的特性。下面是官网提供的InnoDB引擎架构图，主要分为内存结构和磁盘结构两大部分。

![image-20220107184350645](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220107184350645.png)

##### InnoDB内存结构

如上图所示，InnoDB的内存结构主要包括Buffer Pool、Change Buffer、Adaptive Hash Index和Log Buffer四大组件。

**Buffer Pool**

**Change Buffer**

**Adaptive Hash Index**

**Log Buffer**



##### InnoDB磁盘结构



##### 新版本结构演变

![image-20220107185732954](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220107185732954.png)

#### InnoDB线程模型

#### InnoDB数据文件

#### Undo Log

#### Redo Log和Binlog

## MySQL索引原理

### 索引类型

### 索引原理

### 索引分析与优化

### 查询优化

## MySQL事务和锁

### ACID特性

### 事务控制的演进

#### 并发事务

#### 排队

#### 排他锁

#### 读写锁

#### MVCC

### 事务隔离级别

### 锁机制和实战

## MySQL集群架构



