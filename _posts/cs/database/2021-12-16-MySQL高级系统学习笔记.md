---
layout: post 
author: oshacker
title: MySQL高级系统学习笔记
category: database
tags: [cs,datebase]
excerpt: 流水账，不喜勿喷😄

---

## 前言

### 必备基础知识

MySQL软件下载和安装（我使用5.7.30）

熟悉MySQL工具和基本SQL操作

+ windows：MySQL WorkBench、Navicat、SQLyog
+ Linux：MySQL WorkBench、Navicat
+ Mac：Navicat、Sequel Pro

熟悉主键、外键、非空、唯一等约束

熟悉索引、事务概念和基本使用

### 主要学习内容

MySQL架构原理和存储机制

+ MySQL体系结构（内存结构、磁盘结构）、SQL运行机制、存储引擎、Undo/Redo Log等

MySQL索引存储机制和工作原理

+ 索引存储结构、索引查询原理、索引分析和优化、查询优化等

MySQL事务和锁工作原理

+ 事务隔离级别、事务并发处理、锁机制和实战等

MySQL集群架构及相关原理

+ 集群架构设计理念、主动架构、双主架构、分库分表等

互联网海量数据处理实战

+ ShardingSphere、MyCat中间件实战操作、分库分表实战

MySQL第三方工具实战

+ 同步工具、运维工具、监控工具等

### MySQL起源和分支

MySQL 是最流行的关系型数据库软件之一，由于其体积小、速度快、开源免费、简单易用、维护成本低等，在集群架构中易于扩展、高可用，因此深受开发者和企业的欢迎。

Oracle和MySQL是世界市场占比最高的两种数据库。 

+ Oracle:垄断，有钱的大企业采用，互联网企业之外使用第一。
+  MySQL:互联网高速发展，互联网企业使用第一。

> IOE: IBM的服务器，Oracle数据库，EMC存储设备。都是有钱的公司产品采购，例如银行、电信、石油、证券等大企业。

MySQL发展历程如下：

![image-20220104101544950](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104101544950.png)

MySQL主流分支如下图：

![image-20220104102214521](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104102214521.png)

MySQL从最初的1.0、3.1到后来的8.0，发生了各种各样的变化。被Oracle收购后，MySQL的版本演化出了多个分支，除了需要付费的MySQL企业版本，还有很多MySQL社区版本。

+ 其中一条非常流行的开源分支版本叫Percona Server，它是MySQL的技术支持公司Percona推出的，也是在实际工作中经常碰到的。Percona Server在MySQL官方版本的基础上做了一些补丁和优化，同时推出了一些工具。
+ 另外一个非常不错的版本叫MariaDB，它是MySQL的公司被Oracle收购后，MySQL的创始人Monty先生按原来的思路重新写的一套新数据库，同时也把 InnoDB 引擎作为主要存储引擎，也算 MySQL 的 分支。

### MySQL应用架构演变

业务系统架构的演变过程：随着用户增多，网站的访问量不断增长，整个系统的架构也会从最初的单体架构演变为垂直架构，再到后来的分布式SOA架构和分布式微服务架构，且在这些架构中可以使用集群来提升系统对请求处理的的高并发和高可用，比如应用服务器集群、微服务集群等。

为了提升系统对高并发请求的处理能力，除了前面提到的集群外，数据库的存储和访问也是性能优化非常关键的环节，因为用户的请求发送过来后，需要应用服务器、业务服务器和存储服务器共同配合来完成请求的响应。因此，这里介绍网站在不同的并发访问量级和数据量级下，MySQL应用架构的演变过程。

**架构v1.0-单机单库**

一台服务器安装一个MySQL instance（忽略掉了数据备份的实例），在这个MySQL中存储了系统的所有数据，系统通过数据访问层完成对这台服务器中的数据库的读写操作。适用于简单的小型网站或应用。

![image-20220104184938633](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104184938633.png)

架构v1.0存在的问题：

+ 数据库存储了所有的数据，数据量太大，超出一台服务器的承受能力
+ 读写操作量太大（用户访问量很大），超出一台服务器承受能力
+ 一台服务器挂了，应用也会挂掉（可用性差）

**架构v2.0-主从架构**

3台机器各安装一个MySQL instance，一个主库2个从库，通过主从结构（双主结构也属于特殊的主从）解决了架构v1.0下的高可用和读扩展问题。

+ 主库宕机时，可以把从库会切换成主库来保证高可用；

+ 通过给Instance挂载从库（可以更多）解决读取的压力，主库抗写压力，从库分担读压力，即读写分离。对于写少读多的应用，v2.0主从架构完全能够胜任。

![image-20220104185241609](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104185241609.png)

架构v2.0存在的问题：

+ 数据量太大（虽然采用了主从结构，但是每个数据库存储的仍然是完整数据），超出一台服务器的承受能力
+ 写操作量太大，超出一台M服务器的承受能力

**架构v3.0-分库分表**

架构v1.0和v2.0遇到写入瓶颈和存储瓶颈时，可以通过水平拆分来解决。如下图所示，将UserInfo拆分为3个Sharding，每个Sharding持有总量的1/3数据，3个Sharding数据的总和等于一份完整数据。

> 水平拆分和垂直拆分的区别：垂直拆分后，每一个实例都拥有全部数据；水平拆分后，任何实例都只有全量数据的1/n。

![image-20220104185315742](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104185315742.png)

这种架构的复杂性比较高，需要考虑以下问题：

+ 数据如何路由，即一个请求应该分发给哪个服务器上的数据库；
+ 一个表的数据如何拆分，一般可以采用范围拆分，list拆分，hash拆分等；
+ 如何保持数据的一致性

**架构v4.0-云数据库**

云数据库（云计算）是公司节约成本的一个突破口，对于数据存储的MySQL来说，如何让其成为一个Sass（Software as a service）是关键点。MySQL作为一个Sass服务，服务提供商负责解决可配置性、可扩展性、多用户存储结构设计等疑难问题。

![image-20220104185442848](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104185442848.png)

## MySQL0架构原理

### MySQL体系结构

![image-20220104223151509](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104223151509.png)

MySQL Server自顶向下大致可以分为四层：

+ 网络连接层

  + 客户端连接器（Client Connectors）：提供与MySQL服务器建立连接的支持。目前，支持几乎所有主流的服务端编程语言，比如Java、C、Python等，它们通过各自API与MySQL服务器建立连接。

+ 服务层：MySQL Server的核心，主要包含以下六部分。

  + 连接池（Connection Pool）：负责存储和管理客户端与数据库的连接，一个线程负责管理一个连接（这里还提到了线程池，后续再深入）。

  + 系统管理和控制工具（Management Services & Utilities)：比如备份恢复、安全管理、集群管理等

  + SQL接口（SQL Interface）：用于接受客户端发送的各种SQL命令，并且返回用户查询的结果。比如DML、DDL、存储过程、视图、触发器等。

  + 解析器（Parser）：负责将请求的SQL生成一个“解析树”，然后根据一些MySQL规则进一步检查解析树是否合法（词法分析、语法分析）。

  + 查询优化器（Optimizer）：当解析树通过解析器语法检查后，将交给优化器将其转化成执行计划，然后与存储引擎交互。

    > 类似于寻找最优路径，那么究竟是如何优化？
    >
    > 对于select uid,name from user where gender=1;，它会按照选取->投影->联接的策略进行优化。
    >
    > + 先根据where语句进行选取，而不是查询出所有数据再过滤；
    > + 根据uid和name进行属性投影，而不是取出所有字段；
    > + 将两个查询条件联接起来最终生成查询结果。

  + 缓存（Cache&Buffer）：缓存机制是由一系列小缓存组成的。比如表缓存、记录缓存、权限缓存、引擎缓存等。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。

+ 存储引擎层

  + 存储引擎负责MySQL中数据的存储与提取，与底层系统文件进行交互。
  + MySQL的存储引擎是插件式的，服务器中的【查询执行引擎】通过接口与【存储引擎】进行通信，接口屏蔽了不同引擎之间的差异。常见的存储引擎有InnoDB和MyISAM。
  + 存储引擎是针对表的，而不是针对库的，即一个库中的两个表可以使用不同的存储引擎。

+ 系统文件层：负责将数据库的数据和日志存储在文件系统上，并完成与存储引擎的交互，是文件的物理存储层，主要包含以下几部分。

  + 日志文件

    + 错误日志（Error log）： 默认开启，show variables like '%log_err%';
    + 通用查询日志（General query log）：记录一般查询语句，show variables like '%general%';
    + 二进制日志（binary log）：记录了对MySQL数据库执行的更改操作，并且记录了语句的发生时间、执行时长，但它不记录select、show等不修改数据库的SQL。主要用于数据库恢复和主从复制。
      + Show variables like '%log_bin%'; //是否开启
      + Show variables like '%binlog%'; //参数查看
      + Show binary logs; //查看日志文件
    + 慢查询日志（Slow query log）：记录所有执行时间超时的查询SQL，默认为10s。
      + Show variables like '%slow_query%'; //是否开启
      + Show variables like '%long_query_time%'; //时长
      + set long_query_time = 5; //修改时长，其他类似

  + 配置文件

    + 用于存放MySQL所有的配置信息，比如my.cnf、my.ini等。

  + 数据文件：

    + show variables like '%datadir%';  //查看数据文件路径

    + db.opt文件：记录这个库默认使用的字符集和校验规则；

    + frm文件：存储和表相关的元数据（meta）信息，包括表结构的定义信息等，每张表都会有一个.frm文件。

    + MYD文件、MYI文件：MyISAM存储引擎专用，前者用于存放MyISAM表的数据，每张表都会有一个.MYD文件；后者存放MyISAM表的索引相关信息，每一张MyISAM表对应一个.MYI文件。

    + idb文件和IBDATA文件：存放InnoDB的数据文件（包括索引）。

      > InnoDB存储引擎有两种表空间方式：独享表空间和共享表空间（系统表空间）。
      >
      > 独享表空间使用.ibd文件来存放数据，且每一张InnoDB表对应一个.ibd文件；共享表空间使用.ibdata文件，所有表共同使用一个/多个（自行配置）.ibdata文件。

    + ibdata1文件：系统表空间数据文件，用于存储表元数据、Undo日志等；

    + ib_logfile0、ib_logfile1文件：Redo log日志文件。

  + pid文件

    + pid文件是mysqld应用程序在Unix/Linux环境下的一个进程文件，和其他Unix/Linux服务端程序一样，它存放着自己的进程id。

  + socket文件

    + socket文件也是在Unix/Linux环境下才有的，用户在Unix/Linux环境下客户端可以不通过TCP/IP而直接使用Unix Socket来连接MySQL。

### MySQL运行机制

![image-20220105171113016](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220105171113016.png)

建立连接（Connectors & Connection Pool）

+ 客户端通过C/S通信协议与MySQL建立连接，MySQL客户端与服务器的通信方式是“半双工”。对于每一个MySQL连接，时刻都有一个线程状态来标识这个连接正在做什么。

  > 通信机制：
  >
  > + 全双工：客户端（或服务器）能同时发送和接收数据，例如平时打电话；
  > + 半双工：某一时刻，要么发送数据，要么接受数据，不能同时，比例早期的对讲机。
  > + 单工：只能发送数据或只能接收数据，比如单行道。
  >
  > 线程状态：
  >
  > + Show processlist; //查看正在运行的线程信息（查看谁连接了MySQL服务端，连接状态什么样），其中root用户可以查看所有线程，其他用户只能查看自己的
  > + 各个参数具体介绍：
  >   + id：线程ID，可以使用kill xx将其杀掉
  >   + user：启动这个线程的用户
  >   + Host：发送请求的客户端IP和端口
  >   + db：当前命令在哪个库执行
  >   + Command：该线程正在执行的操作命令
  >     + Create DB：正在创建库
  >     + Drop DB：正在删除库
  >     + Execute：正在执行一个PreparedStatement
  >     + Close Stmt：正在关闭一个PreparedStatement
  >     + Query：正在执行一个语句
  >     + Sleep：正在等待客户端发送语句
  >     + quit：该线程正在退出
  >     + Shutdown：正在关闭服务器
  >   + Time：该线程处于当前状态的时间，单位是秒
  >   + State：线程状态
  >     + Updating：正在搜索匹配记录，进行修改
  >     + Sleeping：正在等待客户端发送新请求
  >     + Starting：正在进行请求处理
  >     + Checking table：正在检查数据表
  >     + Closing table：正在将表中数据刷到磁盘中
  >     + Locked：被其他查询锁住了记录
  >     + Sending Data：正在处理select查询，同时将结果发送给客户端
  >   + Info：一般记录线程执行的语句，默认显示前100个字符，想查看完整的使用show full processlist。

+ 查询缓存（Cache&Buffer）：MySQL对查询的优化，如果开启了查询缓存且查询到完全相同的SQL，则将查询结果直接返回给客户端；如果没有开启查询缓存或没有查询到完全相同的SQL，就会由解析器进行语法语义分析，并生成“解析树”。

  + 缓存select查询的结果和SQL语句

  + 执行select查询时，先查询缓存，要求完全相同（包括参数），这样才会命中缓存数据。

  + 即使开启查询缓存，以下SQL也不能缓存

    1. 查询语句使用SQL_NO_CACHE

    2. 查询的结果大于query_cache_limit设置
    3. 查询中有一些不确定的参数，比如now()。

  + Show variables like '%query_cache%'; //查看缓存是否开启，空间大小等

  + Show status like 'Qcache%'; //查看更详细的缓存参数，可用缓存空间，缓存块等

+ 解析器（Parser)

### MySQL存储引擎

