---
layout: post 
author: oshacker
title: MySQL高级系统学习笔记
category: database
tags: [cs,datebase]
excerpt: 流水账，不喜勿喷😄

---

## 前言

### 必备基础知识

MySQL软件下载和安装（我使用5.7.30）

熟悉MySQL工具和基本SQL操作

+ windows：MySQL WorkBench、Navicat、SQLyog
+ Linux：MySQL WorkBench、Navicat
+ Mac：Navicat、Sequel Pro

熟悉主键、外键、非空、唯一等约束

熟悉索引、事务概念和基本使用

### 主要学习内容

MySQL架构原理和存储机制

+ MySQL体系结构（内存结构、磁盘结构）、SQL运行机制、存储引擎、Undo/Redo Log等

MySQL索引存储机制和工作原理

+ 索引存储结构、索引查询原理、索引分析和优化、查询优化等

MySQL事务和锁工作原理

+ 事务隔离级别、事务并发处理、锁机制和实战等

MySQL集群架构及相关原理

+ 集群架构设计理念、主动架构、双主架构、分库分表等

互联网海量数据处理实战

+ ShardingSphere、MyCat中间件实战操作、分库分表实战

MySQL第三方工具实战

+ 同步工具、运维工具、监控工具等

### MySQL起源和分支

MySQL 是最流行的关系型数据库软件之一，由于其体积小、速度快、开源免费、简单易用、维护成本低等，在集群架构中易于扩展、高可用，因此深受开发者和企业的欢迎。

Oracle和MySQL是世界市场占比最高的两种数据库。 

+ Oracle:垄断，有钱的大企业采用，互联网企业之外使用第一。
+  MySQL:互联网高速发展，互联网企业使用第一。

> IOE: IBM的服务器，Oracle数据库，EMC存储设备。都是有钱的公司产品采购，例如银行、电信、石油、证券等大企业。

MySQL发展历程如下：

![image-20220104101544950](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104101544950.png)

MySQL主流分支如下图：

![image-20220104102214521](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104102214521.png)

MySQL从最初的1.0、3.1到后来的8.0，发生了各种各样的变化。被Oracle收购后，MySQL的版本演化出了多个分支，除了需要付费的MySQL企业版本，还有很多MySQL社区版本。

+ 其中一条非常流行的开源分支版本叫Percona Server，它是MySQL的技术支持公司Percona推出的，也是在实际工作中经常碰到的。Percona Server在MySQL官方版本的基础上做了一些补丁和优化，同时推出了一些工具。
+ 另外一个非常不错的版本叫MariaDB，它是MySQL的公司被Oracle收购后，MySQL的创始人Monty先生按原来的思路重新写的一套新数据库，同时也把 InnoDB 引擎作为主要存储引擎，也算 MySQL 的 分支。

### MySQL应用架构演变

业务系统架构的演变过程：随着用户增多，网站的访问量不断增长，整个系统的架构也会从最初的单体架构演变为垂直架构，再到后来的分布式SOA架构和分布式微服务架构，且在这些架构中可以使用集群来提升系统对请求处理的的高并发和高可用，比如应用服务器集群、微服务集群等。

为了提升系统对高并发请求的处理能力，除了前面提到的集群外，数据库的存储和访问也是性能优化非常关键的环节，因为用户的请求发送过来后，需要应用服务器、业务服务器和存储服务器共同配合来完成请求的响应。因此，这里介绍网站在不同的并发访问量级和数据量级下，MySQL应用架构的演变过程。

**架构v1.0-单机单库**

一台服务器安装一个MySQL instance（忽略掉了数据备份的实例），在这个MySQL中存储了系统的所有数据，系统通过数据访问层完成对这台服务器中的数据库的读写操作。适用于简单的小型网站或应用。

![image-20220104184938633](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104184938633.png)

架构v1.0存在的问题：

+ 数据库存储了所有的数据，数据量太大，超出一台服务器的承受能力
+ 读写操作量太大（用户访问量很大），超出一台服务器承受能力
+ 一台服务器挂了，应用也会挂掉（可用性差）

**架构v2.0-主从架构**

3台机器各安装一个MySQL instance，一个主库2个从库，通过主从结构（双主结构也属于特殊的主从）解决了架构v1.0下的高可用和读扩展问题。

+ 主库宕机时，可以把从库会切换成主库来保证高可用；

+ 通过给Instance挂载从库（可以更多）解决读取的压力，主库抗写压力，从库分担读压力，即读写分离。对于写少读多的应用，v2.0主从架构完全能够胜任。

![image-20220104185241609](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104185241609.png)

架构v2.0存在的问题：

+ 数据量太大（虽然采用了主从结构，但是每个数据库存储的仍然是完整数据），超出一台服务器的承受能力
+ 写操作量太大，超出一台M服务器的承受能力

**架构v3.0-分库分表**

架构v1.0和v2.0遇到写入瓶颈和存储瓶颈时，可以通过水平拆分来解决。如下图所示，将UserInfo拆分为3个Sharding，每个Sharding持有总量的1/3数据，3个Sharding数据的总和等于一份完整数据。

> 水平拆分和垂直拆分的区别：垂直拆分后，每一个实例都拥有全部数据；水平拆分后，任何实例都只有全量数据的1/n。

![image-20220104185315742](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104185315742.png)

这种架构的复杂性比较高，需要考虑以下问题：

+ 数据如何路由，即一个请求应该分发给哪个服务器上的数据库；
+ 一个表的数据如何拆分，一般可以采用范围拆分，list拆分，hash拆分等；
+ 如何保持数据的一致性

**架构v4.0-云数据库**

云数据库（云计算）是公司节约成本的一个突破口，对于数据存储的MySQL来说，如何让其成为一个Sass（Software as a service）是关键点。MySQL作为一个Sass服务，服务提供商负责解决可配置性、可扩展性、多用户存储结构设计等疑难问题。

![image-20220104185442848](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104185442848.png)

## MySQL0架构原理

### MySQL体系结构

![image-20220104223151509](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220104223151509.png)

MySQL Server自顶向下大致可以分为四层：

+ 网络连接层

  + 客户端连接器（Client Connectors）：提供与MySQL服务器建立连接的支持。目前，支持几乎所有主流的服务端编程语言，比如Java、C、Python等，它们通过各自API与MySQL服务器建立连接。

+ 服务层：MySQL Server的核心，主要包含以下六部分。

  + 连接池（Connection Pool）：负责存储和管理客户端与数据库的连接，一个线程负责管理一个连接（这里还提到了线程池，后续再深入）。

  + 系统管理和控制工具（Management Services & Utilities)：比如备份恢复、安全管理、集群管理等

  + SQL接口（SQL Interface）：用于接受客户端发送的各种SQL命令，并且返回用户查询的结果。比如DML、DDL、存储过程、视图、触发器等。

  + 解析器（Parser）：负责将请求的SQL生成一个“解析树”（词法分析、语法分析），然后根据一些MySQL规则进一步检查解析树是否合法。

  + 查询优化器（Optimizer）：当解析树通过解析器语法检查后，将交给优化器将其转化成执行计划，然后与存储引擎交互。

    > 类似于寻找最优路径，那么究竟是如何优化？
    >
    > 对于select uid,name from user where gender=1;，它会按照选取->投影->联接的策略进行优化。
    >
    > + 先根据where语句进行选取，而不是查询出所有数据再过滤；
    > + 根据uid和name进行属性投影，而不是取出所有字段；
    > + 将两个查询条件联接起来最终生成查询结果。

  + 缓存（Cache&Buffer）：缓存机制是由一系列小缓存组成的。比如表缓存、记录缓存、权限缓存、引擎缓存等。如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。

+ 存储引擎层

  + 存储引擎负责MySQL中数据的存储与提取，与底层系统文件进行交互。
  + MySQL的存储引擎是插件式的，服务器中的【查询执行引擎】通过接口与【存储引擎】进行通信，接口屏蔽了不同引擎之间的差异。常见的存储引擎有InnoDB和MyISAM。
  + 存储引擎是针对表的，而不是针对库的，即一个库中的两个表可以使用不同的存储引擎。

+ 系统文件层：负责将数据库的数据和日志存储在文件系统上，并完成与存储引擎的交互，是文件的物理存储层，主要包含以下几部分。

  + 日志文件

    + 错误日志（Error log）： 默认开启，show variables like '%log_err%';
    + 通用查询日志（General query log）：记录一般查询语句，show variables like '%general%';
    + 二进制日志（binary log）：记录了对MySQL数据库执行的更改操作，并且记录了语句的发生时间、执行时长，但它不记录select、show等不修改数据库的SQL。主要用于数据库恢复和主从复制。
      + Show variables like '%log_bin%'; //是否开启
      + Show variables like '%binlog%'; //参数查看
      + Show binary logs; //查看日志文件
    + 慢查询日志（Slow query log）：记录所有执行时间超时的查询SQL，默认为10s。
      + Show variables like '%slow_query%'; //是否开启
      + Show variables like '%long_query_time%'; //时长
      + set long_query_time = 5; //修改时长，其他类似

  + 配置文件

    + 用于存放MySQL所有的配置信息，比如my.cnf、my.ini等。

  + 数据文件：

    + show variables like '%datadir%';  //查看数据文件路径

    + db.opt文件：记录这个库默认使用的字符集和校验规则；

    + frm文件：存储和表相关的元数据（meta）信息，包括表结构的定义信息等，每张表都会有一个.frm文件。

    + MYD文件、MYI文件：MyISAM存储引擎专用，前者用于存放MyISAM表的数据，每张表都会有一个.MYD文件；后者存放MyISAM表的索引相关信息，每一张MyISAM表对应一个.MYI文件。

    + idb文件和IBDATA文件：存放InnoDB的数据文件（包括索引）。

      > InnoDB存储引擎有两种表空间方式：独享表空间和共享表空间（系统表空间）。
      >
      > 独享表空间使用.ibd文件来存放数据，且每一张InnoDB表对应一个.ibd文件；共享表空间使用.ibdata文件，所有表共同使用一个/多个（自行配置）.ibdata文件。

    + ibdata1文件：系统表空间数据文件，用于存储表元数据、Undo日志等；

    + ib_logfile0、ib_logfile1文件：Redo log日志文件。

  + pid文件

    + pid文件是mysqld应用程序在Unix/Linux环境下的一个进程文件，和其他Unix/Linux服务端程序一样，它存放着自己的进程id。

  + socket文件

    + socket文件也是在Unix/Linux环境下才有的，用户在Unix/Linux环境下客户端可以不通过TCP/IP而直接使用Unix Socket来连接MySQL。
    + mysql的服务端和客户端在同一host（物理服务器）上的时候，使用unix socket做为通讯协议的载体，它比tcp快。

### MySQL运行机制

![image-20220105171113016](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220105171113016.png)

建立连接（Connectors & Connection Pool）

+ 客户端通过C/S通信协议与MySQL建立连接，MySQL客户端与服务器的通信方式是“半双工”。对于每一个MySQL连接，时刻都有一个线程状态来标识这个连接正在做什么。

  > 通信机制：
  >
  > + 全双工：客户端（或服务器）能同时发送和接收数据，例如平时打电话；
  > + 半双工：某一时刻，要么发送数据，要么接受数据，不能同时，比例早期的对讲机。
  > + 单工：只能发送数据或只能接收数据，比如单行道。
  >
  > 线程状态：
  >
  > + Show processlist; //查看正在运行的线程信息（查看谁连接了MySQL服务端，连接状态什么样），其中root用户可以查看所有线程，其他用户只能查看自己的
  > + 各个参数具体介绍：
  >   + id：线程ID，可以使用kill xx将其杀掉
  >   + user：启动这个线程的用户
  >   + Host：发送请求的客户端IP和端口
  >   + db：当前命令在哪个库执行
  >   + Command：该线程正在执行的操作命令
  >     + Create DB：正在创建库
  >     + Drop DB：正在删除库
  >     + Execute：正在执行一个PreparedStatement
  >     + Close Stmt：正在关闭一个PreparedStatement
  >     + Query：正在执行一个语句
  >     + Sleep：正在等待客户端发送语句
  >     + quit：该线程正在退出
  >     + Shutdown：正在关闭服务器
  >   + Time：该线程处于当前状态的时间，单位是秒
  >   + State：线程状态
  >     + Updating：正在搜索匹配记录，进行修改
  >     + Sleeping：正在等待客户端发送新请求
  >     + Starting：正在进行请求处理
  >     + Checking table：正在检查数据表
  >     + Closing table：正在将表中数据刷到磁盘中
  >     + Locked：被其他查询锁住了记录
  >     + Sending Data：正在处理select查询，同时将结果发送给客户端
  >   + Info：一般记录线程执行的语句，默认显示前100个字符，想查看完整的使用show full processlist。
  > + show status like '%Threads%'; 查询连接当前MySQL服务器的客户端数量

+ 查询缓存（Cache&Buffer）：MySQL对查询的优化，如果开启了查询缓存且查询到完全相同的SQL，则将查询结果直接返回给客户端；如果没有开启查询缓存或没有查询到完全相同的SQL，就会由解析器进行语法语义分析，并生成“解析树”。

  + 缓存select查询的结果和SQL语句

  + 执行select查询时，先查询缓存，要求完全相同（包括参数），这样才会命中缓存数据。

  + 即使开启查询缓存，以下SQL也不能缓存

    1. 查询语句使用SQL_NO_CACHE

    2. 查询的结果大于query_cache_limit设置
    3. 查询中有一些不确定的参数，比如now()。

  + Show variables like '%query_cache%'; //查看缓存是否开启，空间大小等

  + Show status like 'Qcache%'; //查看更详细的缓存参数，可用缓存空间，缓存块等

+ 解析器（Parser)：将客户端发送的SQL进行词法、语法分析，生成“解析树”。预处理器根据一些MySQL规则进一步检查“解析树”是否合法，比如检查数据表和数据列是否存在，还会解析名字和别名，看看它们是否有歧义，最后生成新的“解析树”。

+ 查询优化器（Optimizer）：根据“解析树”生成最优的执行计划，使用的优化策略可以分为两类：静态优化（编译时优化）、动态优化（运行时优化）。

  + 等价变换策略
    + 5=5 and a > 5 改成 a > 5；
    + a < b and a = 5 改成 b > 5 and a = 5；
    + 基于联合索引，调整条件顺序等。
  + 优化count、min、max等函数
    + InnoDB引擎min函数只需要找索引最左边，max函数只需要找索引最右边；
    + MyISAM引擎count(*)不需要计算，直接返回。
  + 提前终止查询：使用了limit查询，获取到limit所需的数据后，就不再继续遍历后面的数据。
  + in的优化：先进行排序，再采用二分法查找数据。比如where id in (2,1,3) 改成 where id in (1,2,3)。

+ 查询执行引擎：负责执行SQL语句，查询执行引擎会根据SQL中表的存储引擎类型，通过对应的API接口与底层存储引擎或物理文件进行交互，得到查询结果并返回给客户端。如果返回结果过多，采用增量模式返回（有点分页的味道）。

  > 如果开启查询缓存，会将SQL和结果完整地保存到查询缓存（Cache & Buffer）中，再将查询结果返回给客户端。这样如果以后有相同的SQL语句执行，则直接返回结果。

### MySQL存储引擎

存储引擎在MySQL的体系架构中位于第三层，负责MySQL中数据的存储和提起，是与文件打交道的子系统，它是根据MySQL提供的【文件访问层抽象接口】定制的一种文件访问机制，这种机制就叫存储引擎。

使用show engines命令可以查看当前数据库支持的引擎信息。

![image-20220107164506010](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220107164506010.png)

> MySQL5.5之前默认采用MyISAM存储引擎，从MySQL5.5开始采用InnoDB存储引擎。

各存储引擎特点：

+ InnoDB：支持事务，具有提交、回滚和崩溃恢复能力，即事务安全
+ MyISAM：不支持事务和外键，访问速度快，适合查询多的场景
+ Memory：利用内存创建表，因为数据在内存，默认使用Hash索引，所以访问速度非常快。但一旦关闭，数据就会丢失。
+ Archive：归档类型引擎，仅能支持insert和select语句。
+ Csv：以CSV文件进行数据存储，由于文件限制，所有列必须强制指定not null，另外CSV引擎也不支持索引和分区，适合做数据交换的中间表。
+ BlackHole：黑洞，只进不出，进来消失，所有插入的数据都不会保存，但binlog中会有操作记录。搞不懂有啥用！
+ Federated：用来访问远端MySQL数据库中的表。本地表不保存数据，访问远程表内容。
+ MRG_MyISAM：一组MyISAM表的组合，这些MyISAM表必须结构相同，MRG表本身没有数据，但对MRG表的操作就可以对一组MyISAM表进行操作。

#### InnoDB和MyISAM对比

InnoDB和MyISAM是MySQL中最常用的两种存储引擎，两者的区别如下：

+ 事务和外键

  + InnoDB支持事务和外键，通过事务保证了数据的安全性和完整性，适合大量insert或update操作；
  + MyISAM不支持事务和外键，提供高速存储和检索，适合大量的select操作。

+ 锁机制

  + InnoDB支持行级锁，锁定指定记录。基于索引来加锁实现（不是太理解！）；
  + MyISAM支持表级锁，锁定整张表。

+ 索引结构

  + InnoDB使用聚簇索引，索引和记录在一起存储，既缓存索引值，也缓存记录；
  + MyISAM使用非聚簇索引，索引和记录分开。

+ 并发处理能力

  + MyISAM使用表锁，会导致写操作并发率低，读之间并不阻塞，读写阻塞；

  + InnoDB读写阻塞范围与隔离级别有关，可以采用多版本并发控制（MVCC）来支持高并发

+ 存储文件

  + InnoDB表对应两个文件：一个.frm表结构文件，一个.ibd数据文件。InnoDB表最大支持64TB；
  + MyISAM表对应三个文件：一个.frm表结构文件，一个.MYD表数据文件，一个.MYI索引文件。MySQL5..0开始默认限制256TB。



两种存储引擎的适用场景：

+ MyISAM
  + 不需要事务支持
  + 并发相对较低（表锁）
  + 数据修改相对较少，以读为主
  + 数据一致性要求不高
+ InnoDB
  + 需要事务支持
  + 行级锁对高并发有很好的适应能力
  + 数据更新较为频繁的场景
  + 数据一致性要求较高
  + 硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存利用率，减少磁盘IO。



两种引擎该如何选择？

+ 是否需要事务？有，InnoDB
+ 是否存在并发修改？有，InnoDB
+ 是否追求快速查询，且数据修改少？是，MyISAM，当然也可以选择InnoDB
+ 在绝大多数情况下，推荐使用InnoDB。



各个存储引擎特性对比如下图：

![image-20220107165735605](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220107165735605.png)

#### InnoDB存储结构

从MySQL5.5开始默认使用InnoDB作为存储引擎，它擅长事务处理，具有自动崩溃恢复的特性。下面是官网提供的InnoDB引擎架构图，主要分为内存结构和磁盘结构两大部分。

![image-20220107184350645](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220107184350645.png)

##### InnoDB内存结构

如上图所示，InnoDB的内存结构主要包括Buffer Pool、Change Buffer、Adaptive Hash Index和Log Buffer四大组件。

**Buffer Pool**

缓存池，简称BP，BP以page（页，默认大小为16K）为单位，底层采用链表管理Page。在InnoDB访问表记录和索引时会在page页中缓存（优化读操作），以后使用可以减少IO操作，提升效率。

1. page管理机制

   + Page根据状态可以分为三种类型：

     + free page：空闲page，未被使用；
     + clean page：被使用page，数据没被修改过；
     + dirty page：脏页，被使用的page，数据被修改过，页中数据和磁盘中的数据不一致

   + 针对上述三种page类型，InnoDB通过三种链表结构来维护和管理：

     + free list：表示空闲缓冲区，管理free page；
     + flush list：表示需要刷新到磁盘的缓冲区，管理dirty page，内部page按修改时间排序(最新修改的page在flush list的头部，最早修改的page在flush list的尾部，刷盘时从尾部开始)。
     + lru list：表示正在使用的缓冲区，管理clean page和dirty page。该缓冲区以midpoint为基点，前面链表称为new列表区，存放经常访问的数据，占63%；后面的链表称为old列表区，存放使用较少的数据，占37%。

     > 注意：
     >
     > + 脏页（dirty page）既存在于flush链表，也在lru链表中，但是两种互不影响，lru链表负责管理page的可用性和释放，而flush链表负责管理脏页的刷盘操作。
     > + 两者也是有联系的：当触发刷盘操作时，会把对应page从lru list移除；当某些page淘汰时，也会触发对应page的刷盘操作。

   + 通过show engine innodb status \G;可以查看innnodb引擎的状态，如下：

     ```mysql
     ----------------------
     BUFFER POOL AND MEMORY
     ----------------------
     Total large memory allocated 140836864
     Dictionary memory allocated 131981
     Buffer pool size   8191 // Buffer Pool共有8191个page 
     Free buffers       7907 // free page的数量
     Database pages     284 // clean page + dirty page的数量，即lru list管理的page
     Old database pages 0 // lru list中old区的page数量
     Modified db pages  0 // dirty page的数量
     Pending reads      0
     Pending writes: LRU 0, flush list 0, single page 0
     Pages made young 0, not young 0
     0.00 youngs/s, 0.00 non-youngs/s
     Pages read 215, created 69, written 187
     0.00 reads/s, 0.00 creates/s, 0.00 writes/s
     No buffer pool page gets since the last printout
     Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s
     LRU len: 284, unzip_LRU len: 0
     I/O sum[0]:cur[0], unzip sum[0]:cur[0]
     ```

     从上面可知，Buffer pool size.= Free buffers + Database pages，但也可能大于，因为BP中的某些page可能会分配给Adaptive Hash Index和Change Buffer。

2. page空间释放（改进型LRU算法）
   + 普通lru：末尾淘汰法，新数据从链表头部加入，释放空间时从末尾淘汰；
   + 改性lru：链表分为new和old两个部分，加入元素时并不是从链表头部插入，而是从中间midpoint位置插入。如果数据数据很快被访问，那么page就会向new列表头部移动；如果数据没有被访问，page会逐步向old尾部移动，等待淘汰。释放空间时依然从尾部淘汰。
   + 每当有新的page数据读取到buffer pool时，InnoDB引擎会判断空闲页是否足够，如果有，就将free page从free list列表删除，放入到lru链表中；如果没有空闲页，就会根据lru算法淘汰掉lru链表末尾的页，将内存空间释放分配给新的页。

3. Buffer Pool配置参数

   + show variables like '%innodb_page_size%'; //查看page页大小

     > 对于确定的参数，可以使用select @@innodb_page_size/1.24;来查看。

   + show variables like '%innodb_old%'; //查看lru list中old列表所占比例

   + show variables like '%innodb_buffer%'; //查看buffer pool参数

     > 具体关系是innnodb_buffer_pool_size分为几个innnodb_buffer_pool_instances，每个innodb_buffer_pool_instances分为几个innodb_buffer_pool_chunk_size，每个innodb_buffer_pool_chunk_size分为几个innodb_page_size。

   > 建议：将innnodb_buffer_pool_size设置为总内存大小的60%-80%，innodb_buffer_pool_instances可以设置为多个，这样当较多数据加载到内存时，使用多个实例可以降低缓存竞争。

**Change Buffer**

写缓冲区，简称CB。在进行DML操作时，如果BP没有相应的page数据，并不会立刻将磁盘页加载到缓冲池BP，而是在CB记录缓冲变更，等将来数据被读取时，再将数据合并恢复到BP中（优化写操作）。

+ Change buffer占用Buffer Pool空间，默认为25%，最大允许占50%，可以根据读写业务量来进行调整（写多读少时增大该参数），参数为innodb_change_buffer_max_size;

+ 当更新一条记录时，会存在以下两种情况：

  + 如果该记录在Buffer Pool中存在，直接在BP中修改，一次内存操作；
  + 如果该记录在Buffer Pool中不存在（没有命中），会直接在Change Buffer进行一次内存操作，不用再去磁盘查询数据，避免一次磁盘IO。当下次查询记录时，会先进行磁盘读取，然后再从CB中读取信息合并，最终载入Buffer Pool中。
  
  > 【注意】：写缓冲区仅适用于非唯一的普通索引页！
  >
  > 如果给索引设置唯一性，在进行修改时，InnoDB必须要做唯一性校验，因此必须查询磁盘，做一次IO操作。即直接将记录查询到Buffer Pool中，并在缓冲池BP中修改，而不会在写缓冲Change Buffer中操作。

**Adaptive Hash Index**

自适应哈希索引，用于优化对BP数据的查询。InnoDB存储引擎会监控对表上二级索引（索引页）的查找，如果发现某二级索引被频繁访问，建立哈希索引可以带来速度的提升，就会建立哈希索引（key是频繁访问的索引键值，value为该索引键值匹配的完整记录所在的数据页编号和页偏移量），所以称之为自适应，即InnoDB存储引擎会自动根据访问的频率和模式为某些数据页建立哈希索引。

![image-20220110102832502](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220110102832502.png)

**Log Buffer**

日志缓冲区，用来保存要写入到磁盘上的日志文件（Redo Log）的数据，日志缓冲区的内容定期刷新到磁盘上的日志文件中。

+ Log Buffer主要用于记录DML操作时InnoDB引擎产生的Redo日志。

+ Log Buffer空间满了，会自动刷新到磁盘。

+ 当遇到BLOB或多行更新的大事务操作时，通过增加日志缓冲区（innodb_log_buffer_size）可以减少磁盘IO。（ 但不要设置过大，否则一旦mysql服务器宕机，恢复的时间太长，一般设置为16M。）

+ Innodb_flush_log_at_trx_commit参数控制日志刷新行为，默认为1

  + 0：每隔1s写日志文件和刷盘，即最多丢失1s数据；
  + 1：事务提交，立刻写日志文件和刷盘，数据不丢失，但是会频繁IO操作；
  + 2：事务提交，立刻写日志文件，每隔1s进行一次刷盘操作

  > 注意：写日志文件指从Log Buffer到OS cache，刷盘指从OS cache到磁盘文件。（与此不同的是，Buffer Pool中的数据通过O_DIRECT可以直接写入到磁盘，而无需先写入到OS_cache）
  
+ 通过show variables like 'innodb_log%'; 和 show variables like 'innodb_flush_log%';可以看到更多参数。

##### InnoDB磁盘结构

**表空间**（Tablespaces）：用来存储表结构和数据。

+ 系统表空间（System Tablespace）：是下面四部分的存储区域，还包含用户在系统表空间中创建的表和索引数据（如果有）。它是一个被多个表共享的表空间，该空间的数据文件通过参数innodb_data_file_path控制，默认值是ibdata1:12M:autoextend。

  + 数据字典（InnoDB Data Dictionary）

    InnoDB数据字典由内部系统表组成，这些表包含用于查找表、索引和表字段等对象的元数据，这些元数据实际上存放在InnoDB系统表空间中，但由于历史原因，这些元数据在一定程度上与InnoDB表元数据文件(.frm)中存储的信息重叠。

  + 双写缓冲区（Doublewrite Buffer）

    位于系统表空间的一个存储区域。在Buffer Pool的page刷新到磁盘上的真正表文件前，会先将数据存放到Doublewrite缓冲区（这不也是写磁盘吗？怎为什么比写表文件快？）。如果在page写入过程中出现操作系统、存储子系统或mysql进程崩溃，InnoDB可以在崩溃恢复期间从Doublewrite缓冲区找到page的一个备份。在大多数情况下，默认启动双写缓冲区，禁用Doublewrite缓冲区只需将innodb_doublewrite设置为0。

    > 注意：使用Doublewrite缓冲区时建议将innodb_flush_method设置为O_DIRECT。
    >
    > MySQL的innodb_flush_method参数控制着innnodb数据文件及redo log的打开、刷写模式，可能的取值有三个：
    >
    > + fdatasync：默认，先写入操作系统缓存OS_Cache，再调用fsync()函数异步将数据文件与redo log的缓存到磁盘文件。
    > + O_DIRECT：数据文件写入操作会通知操作系统不要缓存数据，也不要预读，直接从Innodb Buffer写到磁盘文件。
    > + O_DSYNC

  + 写缓冲区（Change Buffer）

  + 撤销日志（Undo Logs）

    指事务开始前保存的被修改数据的备份，用于回滚事务。

    撤销日志属于逻辑日志，记录每行记录的改变，存在于系统表空间、临时表空间和撤销表空间。

+ 独立表空间（File-Per-Table Tablespaces）

  当Innodb_file_per_table选项开启时（默认开启），表将被创建于独立表空间中，否则将被创建于系统表空间中。每个表的独立表空间由一个.ibd数据文件代表，该文件默认创建于对应数据库目录中。

  在独立表空间中创建的表使用Barracuda文件格式，这种文件格式支持动态和压缩行格式。（搞不懂，后续研究！）

+ 通用表空间（General Tablespaces）

  指通过create tablespace语法创建的共享表空间，它可以创建于数据目录data之外，可以容纳多张表，且支持所有的行格式。

  注：很少使用，了解即可。

  ```sql
  # 创建通用表空间ts1(ts1.ibd默认会放到data目录，当然可以指定到其他目录)
  create tablespace ts1 add datafile 'ts1.ibd' engine=innodb;
  # 创建表t1并添加到ts1表空间
  create table t1(a int primary key tablespace ts1;
  # 删除表
  drop table t1;
  # 删除表空间
  drop tablespace ts1;
  ```

+ 临时表空间（Temporary Tablespaces）

  临时表空间分为session和global临时表空间两种。session临时表空间存储的是用户创建的临时表和优化程序创建的内部临时表，global临时表空间存储的是用户临时表的回滚段（rollback segments）。mysql服务器正常关闭或异常终止时，临时表空间将被移除，每次启动时会被重新创建。(搞不太懂，后续研究！)

+ 撤销表空间（Undo Tablespaces）

  Undo空间包含很多undo日志，在MySQL5.7之前undo日志占用System Tablespace，从MySQL5.7开始可以将undo日志从System Table分离出来，这由innodb_undo_tablespaces选项进行控制，默认为0，表示使用系统表空间。如果该参数大于0，表示使用Undo表空间undo_001、undo_002等。

**重做日志**（Redo Log）

重做日志是一种基于磁盘的数据结构，用于崩溃恢复期间更正不完整事务写入的数据。MySQL将重做日志以循环方式写入文件，记录了InnoDB中所有对Buffer Pool修改的日志。

当出现实例故障，比如断电，导致数据未能更新到数据文件，那么数据库重启时就会重做redo文件中的操作，然后重新把数据更新到数据文件。

读写事务在执行过程中，都会不断产生redo log，默认情况下，重做日志在磁盘上由ib_logfile0和ib_logfile1文件物理表示（读事务也会产生redo log？）。

##### InnoDB结构演变

![image-20220107185732954](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220107185732954.png)

MySQL5.7版本

+ 通过修改innodb_undo_tablespaces选项可以将Undo表空间从System表空间中分离出来，可以在安装MySQL时由用户自行指定文件大小和数量；
+ 增加了temporary临时表空间，里面存储着临时表和临时查询结果集数据；
+ Buffer Pool大小可以动态修改，无需重启数据库实例。

MySQL8.0版本

+ 将InnoDB表的数据字典和Undo Logs都从System表空间ibdata1彻底分离出来，以前需要System表空间ibdata1中的数据字典与独立表空间ibd文件中的的数据字典(.frm???)一致才行，8.0版本就不要了。
+ 将Doublewrite Buffer从System表空间中分离出来了。
+ 用户可以像Oracle一样设置一些表空间，每个表空间对应多个物理文件，每个表空间可以给多个表使用，但是一个表只能存储在一个表空间中。

#### InnoDB线程模型

上面介绍了InnoDB引擎的内存结构（Buffer Pool、Change Buffer、Log Buffer等）和磁盘结构，那么这些缓冲区中的数据是如何更新以及如何与磁盘文件刷新同步，这些就是由后台线程来完成的。

![未命名](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/未命名.png)

**IO Thread**

在InnoDB中使用了大量的AIO（Async IO）来做读写处理，这样可以极大提高数据库的性能。在InnoDB 1.0版本之前共有4个IO thread，分别是write、read、insert buffer（后来增加了修改、更新，即Change Buffer）和log thread，后来版本将read thread和write thread分别增大到了4个，一共有10个了，通过Show engine innodb status \G;的FILE IO部分就可以查看到这10个IO Thread。

+ read thread：负责读取操作，将数据从磁盘加载到缓存page页；
+ write thread: 负责写操作，将缓存脏页刷新到磁盘；
+ log thread：负责将日志缓冲区（Log Buffer）内容刷新到磁盘；
+ insert buffer thread：负责将写缓冲（Change Buffer）内容刷新到磁盘。

**Purge Thread**

事务提交后，其使用的undo日志不再需要，因此需要Purge Thread回收已经分配的undo页。

+ Show variables like '%innodb_purge_threads%'; 默认的4表示开启（0表示关闭），且开启了4个该线程。

**Page Cleaner Thread**

作用是将脏数据刷新到磁盘，脏数据刷盘后相应的redo log就可以覆盖，这样既实现了数据同步，又能让redo log循环使用。

+ 这个过程会调用write thread线程进行处理；
+ Show variables like '%innodb_page_cleaners%';
+ 该线程进行刷新的方式：活跃刷新（常用）、空闲刷新、同步刷新。

**Master Thread**

Master thread是InnoDB的主线程，负责调度其他各线程，优先级最高。

作用是将缓冲池中的数据异步刷新到磁盘，保证数据的一致性。其中包含：脏页的刷新（page cleaner thread）、undo页回收（purge thread）、redo日志刷新（log thread）、合并写缓冲等。

它内部有两个主逻辑，分别是：

+ 每隔1s操作
  + 刷新日志缓冲区到磁盘；
  + 合并写缓冲区数据，根据IO读写压力来决定是否操作；
  + 刷新脏页数据到磁盘，脏页比例达到75%才操作（innodb_max_dirty_pages_pct），至于刷多少页到磁盘由innodb_io_capacity参数来控制；
+ 每隔10s操作
  + 刷新脏页数据到磁盘
  + 合并写缓冲区数据
  + 刷新日志缓冲区
  + 删除无用的undo页（一次删除多少由innodb_purge_batch_size控制）

#### InnoDB数据文件

数据文件：ibd文件

结构文件：frm文件

**InnoDB数据文件存储结构**

![image-20220109200204005](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220109200204005.png)

InnoDB数据文件存储结构：一个ibd数据文件 -> Segment（段）-> Extent（区）-> Page（页）-> Row（行）。

+ Tablespace：表空间，用于存储多个ibd数据文件，用于存储表的记录和索引。一个文件包含多个段。

+ Segment：

  + 段，用于管理多个Extent，分为数据段（Leaf node segment）、索引段（Non-leaf node segment）、回滚段（Rollback segment）；
  + 一张表至少会有两个segment，一个管理数据，一个管理索引。每多创建一个索引，会多两个segment（Leaf和Non-leaf）。

+ Extent：区，一个区固定包含64个连续的页，大小为1M。当表空间不足时，需要分配新的页资源，不会一页一页分，而是直接分配一个区。

+ Page：页，用于存储多个Row行记录，大小为16K。页类型有很多种，比如数据页、undo页、系统页、事务数据页、大的BLOB对象页。

+ Row：行，包含了记录的字段值、事务ID（Trx id）、滚动指针（Roll pointer）、字段指针（Field pointer）等信息。

  > Roll pointer作用：两个事务对同一条数据进行修改时，会有两个不同版本的备份用Roll pointer指针连接起来（事务版本的链），便于将来进行事务回滚操作。

Page是文件最基本的单位，无论何种类型的page，都是由page header、page trailer和page body组成的，如下图所示。

![image-20220109200502486](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220109200502486.png)

**InnoDB数据文件存储格式**

InnoDB数据文件有不同的存储格式，而不同的存储格式有不同的性能，高性能的存储格式可以在一个Page页中存储更多的Row记录，这样查找时就可以减少跨Page的查询，提高查询性能。

方法一：通过 show table status \G;命令可以查看Row_format。

> 一般情况下，如果Row_format为REDUNDANT、COMPACT，文件格式为Antelope；如果Row_format为DYNAMIC和COMPRESSED，文件格式为Barracuda。

方法二：通过 select * from information_schema.innodb_sys_tables; 可以查看表的File文件格式（File_format）和Row行格式（Row_format）。

+ **File文件格式（File_format)**

  早期的InnoDB版本中，文件格式只有一种，随着InnoDB引擎的发展，出现了新文件格式，用于支持新的功能。目前，InnoDB只支持两种文件格式：

  + Antelope：最原始的InnoDB文件格式，MySQL5.6及其以前版本默认格式，它支持两种行格式：REDUNDENT 和 COMPACT。
  + Barracuda：新的文件格式，它支持InnoDB的所有行格式，包括新的行格式：COMPRESSED 和 DYNAMIC。

  通过 innodb_file_format配置参数可以设置默认的InnoDB文件格式，5.7之前默认值为Antelope，5.7版本开始改为Barracuda。

+ **Row行格式（Row_format）**

  表的行格式决定了记录是如何物理存储的，这反过来又会影响查询和DML操作的性能。如果在单个Page页中容纳更多行，查询和索引查找可以更快，缓冲池中所需的内存更少，写入更新时所需的IO更少。

  ![image-20220126102902475](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220126102902475.png)

  如上图所示，InnoDB存储引擎支持四种行格式，DYNAMIC和COMPRESSED新格式引入的功能有：数据压缩、增强型长列数据的页外存储和大索引前缀的支持。

  每张表的数据分成若干页来存储，每页采用B树结构存储（这里不是很懂？？？）；如果某些字段信息过长，无法存储在B树节点中，这时候会被单独分配空间，此时被称为溢出页，该字段被称为页外列。

  + REDUNDANT 行格式

    表会将变长列值（长列数据）的前768字节存储在B树节点的索引记录中，其余存储在溢出页上。

    > 对于>=768字节的固定长度字段InnoDB会转换成变长字段，以便能够在页外存储。

  + COMPACT 行格式

    与REDUNDANT行格式相比，COMPACT行格式减少了约20%的行存储空间，但代价是增加了某些操作的CPU使用量。因此，如果系统负载受缓存命中率和磁盘速度限制，那么COMPACT格式可能更快；如果系统负载受CPU速度限制，那么COMPACT格式可能会慢一些。

  + DYNAMIC 行格式

    该行格式下，InnoDB会将表中变长列值完全存储在页外，而索引记录只包含指向溢出页的20个字节指针。

    > 大于或等于768字节的固定长度字段编码为可变长度字段，完全存储在页外。

    DYNAMIC行格式支持大索引前缀（说的就是上面的768字节），最多可以为3072字节，可通过innodb_large_prefix参数控制。

  + COMPRESSED 行格式

    该行格式与DYNAMIC行格式有相同的存储特性和功能，但增加了对表和索引数据压缩的支持。

  在创建表和索引时，文件格式被用于每个InnoDB表数据文件（其名称与*.ibd匹配），修改文件格式的方法是重新创建表及其索引，最简单方法是对执行如下命令：

  ```java
  ALTER TABLE 表名 ROW_FORMAT = 格式类型; // 只对修改之后数据有效，因此最好先改后再重新建表
  ```

#### Undo Log

**Undo Log介绍**

Undo：撤销/取消，以撤销操作为目的，返回某个指定状态的操作。

Undo Log：Undo意为撤销。数据库事务开始前，会将要修改的记录存放到 Undo 日志里，当事务回滚或数据库崩溃时，可以利用 Undo 日志撤销未提交事务对数据库产生的影响。

>  Undo Log产生：Undo Log在事务开始前产生；
>
> Undo Log销毁：事务提交时并不会立刻删除Undo Log（可能会使用Undo Log做多版本并发控制），InnoDB会将该事务对应的Undo Log放入到删除列表中，后面会通过后台线程Purge Thread进行回收处理。

Undo Log属于逻辑日志，记录一个变化过程。例如，执行一个delete，Undo Log会记录一个insert；执行一个update，Undo Log会记录一个相反的update。

Undo Log存储：Undo Log采用段的方式管理和记录。在InnoDB数据文件中包含一种rollback segment回滚段，内部包含1024个Undo Log Segment。通过show variables like '%innodb_undo%'; 列出的参数可以控制Undo Log存储。

> 其中的innodb_undo_tablespaces的值，0表示使用系统表空间；大于0表示使用Undo表空间，且表示了Undo日志文件的个数。

**Undo Log作用**

**实现事务的原子性**：Undo Log是为了实现事务的原子性而出现的。事务处理过程中，如果出现了错误或用户执行了Rollback语句，MySQL可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。

**实现多版本并发控制（MVCC)：**Undo Log在InnoDB存储引擎中用来实现多版本并发控制，事务未提交之前，Undo Log保存了未提交之前的版本数据，Undo Log中的数据可以作为数据旧版本快照供其他并发事务进行快照读。

![20220126](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/20220126.png)

如上图所示，事务A手动开启事务，执行更新操作，首先会把更新命中的数据备份到Undo Buffer中，此时事务A未提交；事务B手动开启事务，执行查询操作，会读取Undo Buffer/Undo Log数据返回，即进行快照读。

> 如果事务A发生错误，那么可以利用Undo Buffer数据回滚撤销对User的修改。

#### Redo Log

Redo Log和Binlog是MySQL日志系统中非常重要的两种机制，它们有很多相似之处。

**Redo Log介绍**

Redo：重做，以恢复操作为目的，在数据库发生意外时重现操作。

Redo Log：指事务中修改的任何数据，最新（修改后）的数据备份存储的位置（Redo Log），被称为重做日志。例如，假设修改  id=2 行的数据，把Name='B1'修改为Name = 'B2'，那么redo日志就会存放Name='B2'的记录（修改后的记录），如果这个修改在flush 到磁盘文件时出现异常，可以使用redo log实现重做操作，保证事务的持久性。

> Redo Log的生成：随着事务操作的执行，就会生成Redo Log；
>
> Redo Log的释放：在事务提交时会将产生的Redo Log写入Log Buffer（并不是随着事务的提交就立刻写入磁盘文件），等事务操作的脏页写入磁盘后，Redo Log的使命也就完成了，Redo Log占用的空间就可以重用（被覆盖写入）。

**Redo Log工作原理**

Redo Log是为了实现事务的持久性而出现的，防止在发生故障的时间点，还有脏页未写入表的ibd文件中，这样在重启MySQL服务时，可以根据磁盘上的Redo Log进行重做，从而将事务的未入磁盘数据进行持久化。

![20220127](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/20220127.png)

> 疑问1：每次事务提交为什么不会立刻将Buffer中的User持久化到磁盘ibd文件？降低磁盘IO。
>
> 疑问2：每次事务提交时立即将Buffer中的User写入磁盘ibd文件，会导致频繁IO，那么每次事务提交将Redo Buffer持久化到磁盘上的Redo Log就不会频繁IO吗？会，但是可能会出现这样的情况：如果id=1和id=8的两个数据的磁盘地址可能是不连续的，需要先查找定位到这两条数据后（随机IO）再更新；而修改后的两条数据连续写入Redo Buffer， 然后顺序写入磁盘Redo Log文件（顺序IO），效率更高。

**Redo Log写入机制**

![2022012701](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022012701.png)

Redo Log文件内容是以顺序循环的方式写入文件，写满时则回溯到第一个文件，进行覆盖写。如上图所示：

+ Write Pos 是当前记录的位置，一边写一边后移，写到最后一个文件末尾后就回到0号文件开头；
+ Checkpoint 是当前要擦出的位置，也是往后推移并循环的，擦出记录前要把记录更新到数据文件。
+ Write Pos和Checkpoint之间还空着的部分，可以用来记录新的操作。如果Write Pos追上Checkpint，表示写满，这时不能再执行新的更新，得停下来先擦掉一些记录，把Checkpint推进一下。

**Redo Log相关配置参数**

每个InnoDB引擎至少有1个重做日志文件组（group)，每个文件组至少有2个重做日志文件，默认为ib_logfile0和ib_logfile1。通过 show variables like '%innodb_log%'的一组参数控制Redo Log存储。

![20220128](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/20220128.png)

如上图所示，Redo Buffer 持久化到 Redo Log的策略，首先，每次事务提交都会将Redo Log先写入到Log Buffer中，Log Buffer到日志文件的写入方式可通过 Innodb_flush_log_ax_trx_commit 设置：

+ 0：后台Master线程每隔1s执行一次Redo Buffer（Log Buffer） -> OS cache -> flush cache to disk操作，可能丢失1s内的事务数据。    
+ 1（默认值）：每次事务提交执行Redo Buffer -> OS cache -> flush cache to disk，最安全、性能最差的方式。
+ 2：每次事务提交执行 Redo Buffer -> OS cache，然后由后台Master线程每隔1s执行OS cache -> flush cache to disk的操作。

一般建议选择取值2，因为MySQL挂了数据没有损失，整个服务器挂了才会损失1s的事务提交数据。

#### Binlog

InnoDB引擎利用Redo Log机制可以保障提交事务的数据持久性，即解决了事务提交后即使服务器遇到故障也能继续将修改的数据持久化到磁盘的问题。但当遇到了删库、删表操作时，该怎么处理呢？这就是Binlog的应用场景。

**Binlog记录模式**

Redo Log是属于InnoDB引擎所特有的日志，而MySQL Server也有自己的日志，即Binary log（二进制日志），简称Binlog。Binlog是记录所有数据库表结构变更以及表数据修改的二进制日志，不会记录SELECT和SHOW这类操作。Binlog日志是以事件形式记录，还包含语句执行所消耗的时间。开启Binlog日志有以下两个重要的使用场景：

+ 主从复制：在主库中开启Binlog功能，这样主库就可以把Binlog传递给从库，从库拿到Binlog后实现数据恢复达到主从数据一致性。
+ 数据恢复：通过mysqlbinlog工具来恢复数据。

Binlog文件名默认为“主机名_binlog-序列号”格式，例如 oshacker_binlog-000001，也可以在配置文件中指定名称（见后面的/etc/my.cnf中的log_bin-basename参数）。

文件记录模式有三种，具体含义如下：

+ ROW（row-based replication，PBR）：日志中会记录每一行数据被修改的情况，然后在slave端对相同的数据进行修改。主从架构中推荐使用。

  > 优点：能清楚记录每行数据的修改细节，能完全实现主从数据同步和数据的恢复；
  >
  > 缺点：批量操作（修改涉及多行），会产生大量的日志，尤其是alter table会让日志暴涨。

+ STATEMENT（statement-based Replication，SBR）：每条被修改数据的SQL都会记录到master的Binlog中，slave在复制时SQL进程会解析成master端执行的相同的SQL再次执行，即SQL语句复制。

  > 优点：日志量小，减少磁盘IO，提升存储和恢复速度；
  >
  > 缺点：某些情况下会导致主从数据不一致，比如last_insert_id()、now()等函数。

+ MIXED（mixed-based replication，MBR）：以上两种模式的混合使用，一般会使用STATEMENT模式保存Binlog，对于STATEMENT模式无法复制的操作使用ROW模式保存binlog，MySQL会根据执行的SQL语句选择写入模式。

**Binlog文件结构**

MySQL的Binlog文件中记录的是对数据库的各种修改操作，用来表示修改操作的数据结构是Log event，不同的修改操作对应不同的Log event，比如常用的Log event有：Query event、Row event、Xid event等。

Binlog文件的内容就是各种Log event的集合，Log event的结构如下：

![2022012801](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022012801.png)

**Binlog写入机制**

1. 根据记录模式和操作触发event事件生成Log event（事件触发执行机制）；

2. 将事务执行过程中产生Log event写入缓冲区，每个事务线程都有一个缓冲区。

   > Log event保存在一个Binlog_cache_mngr数据结构中，在该结构中有两个缓冲区：一个是stmt_cache，用于存放不支持事务的信息；另一个是trx_cache，用于存放支持事务的消息（Binlog属于MySQL Server，下游的存储引擎有的支持事务，有的不支持）。

3. 事务在提交阶段会将产生的Log event（存放在缓冲区中）写入到外部Binlog文件中。

   > 不同事务以串行方式将Log event写入到Binlog文件中，所以一个事务包含的Log event信息在Binlog文件中是连续的，中间不会插入其他事务的Log event。

**Binlog文件操作**

Binlog状态查看：show variables like '%log_bin%';（其中的一个参数显示了binlog文件的存放路径）

开启Binlog功能：直接通过set global log_bin=ON;会报错，因此修改/etc/my.cnf配置文件（如果没有的话添加/etc/my.cnf，[其实不是必须在/etc下添加，在安装目录根目录也可以](https://blog.csdn.net/fdipzone/article/details/52705507)），在[mysqld]下面增加log_bin=mysqlbinlog，重启MySQL服务。

```mysql
#log-bin = ON
#log_bin-basename=mysqlbinlog
# 缺少这条启动MySQL会报错：You have enabled the binary log, but you haven't provided the mandatory server-id.
server_id = 1 
binlog-format = ROW
log-bin=mysqlbinlog
```

使用show binlog events命令：

```mysql
show binary logs; // 等价于show master logs;
show master status; // 当前正在使用哪个binlog文件
show binlog events; // 查看binlog内容
show binlog events in 'mysqlbinlog.000001'; // 查看特定binlog文件的内容
```

使用mysqlbinlog命令可以查看开始结束时间等更详细的信息：

```mysql
mysqlbinlog "binlog日志文件名"
mysqlbinlog "binlog日志文件名" > "test.sql"
```

使用Binlog恢复数据：

```mysql
// 按指定时间恢复
mysqlbinlog --start-datetime = "2022-01-29 18:00:00" --stop-datetime = "2022-01-30 00:00:00" mysqlbinlog.000001 | mysql -uroot -p

// 按事件位置号恢复
mysqlbinlog --start-position=154 --stop-position=1430 mysqlbinlog.000001 | mysql -uroot -p
```

+ mysqldump：定期全部备份数据库数据；

+ mysqlbinlog：可以做增量备份和恢复备份。

删除Binlog文件

```mysql
purge binary logs to 'mysqlbinlog.000001'; // 删除指定文件
purge binary logs before '2020-04-28 00:00:00'; // 删除指定时间之前的文件
reset master; // 清除所有文件
```

+ 可以通过设置expire_logs_days参数来启动自动清理功能。默认值0表示没启用，设置为1表示超过1天的binlog文件会自动删除。

**Redo Log和BinLog的区别**

两者相同：都会把对数据库的更改操作记录到日志文件，可以用于恢复数据。

两者不同：

+ Redo Log属于InnoDB引擎功能，Binlog属于MySQL Server自带功能，并且是二进制文件记录；

+ Redo Log属于物理日志，记录该数据页更新状态内容（我的理解是更新结果），Binlog是逻辑日志，记录更新过程；

+ Redo Log日志是循环写，日志空间大小固定，Binlog是追加写入，写完一个写下一个，不会覆盖使用；

+ Redo Log作为服务器异常宕机后事务数据自动恢复使用，Binlog可以作为主从复制和数据恢复使用。Binlog没有自动crash-safe能力，即服务器宕机后重启无法自动恢复之前的操作（无法保证已提交的事务数据正常写入磁盘）。

> Binlog是引擎插件上层（MySQL Server）的功能，事务提交第一个会调用Binlog功能接口，然后再调用存储引擎的功能接口。因此，先写Binlog，然后再执行InnoDB的Redo /Undo Log和脏页刷新操作。

## MySQL索引原理

### 索引类型

索引可以提升查询速度，会影响where查询以及order by排序。MySQL索引类型如下：

+ 从索引存储结构划分：B Tree索引、Hash索引、FULLTEXT索引(底层是倒排索引)、R Tree索引（B Tree的多维空间）；
+ 从应用层次上划分：普通索引、唯一索引、主键索引、复合索引；
+ 从索引键值（字段）类型划分：主键索引、辅助索引（二级索引）
+ 从数据存储和索引键值逻辑关系划分：聚集索引（聚簇索引：索引和记录放在一起）、非聚集索引（非聚簇索引：记录和索引数据分开放）

#### 普通索引

这是最基本的索引类型，基于普通字段（非主键、非唯一约束字段）建立的索引，没有任何限制。创建普通索引的方法：

```sql
CREATE INDEX <索引的名字> ON tablename(字段名);
ALTER TABLE tablename ADD INDEX [索引的名字](字段名);
CREATE TABLE tablename([...], INDEX [索引的名字](字段名));

// 查看索引
show index from tablename;
// 删除索引
drop index <索引的名字> on tablename;
```

#### 唯一索引

与普通索引类似，唯一索引字段可以为空且可以多条记录中该字段均为空，不同点是唯一索引字段值必须唯一。创建唯一索引的方法：

```SQL
CREATE UNIQUE INDEX <索引的名字> ON tablename(字段名);
ALTER TABLE tablename ADD UNIQUE INDEX [索引的名字](字段名);
CREATE TABLE tablename([...], UNIQUE [索引的名字](字段名));
```

另外，在创建或修改表时追加唯一约束，就会自动创建对应的唯一索引。

#### 主键索引

一种特殊的唯一索引，与唯一索引不同的是不允许有空值。创建主键索引的方法：

```sql
ALTER TABLE tablename ADD PRIMARY KEY (字段名);
CREATE TABLE tablename([...], PRIMARY KEY (字段名));
```

在创建或修改表时追加主键约束即可，每个表只能有一个主键。

#### 复合索引

单一索引指索引列为一列的情况；用户可以对多个列建立索引，即复合索引（组合索引）。复合索引可以代替多个单一索引，与多个单一索引相比，复合索引所需的开销更小。

索引还有宽、窄索引之分，窄索引是指索引列为1-2列的索引，宽索引是指索引列超过2列的索引。**设计索引的一个重要原则**是能用窄索引不用宽索引，因为窄索引往往比宽索引占用空间小、查找效率更高。但前面提到，如果有大量的窄索引，那么不如将它们组合成一个宽索引。

创建复合索引的方法：

```sql
CREATE INDEX <索引的名字> ON tablename(字段名1, 字段名2...);
ALTER TABLE tablename ADD INDEX [索引的名字](字段名1, 字段名2...);
CREATE TABLE tablename([...], INDEX [索引的名字](字段名1, 字段名2...)); 
```

复合索引使用注意事项：

+ 查询时建议但非必须按照索引字段的顺序使用，因为MySQL底层的优化器会进行优化，调整索引的顺序。

+ 何时使用复合索引，要根据where条件建索引，但注意不要过多使用索引，过多使用会对更新操作效率有很大影响。
+ 如果表已经建立了索引（col1,col2），就没有必要再单独建索引（col1）；如果现在已经有索引（col1），但查询需要col1和col2条件，可以建立复合索引（col1，col2），对查询有一定提高。

#### 全文索引

查询操作在数据量比较少时，可以使用like模糊查询，但是对于大量的文本数据检索，效率很低。如果使用全文索引，查询速度会比like快很多倍。

> MySQL5.6以前的版本，只有MyISAM存储引擎支持全文索引，MySQL5.6开始MyISAM和InnoDB存储引擎均支持。

创建全文索引的方法如下：

```sql
CREATE FULLTEXT INDEX <索引的名字> ON tablename(字段名);
ALTER TABLE tablename ADD FULLTEXT INDEX [索引的名字](字段名);
CREATE TABLE tablename([...], FULLTEXT KEY [索引的名字](字段名)); 
```

和常用的like模糊查询不同，全文索引有自己的语法格式，使用match和against关键字如下：

```sql
SELECT * FROM person WHERE match(name) against('aaa');
```

全文索引使用注意事项：

+ 相关参数：show variables like '%ft%'; 

+ 全文索引必须在字符串、文本字段上建立；

+ 全文索引字段值必须在最小字符和最大字符之间时，索引才有效（innodb: 3-84; myisam: 4-84）。因此使用InnoDB引擎时，通过全文索引查询name为aaa能找到，但是查询name为aa就找不到。

  > 参数ft_max_word_len和ft_min_word_len适用于MyISAM，innodb_ft_max_token_size和innodb_ft_min_token_size适用于InnoDB。

+ 全文索引字段值要进行切词处理，按参数ft_boolean_syntax中的字符进行切割，如b+aaa，切分成b和aaa，这样通过全文索引查询name为aaa时就能找到b+aaa，而不能找到baaa。

+ 全文索引匹配查询默认使用的是等值匹配，比如a匹配a，不会匹配ab,ac。如果想匹配在布尔模式下搜索a*。

  ```sql
  SELECT * FROM person WHERE match(name) against('a*' in boolean mode);
  ```

### 索引原理

MySQL官方对索引的定义：是存储引擎用于快速查找记录的一种数据结构，需要额外开辟空间和数据维护工作。

+ 索引是物理数据页存储，在ibd数据文件中利用数据页page存储；
+ 索引可以加快检索速度，但同时也会降低增删改操作速度，因为索引维护需要代价（比如删除了书的某一章节内容，相应的目录也要进行删除，所以并不是索引越多越好）。

索引涉及的理论知识：二分查找法、Hash和B+ Tree。

#### 二分查找法

二分查找法是在有序数组中查找指定数据的搜索算法。它的优点是等值查询、范围查询性能好；缺点是增删改数据维护成本高。

二分查找算法具体内容略。

#### Hash结构

Hash结构底层是由Hash表来实现的，是根据键值<key,value>存储数据的结构。适合根据key查找value值，即等值查询。

![20220208](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/20220208.png)

从上图可知，Hash索引可以方便的提供等值查询，但是对于范围查询就需要全表扫描了。在MySQL中Hash结构主要应用在Memory原生的Hash索引、InnoDB自适应哈希索引。

InnoDB自适应哈希索引是为了提升查询效率，原理是InnoDB会监控表上各个索引页的查询，当注意到某些索引值访问非常频繁时，会在内存中基于B+ Tree再创建一个哈希索引，使得内存中的B+ Tree索引具备哈希索引的功能，即能够快读定值访问频繁访问的索引页。

本来表中的数据已经采用B+ Tree建立索引，之所以还要建立自适应哈希索引是因为通过Hash索引访问，一次查找就能定位数据，等值查询效率优于B+ Tree（取决于树的高度，一般3-4层），所以引入自适应哈希索引是为了进一步优化（自适应哈希索引的建立使得InnoDB能自动根据索引页访问的频率和模式，自动地为某些热点页建立哈希索引来加快访问）。

另外，InnoDB自适应哈希索引的功能，用户只能选择开启或关闭，无法进行人工干预。

```sql
show engine innodb status \G; // 查看使用和不使用该索引的效率
show variables like '%innodb_adaptive%'; //如果使用该索引反而效率低，那么可以关闭该索引
```

#### B+ Tree结构

MySQL数据库采用的是B+ Tree结构，在B-Tree结构上做了优化改造。

![2022020801](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022020801.png)

B-Tree结构如上图所示

+ 索引值和data数据分布在整棵树结构中；
+ 每个节点可以存放多个索引值及对应的data数据；
+ 树节点中的多个索引值从左到右升序排列。

B树的搜索：从根节点开始，对节点内的索引值序列采用二分法查找，如果命中就结束查找；如果没有命中，就会进入子节点重复查找过程，直到所对应的节点指针为空或已经是叶子结点了才结束。

![2022020802](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022020802.png)

B+ Tree结构如上图所示

+ 非叶子节点不存储data数据，只存储索引值，这样便于存储更多的索引值；
+ 叶子节点包含了所有索引值和data数据；
+ 叶子节点用指针连接，提高区间的访问性能。

相比B树，B+树进行范围查找时，只需要查找定位两个节点的索引值，然后利用叶子节点的指针进行遍历即可；而B树需要遍历范围内所有的节点和数据，显然B+树效率高。但如果是等值查找，可能在中间就找到了，这样B树的效率反而更高，因为不用像B+树需要遍历到叶子节点。

#### 聚簇索引和辅助索引

**（结论）聚簇索引和非聚簇索引**

+ 聚簇索引：B+ Tree的叶子节点存放主键索引值和行记录；

+ 非聚簇索引：索引值和行记录分开存放。

**（结论）主键索引和辅助索引（二级索引）**

+ 主键索引：B+ Tree的叶子节点存放的是主键字段值；
+ 辅助索引（二级索引）：B+ Tree的叶子节点存放的是非主键值。

结论：在InnoDB存储引擎中，主键索引采用的就是聚簇索引结构存储。

**聚簇索引、主键索引**

![2022020804](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022020804.png)

聚簇索引是一种数据存储方式，InnoDB的聚簇索引就是按照主键值顺序构建的B+ Tree结构，B+ Tree的叶子节点就是行记录，行记录和主键值紧凑地存储在一起。也就是说，InnoDB的主键索引就是数据表本身，它按主键顺序存放了整张表的数据，占据的空间就是整个表数据量的大小。**通常所说的主键索引就是聚簇索引**。

InnoDB表要求必须有聚簇索引：

+ 如果表定义了主键，则主键索引就是聚簇索引；
+ 如果表没有定义主键，则第一个非空unique列作为聚簇索引，否则InnoDB会创建一个隐藏的row-id作为聚簇索引。

**辅助索引（二级索引）**

辅助索引是根据索引列构建B+ Tree结构，但B+ Tree的叶子节点只存储了索引列和主键的信息。二级索引占用的空间会比聚簇索引小很多，通常创建辅助索引就是为了提升查询效率。一个InnoDB表只能创建一个聚簇索引，但可以创建多个辅助索引。

**非聚簇索引**

与InnoDB表存储不同，MyISAM表的索引文件和数据文件是非开的，被称为非聚簇索引结构。

![2022020806](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022020806.png)

### 索引分析与优化

```mysql
mysql> show create table person \G;
*************************** 1. row ***************************
       Table: person
Create Table: CREATE TABLE `person` (
  `id` int(11) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `name_1` (`name`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8
1 row in set (0.00 sec)

ERROR: 
No query specified

mysql> select * from person;
+----+----------+------+
| id | name     | age  |
+----+----------+------+
|  1 | zhangsan |   23 |
|  2 | lisi     |   24 |
|  3 | wangwu   |   25 |
|  4 | zhaoliu  |   26 |
+----+----------+------+
4 rows in set (0.00 sec)

mysql> show index from person \G;
*************************** 1. row ***************************
        Table: person
   Non_unique: 0
     Key_name: PRIMARY
 Seq_in_index: 1
  Column_name: id
    Collation: A
  Cardinality: 4
     Sub_part: NULL
       Packed: NULL
         Null: 
   Index_type: BTREE
      Comment: 
Index_comment: 
*************************** 2. row ***************************
        Table: person
   Non_unique: 1
     Key_name: name_1
 Seq_in_index: 1
  Column_name: name
    Collation: A
  Cardinality: 4
     Sub_part: NULL
       Packed: NULL
         Null: YES
   Index_type: BTREE
      Comment: 
Index_comment: 
2 rows in set (0.00 sec)

ERROR: 
No query specified
```

#### EXPLAIN

MySQL提供了EXPLAIN命令对SELECT语句进行分析，会输出SELECT执行的详细信息（执行计划）供开发人员有针对性的优化。比如：

```mysql
mysql> explain select * from person where id < 3 \G;
*************************** 1. row ***************************
           id: 1					# select查询的标识符，每个select都会自动分配一个唯一的标识符
  select_type: SIMPLE			# select查询的类型
        table: person			# 查询的是哪个表
   partitions: NULL				# 匹配的分区
         type: range			# join类型
possible_keys: PRIMARY		# 此次查询可能选用的索引
          key: PRIMARY		# 此次查询确认使用到的索引
      key_len: 4
          ref: NULL				# 哪个字段或常数与key一起被使用
         rows: 2					# 此次查询一共扫描了多少行（估计值）
     filtered: 100.00			
        Extra: Using where # 额外的信息 
1 row in set, 1 warning (0.01 sec)

ERROR: 
No query specified
```

select_type表示查询的类型，常用的值如下：

+ SIMPLE（最常见）：表示查询语句不包含子查询或union；

+ PRIMARY：表示此查询是最外层的查询；

+ UNION：表示此查询是UNION的第二个或后续的查询；

+ DEPENDENT UNION：UNION中的第二个或后续的查询语句使用到了外面的查询结果；

+ UNION RESULT：UNION的结果；

+ SUBQUERY：SELECT子查询语句；

+ DEPENDENT SUBQUERY：SELECT子查询语句依赖外层查询的结果。

  ```mysql
  mysql> explain select * from person where id = 2 \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: const
  possible_keys: PRIMARY
            key: PRIMARY
        key_len: 4
            ref: const
           rows: 1
       filtered: 100.00
          Extra: NULL
  1 row in set, 1 warning (0.01 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain select id from person where id = 2 \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: const
  possible_keys: PRIMARY
            key: PRIMARY
        key_len: 4
            ref: const
           rows: 1
       filtered: 100.00
          Extra: Using index
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain select * from person where id = 1
      -> union
      -> select * from person where id = 2 \G;
  *************************** 1. row ***************************
             id: 1
    select_type: PRIMARY
          table: person
     partitions: NULL
           type: const
  possible_keys: PRIMARY
            key: PRIMARY
        key_len: 4
            ref: const
           rows: 1
       filtered: 100.00
          Extra: NULL
  *************************** 2. row ***************************
             id: 2
    select_type: UNION
          table: person
     partitions: NULL
           type: const
  possible_keys: PRIMARY
            key: PRIMARY
        key_len: 4
            ref: const
           rows: 1
       filtered: 100.00
          Extra: NULL
  *************************** 3. row ***************************
             id: NULL
    select_type: UNION RESULT
          table: <union1,2>
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: NULL
       filtered: NULL
          Extra: Using temporary
  3 rows in set, 1 warning (0.01 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain select * from person where id = (select max(id) from person) \G;
  *************************** 1. row ***************************
             id: 1
    select_type: PRIMARY
          table: person
     partitions: NULL
           type: const
  possible_keys: PRIMARY
            key: PRIMARY
        key_len: 4
            ref: const
           rows: 1
       filtered: 100.00
          Extra: NULL
  *************************** 2. row ***************************
             id: 2
    select_type: SUBQUERY
          table: NULL
     partitions: NULL
           type: NULL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: NULL
       filtered: NULL
          Extra: Select tables optimized away
  2 rows in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> insert into person values(5,'hello',23);
  Query OK, 1 row affected (0.00 sec)
  
  # 相关子查询的执行过程，具体参考：https://blog.csdn.net/qq_38238296/article/details/86251165
  mysql> explain select * from person p1 where p1.id = (select max(p2.id) from person p2 where p2.age = p1.age) \G;
  *************************** 1. row ***************************
             id: 1
    select_type: PRIMARY
          table: p1
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 5
       filtered: 100.00
          Extra: Using where
  *************************** 2. row ***************************
             id: 2
    select_type: DEPENDENT SUBQUERY
          table: p2
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 5
       filtered: 20.00
          Extra: Using where
  2 rows in set, 2 warnings (0.00 sec)
  
  ERROR: 
  No query specified
  ```

type表示存储引擎查询数据时采用的方式。这是比较重要的一个属性，通过它可以判断出查询是全表扫描还是基于索引的部分扫描。常用的属性值（从上至下效率依次增强）如下：

+ ALL：表示全表扫描，性能最差；(possible_keys和key字段都是NULL，即没有使用到索引，此外rows很大)

  ```mysql
  mysql> explain select * from person where age = 23 \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 5
       filtered: 20.00
          Extra: Using where
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

+ index：表示基于索引的全表扫描，先扫描索引再扫描全表数据；

  ```mysql
  mysql> explain select * from person where age = 23\G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 5
       filtered: 20.00
          Extra: Using where
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain select * from person where age = 23 order by age \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 5
       filtered: 20.00
          Extra: Using where
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain select * from person where age = 23 order by name \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 5
       filtered: 20.00
          Extra: Using where; Using filesort
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain select * from person where age = 23 order by id \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: index
  possible_keys: NULL
            key: PRIMARY
        key_len: 4
            ref: NULL
           rows: 5
       filtered: 20.00
          Extra: Using where
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

+ range：表示使用索引范围查询，一般在使用>、>=、<、<=、in等；

  ```sql
  mysql> explain select * from person where age >= 23 \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 5
       filtered: 33.33
          Extra: Using where
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain select * from person where name >= 'zhang' \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: range
  possible_keys: name_1
            key: name_1
        key_len: 768
            ref: NULL
           rows: 2
       filtered: 100.00
          Extra: Using index condition
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain select name from person where name >= 'zhang' \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: range
  possible_keys: name_1
            key: name_1
        key_len: 768
            ref: NULL
           rows: 2
       filtered: 100.00
          Extra: Using where; Using index
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain select * from person where id >= 1 \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: range
  possible_keys: PRIMARY
            key: PRIMARY
        key_len: 4
            ref: NULL
           rows: 5
       filtered: 100.00
          Extra: Using where
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain select id from person where id >= 1 \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: range
  possible_keys: PRIMARY
            key: PRIMARY
        key_len: 4
            ref: NULL
           rows: 5
       filtered: 100.00
          Extra: Using where; Using index
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

+ ref：表示使用非唯一索引进行单值查询；

  ```mysql
  mysql> explain select * from person where name = 'zhangsan' \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: ref
  possible_keys: name_1
            key: name_1
        key_len: 768
            ref: const
           rows: 1
       filtered: 100.00
          Extra: NULL
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> insert into person values(6,'zhangsan',27);
  Query OK, 1 row affected (0.00 sec)
  mysql> explain select * from person where name = 'zhangsan' \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: ref
  possible_keys: name_1
            key: name_1
        key_len: 768
            ref: const
           rows: 2
       filtered: 100.00
          Extra: NULL
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> insert into person values(7,'zhangsan',28);
  Query OK, 1 row affected (0.00 sec)
  # 当name='zhangsan'的数量大于等于3时
  mysql> explain select * from person where name = 'zhangsan' \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: ALL
  possible_keys: name_1
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 7
       filtered: 42.86
          Extra: Using where
  1 row in set, 1 warning (0.01 sec)
  
  ERROR: 
  No query specified
  ```

+ eq_ref：一般情况出现在多表join查询，表示前面表的每行记录都只能匹配后面表的一行结果（一对一关系）；

  ```mysql
  mysql> create table score (
      -> id int primary key auto_increment,
      -> person_id int,
      -> score int) engine=innodb charset=utf8;
  Query OK, 0 rows affected (0.02 sec)
  
  mysql> select * from score;
  +----+-----------+-------+
  | id | person_id | score |
  +----+-----------+-------+
  |  1 |         1 |    80 |
  |  2 |         2 |    90 |
  |  3 |         3 |   100 |
  +----+-----------+-------+
  3 rows in set (0.00 sec)
  
  mysql> explain select * from person p,score s where p.id = s.person_id \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: s
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 3
       filtered: 100.00
          Extra: Using where
  *************************** 2. row ***************************
             id: 1
    select_type: SIMPLE
          table: p
     partitions: NULL
           type: eq_ref
  possible_keys: PRIMARY
            key: PRIMARY
        key_len: 4
            ref: test.s.person_id
           rows: 1
       filtered: 100.00
          Extra: NULL
  2 rows in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

+ const：表示使用主键或唯一索引做等值查询（常量查询）；

  ```mysql
  mysql> explain select * from person where id = 1 \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: const
  possible_keys: PRIMARY
            key: PRIMARY
        key_len: 4
            ref: const
           rows: 1
       filtered: 100.00
          Extra: NULL
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

+ NULL：表示不访问表，速度最快。

  ```mysql
  mysql> explain select now() \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: NULL
     partitions: NULL
           type: NULL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: NULL
       filtered: NULL
          Extra: No tables used
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

possible_key表示查询时能够使用到的索引名称。注意：不一定会真正使用。

key表示查询时真正使用到的索引，显示的是索引名称。

rows指MySQL查询优化器估算SQL查询到结果需要扫描多少行记录。原则上rows越少效率越高，可以直观了解到SQL效率高低。

key_len表示查询使用了索引的字节数量。可以判断是否全部使用了组合索引。key_len的计算规则如下：

+ 字符串类型
  + 字符串长度跟字符集有关：latin1=1、gbk=2、utf8=3、utf8mb4=4
  + char(n)：n*字符集长度
  + varchar(n)：n*字符集长度+2字节
+ 数值类型
  + TINYINT：1个字节
  + SMALLINT：2个字节
  + MEDIUMINT：3个字节
  + INT、FLOAT：4个字节
  + BIGINT、DOUBLE：8个字节
+ 时间类型
  + DATE：3个字节
  + TIMESTAMP：4个字节
  + DATETIME：8个字节

此外，如果该字段可以为NULL，那么需要额外增加一个字节（NULL属性占用1个字节）；如果一个字段设置了NOT NULL，则没有此项。比如，在上面的例子中，key_len为768=255*3+2+1。

Extra：表示很多额外的信息，各种操作会在Extra提示相关信息，常见的如下：

+ Using where：表示查询需要通过索引回表查询数据；

  ```mysql
  mysql> explain select * from person where name = 'zhangsan' \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: ALL
  possible_keys: name_1
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 7
       filtered: 42.86
          Extra: Using where
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

+ Using index：表示查询需要通过索引，索引就可以满足所需数据。

  ```mysql
  mysql> explain select name from person \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: index
  possible_keys: NULL
            key: name_1
        key_len: 768
            ref: NULL
           rows: 7
       filtered: 100.00
          Extra: Using index
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

+ Using filesort：表示查询出来的结果需要额外排序（如果有索引就不需要了，因为可以通过索引得到排序数据；如果没有索引，就需要额外排序，数据量小在内存，大的话在磁盘，因此有Using filesort建议优化）；

  ```mysql
  mysql> explain select * from person order by age \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 7
       filtered: 100.00
          Extra: Using filesort
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain select * from person order by name \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 7
       filtered: 100.00
          Extra: Using filesort
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain select name from person order by name \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: index
  possible_keys: NULL
            key: name_1
        key_len: 768
            ref: NULL
           rows: 7
       filtered: 100.00
          Extra: Using index
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain select * from person order by id \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: index
  possible_keys: NULL
            key: PRIMARY
        key_len: 4
            ref: NULL
           rows: 7
       filtered: 100.00
          Extra: NULL
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

+ Using temporary：查询使用到了临时表，一般出现于去重、分组等操作，有的话尽量优化掉。

  ```mysql
  mysql> explain select distinct(age) from person \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 7
       filtered: 100.00
          Extra: Using temporary
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain select age,max(id) from person group by age \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 7
       filtered: 100.00
          Extra: Using temporary; Using filesort
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

+ 其他

  ```mysql
  mysql> explain select * from person where 1 < 0 \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: NULL
     partitions: NULL
           type: NULL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: NULL
       filtered: NULL
          Extra: Impossible WHERE
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain select * from person where id = 0 \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: NULL
     partitions: NULL
           type: NULL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: NULL
       filtered: NULL
          Extra: no matching row in const table
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  # ...
  ```

#### 回表查询

前面提到InnoDB索引有聚簇索引和辅助索引。聚簇索引由一棵B+树构建，其中非叶子节点存储的是主键值，叶子节点存储整行记录，InnoDB表必须有且只有一个聚簇索引。辅助索引也是由一棵B+树构建，其中非叶子节点存储索引字段值，叶子节点存储的是索引字段值和主键值。通过辅助索引无法直接定位行记录，通常情况下，先通过辅助索引定位主键值，然后再通过聚簇索引定位行记录（SQL所需的列包含除辅助索引字段和主键之外的其他字段），这就叫做回表查询，它的性能比扫一遍索引树低。

总结：

+ 通过辅助索引查询主键值，然后再去聚簇索引查询记录信息。
+ 如果explain 的Extra字段为Using where，则表示发生了回表查询。如果能够将其优化成Using index，查询性能就会有很大提升。

#### 覆盖索引

SQL Server官网关于What is a covering index?的介绍如下：

```
A covering index is a non-clustered index which includes all columns referenced in the query and therefore, the optimizer does not have to perform an additional lookup to the table in order to retrieve the data requested. As the data requested is all indexed by the covering index, it is a faster operation.

覆盖索引是一个辅助索引，它包括查询中涉及的所有列，因此优化器不必为了检索请求的数据而对表执行额外的查找。由于请求的数据全部由覆盖索引索引，因此操作速度更快
```

MySQL官网类似的说法出现在explain查询计划优化章节，即**explain的输出结果中Extra字段为Using index时**，能够触发索引覆盖。

![image-20220209190249151](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220209190249151.png)

不管是SQL Server官网，还是MySQL官网都表达了：只需要在一棵索引树上就能获取SQL所需的所有列数据（查询需要的字段都在索引中），无需回表，速度更快，这就叫做**索引覆盖**。

实现索引覆盖最常见的办法就是：将被查询的字段建立到组合索引。

```mysql
# 添加索引实现索引覆盖

mysql> drop index name_1 on person;
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select count(name) from person \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: person
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 7
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified

mysql> create index name_1 on person(name);
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select count(name) from person \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: person
   partitions: NULL
         type: index
possible_keys: NULL
          key: name_1
      key_len: 768
          ref: NULL
         rows: 7
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified

# 添加组合索引实现索引覆盖

mysql> explain select id,name,age from person where name='lisi'\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: person
   partitions: NULL
         type: ref
possible_keys: name_1
          key: name_1
      key_len: 768
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified

mysql> create index name_age on person(name,age);
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select id,name,age from person where name='lisi'\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: person
   partitions: NULL
         type: ref
possible_keys: name_1,name_age
          key: name_1
      key_len: 768
          ref: const
         rows: 1
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified

mysql> drop index name_1 on person;
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select id,name,age from person where name='lisi'\G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: person
   partitions: NULL
         type: ref
possible_keys: name_age
          key: name_age
      key_len: 768
          ref: const
         rows: 1
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified
```

#### 最左前缀原则

复合索引使用时遵循最左前缀原则，即最左优先，查询中使用最左边的列就会使用到索引；如果从索引的第二列开始查找，索引将失效。

![20220210](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/20220210.png)

```mysql
mysql> drop index name_age on person;
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select id from person where age=23 and name='lisi' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: person
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 7
     filtered: 14.29
        Extra: Using where
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified

mysql> create index age_1 on person(age);
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

# 这里age索引生效了，但当age=23的数量大于等于3时，type变为ALL，即索引又失效了（为什么？？？）。
mysql> explain select id from person where age=23 and name='lisi' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: person
   partitions: NULL
         type: ref
possible_keys: age_1
          key: age_1
      key_len: 5
          ref: const
         rows: 2
     filtered: 14.29
        Extra: Using where
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified

mysql> update person set age=23 where id = 7;
Query OK, 1 row affected (0.01 sec)
Rows matched: 1  Changed: 1  Warnings: 0

# 当age=23的数量大于等于3时，type为ALL，即索引失效
mysql> explain select id from person where age=23 and name='lisi' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: person
   partitions: NULL
         type: ALL
possible_keys: age_1
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 7
     filtered: 14.29
        Extra: Using where
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified

# 单独使用age索引生效
mysql> explain select id from person where age=23 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: person
   partitions: NULL
         type: ref
possible_keys: age_1
          key: age_1
      key_len: 5
          ref: const
         rows: 3
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified

mysql> drop index age_1 on person;
Query OK, 0 rows affected (0.02 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> create index age_name on person(age,name);
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

# 符合最左匹配原则
mysql> explain select id from person where age=23 and name='lisi' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: person
   partitions: NULL
         type: ref
possible_keys: age_name
          key: age_name
      key_len: 773
          ref: const,const
         rows: 1
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified

# 符合最左匹配原则
mysql> explain select id from person where age=23 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: person
   partitions: NULL
         type: ref
possible_keys: age_name
          key: age_name
      key_len: 5
          ref: const
         rows: 3
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified

# 不符合最左匹配原则（虽然key为age_name，但rows为7，即全表扫描）
mysql> explain select id from person where name='lisi' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: person
   partitions: NULL
         type: index
possible_keys: NULL
          key: age_name
      key_len: 773
          ref: NULL
         rows: 7
     filtered: 14.29
        Extra: Using where; Using index
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified

# 查询优化器对索引顺序进行优化
mysql> explain select id from person where name='lisi' and age=23 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: person
   partitions: NULL
         type: ref
possible_keys: age_name
          key: age_name
      key_len: 773
          ref: const,const
         rows: 1
     filtered: 100.00
        Extra: Using index
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified
```

此外，如果索引有多个（name，name_age，name_age_sex)，查询时用哪个呢？MySQL会选择获取结果记录数rows最少的索引，如果一样多，会选择最先建立的索引。

#### LIKE查询

MySQL使用like模糊查询时，只有把%字符写在后面才会使用到索引，如下：

```mysql
# 不起作用
mysql> explain select * from person where name like '%h%' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: person
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 7
     filtered: 14.29
        Extra: Using where
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified

# 起作用
mysql> explain select * from person where name like 'h%' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: person
   partitions: NULL
         type: range
possible_keys: name_1
          key: name_1
      key_len: 768
          ref: NULL
         rows: 1
     filtered: 100.00
        Extra: Using index condition
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified

# 不起作用
mysql> explain select * from person where name like '%h' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: person
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 7
     filtered: 14.29
        Extra: Using where
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified
```

**索引下推**（Index Condition Pushdown, ICP）：ICP是MySQL5.6引入的新功能，主要核心点在于把数据筛选的过程放在了存储引擎去处理，而不是像之前一样放到Server层去做过滤。

索引下推是否开启：show variables like '%optimizer_switch%' \G;，发现index_condition_pushdown=on表示已开启。

索引下推更多请参考：

+ （已读）https://zhuanlan.zhihu.com/p/405867762
+ （未读，深入学习再读）https://zhuanlan.zhihu.com/p/351446942

> Extra为Using index condition并不代表一定是使用了索引下推，只能代表可以使用，但是不一定用了。切记索引下推一定是在联合索引的情况下，根据联合索引本身就有的数据直接做一次过滤，而不用进行多次无用的回表后再到Server层进行过滤。

#### NULL查询

对于MySQL来说，NULL是一个特殊的值，从概念上讲NULL意味着“一个未知值”，它的处理方式与其他值（比如空值，varchar类型空值指空字符串）有些不同。比如：不能使用=，<, >这样的运算符，对NULL做算术运算的结果都是NULL，count时不会包括NULL行，NULL比空字符串需要更多的存储空间等。

关于最后一点，官网的解释如下：

```
NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte.
```

NULL列（如果可能为NULL的话）需要额外空间记录其值是否为NULL。对于MyISAM表，每个NULL列多占用一位，四舍五入到最接近的字节。

> 空值和NULL的区别：空值是不占用空间的，但是NULL其实是占用空间的。空值就相当于抽真空的杯子，NULL值相当于装满空气的杯子。

**如果MySQL表的某一列含有NULL值，那么包含该列的索引是否有效？**

![20220211](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/20220211.png)

```mysql
mysql> insert into person values(8,null,28);
Query OK, 1 row affected (0.00 sec)
mysql> insert into person values(9,null,29);
Query OK, 1 row affected (0.00 sec)

# 单索引
mysql> explain select * from person where name is null \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: person
   partitions: NULL
         type: ref
possible_keys: name_1
          key: name_1
      key_len: 768
          ref: const
         rows: 2
     filtered: 100.00
        Extra: Using index condition
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified

# 组合索引
mysql> create index name_age on person(name,age);
Query OK, 0 rows affected (0.25 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> drop index name_1 on person;
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select * from person where name is null \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: person
   partitions: NULL
         type: ref
possible_keys: name_age
          key: name_age
      key_len: 768
          ref: const
         rows: 2
     filtered: 100.00
        Extra: Using where; Using index
1 row in set, 1 warning (0.01 sec)

ERROR: 
No query specified

mysql> explain select * from person where name is null and age=28 \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: person
   partitions: NULL
         type: ref
possible_keys: name_age
          key: name_age
      key_len: 773
          ref: const,const
         rows: 1
     filtered: 100.00
        Extra: Using where; Using index
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified
```

MySQL可以在含有NULL的列上使用索引，但NULL和其他数据还是有区别的，因此不建议列允许为NULL。如果一定要使用，最好设置为NOT NULL，然后给一个默认值（0，空字符串，datetime类型设置为系统当前时间或某个固定的特殊值，比如'1970-01-01 00:00:00'）。

#### 索引与排序

MySQL查询支持两种方式的排序：

+ filesort是先把结果查出来，然后在缓存或磁盘进行排序操作，效率较低。
+ index是利用索引自动实现排序（查出来的已排好序），无需另做排序操作，效率比较高。

filesort有两种排序算法：

+ 双路排序（旧）：需要两次磁盘扫描读取，最终拿到排序数据后返回。第一次将排序字段读取出来，然后在内存中排序；第二次读取其他字段数据，然后将两次数据并在一起后返回。
+ 单路排序（新）：从磁盘查询所需的所有列数据，然后在内存排序后返回。如果查询出来的数据超出缓存sort_buffer，那么会分多次加载到内存中，这样会导致多次读盘操作（产生多次IO，这样就非单路，也非双路，而是多路，效率比双路排序还低），并创建临时表，直到都处理完再返回，反而会增加负担。因此，应少用select *，并增加sort_buffer_size和max_length_for_sort_data的容量。

> 使用Explain分析SQL时，如果Extra属性显示Using filesort，表示使用了filesort排序方式，需要优化；如果Extra属性显示Using index（建议），表示覆盖索引，即所有操作都在索引上完成，因此表示使用了index排序方式。 

使用index方式的排序

+ order by子句索引列组合满足最左前缀原则（我的理解是没有where子句）

  ```mysql
  mysql> drop index name_age on person;
  Query OK, 0 rows affected (0.01 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  
  mysql> explain select id from person order by id \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: index
  possible_keys: NULL
            key: PRIMARY
        key_len: 4
            ref: NULL
           rows: 9
       filtered: 100.00
          Extra: Using index
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

+ where子句与order by子句索引列组合满足最左前缀原则

  ```mysql
  mysql> show index from person \G;
  *************************** 1. row ***************************
          Table: person
     Non_unique: 0
       Key_name: PRIMARY
   Seq_in_index: 1
    Column_name: id
      Collation: A
    Cardinality: 9
       Sub_part: NULL
         Packed: NULL
           Null: 
     Index_type: BTREE
        Comment: 
  Index_comment: 
  1 row in set (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain select id from person where age=23 order by name \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 9
       filtered: 11.11
          Extra: Using where; Using filesort
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> create index age_name on person(age,name);
  Query OK, 0 rows affected (0.02 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  
  mysql> explain select id from person where age=23 order by name \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: ref
  possible_keys: age_name
            key: age_name
        key_len: 5
            ref: const
           rows: 3
       filtered: 100.00
          Extra: Using where; Using index
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

使用filesort方式的排序

+ 对索引列同时使用了ASC和DESC

  ```mysql
  mysql> explain select id from person order by age,name \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: index
  possible_keys: NULL
            key: age_name
        key_len: 773
            ref: NULL
           rows: 9
       filtered: 100.00
          Extra: Using index
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain select id from person order by age asc,name desc \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: index
  possible_keys: NULL
            key: age_name
        key_len: 773
            ref: NULL
           rows: 9
       filtered: 100.00
          Extra: Using index; Using filesort
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

+ order by或where+order by索引列不满足最左前缀原则

  ```mysql
  mysql> explain select id from person order by name \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: index
  possible_keys: NULL
            key: age_name
        key_len: 773
            ref: NULL
           rows: 9
       filtered: 100.00
          Extra: Using index; Using filesort
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

+ where子句和order by子句满足最左前缀原则，但where子句使用了范围查询（>、<、in等）

  ```mysql
  mysql> explain select id from person where age > 10 order by name \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: index
  possible_keys: age_name
            key: age_name
        key_len: 773
            ref: NULL
           rows: 9
       filtered: 100.00
          Extra: Using where; Using index; Using filesort
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

+ 使用了不同的索引（order by涉及了两个索引），MySQL每次只采用一个索引

  ```mysql
  mysql> drop index age_name on person;
  Query OK, 0 rows affected (0.01 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  
  mysql> create index age_1 on person(age);
  Query OK, 0 rows affected (0.03 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  
  mysql> create index name_1 on person(name);
  Query OK, 0 rows affected (0.01 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  
  mysql> explain select id from person order by age,name \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 9
       filtered: 100.00
          Extra: Using filesort
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

+ where子句与order by子句使用了不同的索引

  ```mysql
  mysql> explain select id from person where name = 'zhangsan' order by age \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: ref
  possible_keys: name_1
            key: name_1
        key_len: 768
            ref: const
           rows: 3
       filtered: 100.00
          Extra: Using index condition; Using filesort
  1 row in set, 1 warning (0.01 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain select id from person order by age \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: index
  possible_keys: NULL
            key: age_1
        key_len: 5
            ref: NULL
           rows: 9
       filtered: 100.00
          Extra: Using index
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

+ where子句或order by子句中索引列使用了表达式（包括函数表达式）

  ```mysql
  mysql> explain select id from person order by abs(age) \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: index
  possible_keys: NULL
            key: age_1
        key_len: 5
            ref: NULL
           rows: 9
       filtered: 100.00
          Extra: Using index; Using filesort
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

### 查询优化

执行的SQL语句很多，具体该优化哪一个呢？这就依赖于慢查询日志。

#### 慢查询定位

**开启慢查询日志**

查看慢查询日志是否开启和慢查询日志文件的存储位置命令：show variables like 'slow_query_log%';

开启慢查询日志命令：

```
set global slow_query_log=ON;
#set global slow_query_log_file='oshacker-slow.log';
#set global log_queries_not_using_indexes=ON;
#set long_query_time=10;
```

+ Long_queries_not_using_indexs：记录没有使用索引的查询SQL（前提是slow_query_log=ON，否则不生效）。
+ long_query_time：指定慢查询的阈值（单位秒）。如果SQL执行时间超过阈值，就属于慢查询，该SQL就会被记录到日志文件中。

**查看慢查询日志**

为了方便实验，将long_query_time设置为0.1s，然后造大量数据如下：

```mysql
create table slow (
	id int primary key auto_increment,
  name varchar(20)) engine=innodb charset=utf8;
)

insert into slow(name) values('java');
insert into slow(name) values('bigdata');
insert into slow(name) values('python');
insert into slow(name) values('algorithym');
insert into slow(name) select name from slow; // 插入4条
insert into slow(name) select name from slow; // 插入8条
insert into slow(name) select name from slow; // 插入16条
# ...
insert into slow(name) select name from slow; // 插入131072条

select * from slow where name='java';
```

文本方式查看

```log
# Time: 2022-02-17T12:05:54.521207Z
# User@Host: root[root] @ localhost []  Id:     7
# Query_time: 0.911155  Lock_time: 0.000246 Rows_sent: 65536  Rows_examined: 262144
SET timestamp=1645099554;
select * from slow where name='java';
```

+ Time：写入日志的时间
+ User@Host：执行的用户及主机
+ Query_time：执行的时间
+ Lock_time：锁表时间
+ Rows_sent：发送给请求放的记录数（查询结果数量）
+ Row_examined：语句扫描的记录条数
+ SET timestamp：语句执行的时间点
+ Select * ：执行的具体SQL语句

使用慢查询日志分析工具mysqldumpslow查看

> 需要先安装perl环境，然后在MySQL的bin目录下执行perl mysqldumslow --help看如何使用。然后通过以下命令查看慢查询日志信息：mysqldumpslow -a -t 3 -s at xxx/ubuntu-slow.log

除了使用mysqldumpslow工具，还可以使用第三方分析工具，如pt-query-digest、mysqlsla等。

#### 慢查询优化

问题：为什么SQL语句使用了索引但依然是慢查询？使用了索引是否一定快？

**索引和慢查询**

+ MySQL判断一条SQL语句是否为慢查询：主要依据SQL语句的执行时间，如果当前语句的执行时间 > long_query_time（默认为10s，可根据业务需要进行调整），就会把这条SQL记录到慢查询日志中。

+ 判断SQL语句是否应用了索引：根据SQL语句执行过程中有没有用到表的索引，具体可通过explain分析，看key是否为NULL。

+ 应用了索引是否一定快？

  ```mysql
  mysql> explain select * from person \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: ALL
  possible_keys: NULL
            key: NULL
        key_len: NULL
            ref: NULL
           rows: 9
       filtered: 100.00
          Extra: NULL
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain select * from person where id>0 \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: range
  possible_keys: PRIMARY
            key: PRIMARY
        key_len: 4
            ref: NULL
           rows: 9
       filtered: 100.00
          Extra: Using where
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  
  mysql> explain select * from person where id=1 \G;
  *************************** 1. row ***************************
             id: 1
    select_type: SIMPLE
          table: person
     partitions: NULL
           type: const
  possible_keys: PRIMARY
            key: PRIMARY
        key_len: 4
            ref: const
           rows: 1
       filtered: 100.00
          Extra: NULL
  1 row in set, 1 warning (0.00 sec)
  
  ERROR: 
  No query specified
  ```

  从上面SQL的explain结果可知，第二个SQL语句使用了索引，但还是从主键索引的最左边的叶子节点向右扫描整个索引树，进行了全表扫描，此时索引失去了意义。第三个SQL语句使用了索引且只扫描一条记录，这样使用的索引才加快了查询效率。

> 总结：
>
> 1. 查询语句是否使用了索引，只是表示一个SQL语句的执行过程，而是否为慢查询由它执行的时间决定，即两者之间没有必然的联系。
> 2. 使用索引时，不要只关注是否起作用，应该关心索引是否减少了查询扫描的数据行数，扫描行数减少了，效率才会得到提升。对于一个大表，不仅要创建索引，还要考虑提升索引过滤性，过滤性好执行速度才会快。

**提高索引过滤性**

假如一个5000万记录的用户表，通过sex='男'索引过滤后可能还有3000万，而针对3000万的查询，SQL执行速度也不会很快；与之相比，使用id过滤可能只剩很少，这个问题就涉及到索引的过滤性，索引过滤性与索引字段、表的数据量、表设计都有关系。

```mysql
mysql> insert into student(name,sex,age) values('zhangsan','M',18);
Query OK, 1 row affected (0.01 sec)

mysql> insert into student(name,sex,age) values('zhangsanfeng','M',18);
Query OK, 1 row affected (0.01 sec)

mysql> insert into student(name,sex,age) values('lisi','M',18);
Query OK, 1 row affected (0.00 sec)

mysql> insert into student(name,sex,age) values('wangwu','M',19);
Query OK, 1 row affected (0.01 sec)

mysql> insert into student(name,sex,age) values('zhaoliu','F',19);
Query OK, 1 row affected (0.00 sec)

mysql> insert into student(name,sex,age) select name,sex,age from student;
Query OK, 5 rows affected (0.01 sec)
Records: 5  Duplicates: 0  Warnings: 0

mysql> insert into student(name,sex,age) select name,sex,age from student;
Query OK, 10 rows affected (0.01 sec)
Records: 10  Duplicates: 0  Warnings: 0

# ...

mysql> insert into student(name,sex,age) select name,sex,age from student;
Query OK, 2560 rows affected (0.19 sec)
Records: 2560  Duplicates: 0  Warnings: 0

mysql> select count(*) from student;
+----------+
| count(*) |
+----------+
|     5120 |
+----------+
1 row in set (0.01 sec)

mysql> select count(*) from student where age=18 and name like 'zhang%';
+----------+
| count(*) |
+----------+
|     2048 |
+----------+
1 row in set (0.02 sec)

mysql> select count(*) from student where age=18;
+----------+
| count(*) |
+----------+
|     3072 |
+----------+
1 row in set (0.02 sec)

mysql> explain select * from student where age=18 and name like 'zhang%' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: student
   partitions: NULL
         type: ALL
possible_keys: NULL
          key: NULL
      key_len: NULL
          ref: NULL
         rows: 5120
     filtered: 1.11
        Extra: Using where
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified

# 优化一：分别创建age_1、age_name索引，对查询进行优化

# 只有索引age_1
mysql> create index age_1 on student(age);
Query OK, 0 rows affected (0.07 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select * from student where age=18 and name like 'zhang%' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: student
   partitions: NULL
         type: ref
possible_keys: age_1
          key: age_1
      key_len: 5
          ref: const
         rows: 3072
     filtered: 11.11
        Extra: Using where
1 row in set, 1 warning (0.00 sec)

ERROR: 
No query specified

# 从key为age_1和rows结果为3072可知，SQL的执行过程为：根据age_1索引树过滤出age=18的3072个主键值，然后再回表查询其对应记录，最后取出select需要的字段值。

# 只有组合索引age_name（删除age_1索引，排除其干扰）
mysql> drop index age_1 on student;
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> create index age_name on student(age,name);
Query OK, 0 rows affected (0.09 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> explain select * from student where age=18 and name like 'zhang%' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: student
   partitions: NULL
         type: range
possible_keys: age_name
          key: age_name
      key_len: 68
          ref: NULL
         rows: 2048
     filtered: 100.00
        Extra: Using index condition
1 row in set, 1 warning (0.01 sec)

ERROR: 
No query specified

# 从rows为2048可知，查询效率更高了，这是因为Using index condition的缘故，即基于age_name索引进行了age和name的过滤。至此，index condition pushdown(索引下推)的优化效果已经不错了。

# 优化二：再进一步优化，使用MySQL 5.7引入的虚拟列来实现，把名字的第一个字和年龄组成联合索引。
mysql> drop index age_name on student;
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> alter table student add first_name varchar(5) generated always as (left(name,5));
Query OK, 0 rows affected (0.04 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> alter table student add index age_firstName(age,first_name);
Query OK, 0 rows affected (0.10 sec)
Records: 0  Duplicates: 0  Warnings: 0

# 添加虚拟列后，要查询的SQL可以修改为下面的SQL
mysql> explain select * from student where age=18 and first_name = 'zhang' \G;
*************************** 1. row ***************************
           id: 1
  select_type: SIMPLE
        table: student
   partitions: NULL
         type: ref
possible_keys: age_firstName
          key: age_firstName
      key_len: 23
          ref: const,const
         rows: 2048
     filtered: 100.00
        Extra: NULL
1 row in set, 1 warning (0.01 sec)

ERROR: 
No query specified

# type由range变为了ref，查询效率变高。但rows都是2048，老师解释说前者回表的次数比后者多，这里我搞不懂！
```

**慢查询原因总结**

1. 全表扫描：explain分析type属性为all；
2. 全索引扫描（变相的全表扫描）：explain分析type属性为index；
3. 索引过滤性不好：考虑索引字段选择、数据量和状态（sex全是男）、表设计（虚拟列）；
4. 频繁的回表查询：尽量少用select *，多使用覆盖索引。

#### 分页查询优化

**一般性分页**

一般的分页查询使用简单的limit子句实现，具体为：

```sql
SELECT * FROM 表名 LIMIT [offset], rows;
```

+ offset：第一个返回记录行的偏移量，从0开始；
+ rows：返回记录行的最大数目；
+ 如果只给一个参数，它表示返回的最大记录行数。 

> 思考1：如果偏移量固定，返回记录量对执行时间有什么影响？

```mysql
# 将student表中的数据最终添加到4万多条，然后执行下面的查询语句
mysql> insert into student (name,sex,age) select name,sex,age from student;
Query OK, 20480 rows affected (1.94 sec)
Records: 20480  Duplicates: 0  Warnings: 0

# 为了查看SQL执行时间，需要查看是否profiling开启（如未开启需要先开启后再执行SQL）：
mysql> show variables like 'profiling';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| profiling     | OFF   |
+---------------+-------+
1 row in set (0.01 sec)

mysql> set profiling=on;
Query OK, 0 rows affected, 1 warning (0.00 sec)

select * from student limit 10000,1;
select * from student limit 10000,10;
select * from student limit 10000,100;
select * from student limit 10000,1000;
select * from student limit 10000,10000;

mysql> show profiles;
+----------+------------+---------------------------------------------------------------------+
| Query_ID | Duration   | Query                                                               |
+----------+------------+---------------------------------------------------------------------+
|        #...                                                                                 |
|        5 | 0.05369650 | select * from student limit 10000,1                                 |
|        6 | 0.05674800 | select * from student limit 10000,10                                |
|        7 | 0.05763475 | select * from student limit 10000,100                               |
|        8 | 0.06127900 | select * from student limit 10000,1000                              |
|        9 | 0.11717450 | select * from student limit 10000,10000                             |
+----------+------------+---------------------------------------------------------------------+
9 rows in set, 1 warning (0.00 sec)
```

思考1结论：查询时返回的记录数少于100条时，查询时间基本没有变化，差距不大；随着查询记录数越大，所花费的时间也会越来越多。

> 思考2：如果查询偏移量变化，返回记录量数固定对执行时间有什么影响？

```mysql
select * from student limit 1,100;
select * from student limit 10,100;
select * from student limit 100,100;
select * from student limit 1000,100;
select * from student limit 10000,100;

mysql> show profiles;
+----------+------------+---------------------------------------------------------------------+
| Query_ID | Duration   | Query                                                               |
+----------+------------+---------------------------------------------------------------------+
|       # ...                                                                                 |
|       10 | 0.00197075 | select * from student limit 1,100                                   |
|       11 | 0.00182475 | select * from student limit 10,100                                  |
|       12 | 0.00277350 | select * from student limit 100,100                                 |
|       13 | 0.00760950 | select * from student limit 1000,100                                |
|       14 | 0.05798800 | select * from student limit 10000,100                               |
+----------+------------+---------------------------------------------------------------------+
14 rows in set, 1 warning (0.00 sec)

```

思考2结论：查询时，如果查询记录数相同，偏移量超过100后随着偏移量增大，查询时间急剧增加。

> 上面两个结论的原因是这种分页查询机制每次都会从数据库第一条记录开始扫描，越往后查询越慢，而且查询的数据越多，也会拖慢总查询速度。

**分页优化方案**

利用覆盖索引

```mysql
select * from student limit 10000,100; # 优化前 0.05798800
select id form student limit 10000,100; # 优化后 0.04083175
```

如果需要*列数据，那么就利用子查询优化（子查询利用覆盖索引拿到第10000条记录id，然后通过主键id取100条）

```mysql
select * from student where id >= (select id from student limit 10000,1) limit 100; // 优化后 0.

# 如果id不是连续的，那么无法知道第10000条记录的id，因此使用子查询拿到第10000条记录的id。
```

## MySQL事务和锁

### ACID特性

在关系型数据库中，一个逻辑工作单元要成为事务，必须满足ACID四个特性：原子性（Atomicity)、一致性（Consistency）、隔离型（Isolation）和持久性（Durability）。

#### 原子性

原子性指事物是一个原子操作单元，其对数据的修改，要么全部执行，要么全部不执行。

写操作时，先修改Buffer Pool中的数据页，然后将修改后的脏页刷新到磁盘文件。但在这个过程中可能存在两种意外情况：

+ 事务提交了（修改了Buffer Pool中的数据），但Buffer Pool的脏页没有刷到磁盘，那么该如何保证修改的数据生效呢？Redo
+ 事务没提交，但是Buffer Pool中的脏页刷盘了，那么如何保证不该存在的数据撤销？Undo

具体地讲，每个写事务都会修改Buffer Pool，从而产生相应地Redo/Undo日志，在Buffer Pool中的页被刷新到磁盘前，这些日志信息都会先写入到日志文件中。如果事务提交了，Buffer Pool中的脏页没有刷盘成功，此时数据库挂了，那么在数据库再次启动之后，可以通过Redo日志将其恢复出来，以保证脏页写的数据不会丢失；如果事务没提交，脏页刷盘成功，此时数据库挂了，就需要通过Undo日志将其撤销。

#### 隔离性

隔离性指的是一个事务的执行不能被其他事务干扰，即一个事务内部的操作以及使用的数据对其他的并发事务是隔离的。

InnoDB支持的隔离性有4种，从低到高分别是：读未提交、读已提交、可重复读、串行化。锁和多版本并发控制技术（MVCC）就是用于保证隔离性的（后面详细介绍）。

#### 持久性

持久性指一个事务一旦提交，它对数据库中数据的改变应该是永久性的，后续的操作或故障不应该对其有任何影响，不会丢失。

![20220218](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/20220218.png)

如上图所示，事务提交动作触发的操作有：binlog落地（MySQL Server层）、发送binlog（主从架构通过binlog实现数据同步）、存储引擎提交、flush_logs（Log Buffer刷新到磁盘）、check_point（Buffer Pool中的脏页刷新到磁盘）、事务提交标记（标记以用于回滚）等，这些都是数据库保证其完整性、持久性的手段。

此外，MySQL的持久性也与[WAL技术(Write-Ahead Logging，先写日志，再将脏页写到磁盘)](https://www.cnblogs.com/mengxinJ/p/14211427.html)相关，redo log在系统crash时可以修复数据，从而保障事务的持久性。通过原子性可以保证逻辑上的持久性，通过存储引擎的数据刷盘可以保证物理上的持久性。

#### 一致性

一致性指事务开始前和事务结束后，数据库的完整性限制未被破坏。一致性包括两方面：约束一致性和数据一致性。

+ 约束一致性（逻辑上的一致性，属于业务逻辑范畴）：创建表结构时指定的外键、Check、唯一索引等约束，可惜在MySQL中不支持Check。
+ 数据一致性（可以理解为数据的完整性）：它是由原子性、持久性、隔离性共同保证的，而这3个特性又是通过Redo/Undo来保证的。

ACID及它们之间的关系如上图所示，4个特性中有3个与WAL有关系，都需要通过Redo/Undo日志来保证。

![20220220](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/20220220.png)

### 事务控制的演进

#### 并发事务

事务并发处理可能会带来一些问题，比如更新丢失、脏读、不可重复读、幻读等。

更新丢失指两个或多个事务更新同一行记录，会产生更新丢失现象。它可以分为两种：

+ 回滚覆盖：一个事务回滚操作，把其他事务已提交的数据给覆盖了。
+ 提交覆盖：一个事务提交操作，把其他事务已提交的数据给覆盖了。

脏读：一个事务读取到了另一个事务修改但未提交的数据。

不可重复读：一个事务中多次读取同一行记录，后面读取的和前面读取的不一致。

幻读：一个事务中多次按相同条件查询，后面查询的结果和前面查询的结果不同，多了或少了几行记录。

接下来，就是如何避免这些问题且提高系统的并发性能，因此要对事务进行控制。

#### 排队

最简单（严格）的方法就是完全顺序执行所有的事务单元，事务内部的操作也顺序执行，这样数据库某个时刻只处理一个事务的一个操作，不需要加锁，即全局排队。特点是强一致性，处理性能低。

![2022022001](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022022001.png)

#### 排他锁

锁是计算机协调多个进程或线程并发访问资源的一种机制，锁采用独占资源方式保证在只有一个版本的情况下事务之间的互相隔离，可以理解为单版本并发控制。

引入锁之后就可以支持并发处理事务，如果事务之间涉及到相同的数据项，会使用排它锁（互斥锁），先进入的事务独占数据项，其他事务被阻塞，等待前面的事务释放锁。

![2022022002](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022022002.png)

整个事务1结束前，锁是不会释放的，所以事务2必须等到事务1结束之后开始。

#### 读写锁

使用了排他锁后，并发处理能力已经得到了提升，我们对数据库的操作无非就是读和写操作（读读、写写、读写、写读），为了进一步提升，研究出了读写锁。

读写锁就是进一步细化锁的颗粒度，把读操作和写操作区分开，让读和读之间不加锁，这样下面的两个事务就可以同时被执行了。

![2022022003](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022022003.png)

读写锁可以让读和读并行，而读和写、写和读、写和写这几种之间还是要加排它锁，不能并行。

#### MVCC

MVCC也是Copy on Write的思想，它除了支持读和读并行，还支持读和写、写和读的并行，但为了保证一致性，写和写是无法并行的。

![2022022004](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022022004.png)

事务1开始写操作时会copy一个记录的副本，其他事务读操作会读取这个记录副本，因此不会影响其他事务对此记录的读取，实现写和读并行。

**MVCC概念**

多版本并发控制（Multi Version Concurrency Control，MVCC）指在数据库中为了实现高并发的数据访问，对数据进行多版本处理，并通过事务的可见性保证事务能看到自己应该看到的数据版本。多版本并发控制巧妙地将稀缺资源的独占互斥转换为并发，大大提高了数据库的吞吐量及读写性能。

> 多版本生成：每次事务修改操作前，都会在Undo日志中记录修改之前的数据状态和事务号，该备份记录可以用于其他事务的读取，也可以进行必要时的数据回滚。

**MVCC实现原理**

InnoDB引擎就是采用MVCC而非锁进行并发控制的，MVCC最大的好处是读不加锁，读写不冲突。在读多写少的系统应用中，读写不冲突是非常重要的，极大的提升系统的并发性能，所以现阶段几乎所有的关系型数据库都支持MVCC，但目前MVCC只在Read Commited和Repeatable Read两种隔离级别下工作。

在MVCC并发控制中，读操作可以分为两类：

+ 快照读（Snapshot Read）：读取的是记录的快照版本（可能是历史版本），不用加锁。（select)
+ 当前读（Current Read）：读取的是记录的最新版本，且当前读返回的记录都会加锁，以保证其他事务不会再并发修改这条记录。（select... for update或lock in share mode，insert/delete/update）

> 疑问：[RC和RR隔离级别下都有快照读，区别是啥？](https://juejin.cn/post/6941253684537851912)

如下图所示，F1-F6是表中的字段名，1-6是其对应的数据，后面三个隐含字段分别对应行的隐含ID、事务号和回滚指针。这三个隐含字段都是InnoDB引擎自动创建的，其中：

+ 隐含ID是InnoDB自动产生聚集索引时生成的；
+ 事务ID表示最新更新该记录的事务ID号，每当一个事务处理该记录，事务ID就会自动加一；
+ 回滚指针指向当前记录的Rollback回滚段，该指针指向之前的哪个版本就可以回滚到哪种数据状态。

![20220221](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/20220221.png)

下面通过记录更新过程理解MVCC中多版本的实现：

1. 如下图所示，假如一条数据是刚INSERT的，DB_ROW_ID为1，其他两个字段为NULL。

   ![image-20220221151554561](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220221151554561.png)

2. 如下图所示，事务1更改该行的数据值时会进行如下操作：

   + 用排他锁锁定该行，记录Redo Log；
   + 把该行记录修改前的值复制到Undo Log（下图中下面的一行）；
   + 修改当前行记录的值，填写事务编号并让回滚指针指向Undo Log中修改前的行。

   ![2022022101](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022022101.png)

3. 接下来，事务2操作与事务1相同，此时Undo Log中会有两行记录，如下图所示，并且通过回滚指针连在一起，通过当前记录的回滚指针回溯到该行记录创建时的初始内容。

   ![image-20220221152334958](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220221152334958.png)

   > Undo Log不会无限增大，purge thread会清除比较老的记录，具体参考InnoDB线程模型。

#### 乐观锁、悲观锁

MVCC已经实现了读读、读写、写读并发处理，如果想进一步解决写写冲突，可以采取的方案有两种：乐观锁和悲观锁。

### 事务隔离级别

隔离级别是针对支持事务的InnoDB引擎，MyISAM引擎不支持事务。

#### 隔离级别类型

前面提到的“丢失更新”、“脏读”、“不可重复读“和”幻读“等并发事务问题，其实都是数据一致性问题。为了解决这些问题，MySQL是通过事务隔离级别来解决的，数据库系统提供了以下4种事务隔离级别供用户选择。

+ 读未提交（Read Uncommited）：解决了回滚覆盖类型的丢失更新，但可能会发生脏读现象（可能读取到其他会话中未提交事务修改的数据）。
+ 读已提交（Read Commited）：只能读取到其他会话中已提交的数据，解决了脏读问题。但可能发生不可重复读现象（可能在一个事务中两次查询结果不一致）。
+ 可重复读（Repeatable Read）：它确保同一事务中多次读取数据时，会看到同样的数据行，即解决了不可重复读问题。但理论上会出现幻读现象（当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据时发现有新的幻影行）。
+ 串行化（Serializable）：所有的增删改查串行执行。它通过强制事务排序来解决相互冲突，从而解决幻读问题。但这个级别可能导致大量的超时现象和锁竞争，效率低下。

事务隔离级别与可能存在的并发事务问题总结如下：

![image-20220221204842057](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220221204842057.png)

数据库的事务隔离级别越高，并发问题就越少，但并发处理能力越差（代价）。因此，使用时可以根据系统特点选择一个合适的隔离级别，比如对不可重复读和幻读并不敏感，更关心数据库并发处理能力，此时可以使用Read Commited隔离级别。

MySQL默认的隔离级别是Repetable Read（Oracle、SQL Server默认隔离级别为Read Commited），查看/设置当前数据库事务隔离级别命令为：

```mysql
show variables like 'tx_isolation';
select @@tx_isolation;

# 全局设置加global，注意全局设置后，当前会话不会立刻生效，新打开的会生效
set tx_isolation='READ-UNCOMMITTED';
set tx_isolation='READ-COMMITTED';
set tx_isolation='REPEATABLE-READ';
set tx_isolation='SERIALIZATION';
```

#### 事务隔离级别与锁的关系

事务隔离级别是SQL92定制的标准，相当于事务并发控制的整体解决方案，本质上是对锁和MVCC使用的封装，隐藏了底层细节（加锁细节、MVCC使用的细节）。

锁是数据库实现事务并发控制的基础，事务隔离性是采用锁实现的，即对相应操作加不同的锁，就可以防止其他事务同时对数据进行读写操作。

> 两个事务可以同时读数据，数据库底层可以使用读写锁实现；一个事务写时，另一个事务可以读，数据库底层可以使用MVCC实现；两个事务同时写可能存在问题（丢失更新、脏读、不可重复读、幻读），数据库底层可以通过排他锁实现。

对用户来讲，首先选择使用隔离级别，当选用的隔离级别不能解决并发问题或需求时，才有必须要在开发中手动设置锁（实际中一般不使用串行化，这样即使使用可重复读，也可能会存在幻读的问题，因此就需要手动设置悲观锁或乐观锁）。

> Read-Uncommitted隔离级别，读操作不加S锁，写操作修改完数据就立马释放了锁（此时还没有提交事务，但其他事务可以读）
>
> Read-Committed隔离级别，数据的读取不加S锁，写操作（增删改）在修改完数据且事务提交后才释放锁；（不提交也可以读是因为MVCC多版本并发控制的存在（快照读），即MySQL为了提高系统的并发量，在事务未提交前，虽然事务内操作的数据是锁定状态，但是两一个事务仍然可以读取）
>
> Repeatable-read隔离级别，通过MVCC机制让数据变得可重复读（读到历史数据，快照读，即MySQL第一次读的时候会读最新提交事务的数据，之后再读时，mysql会取第一次读取的数据作为结果。这样就保证了同一个事务多次读取时数据的一致性），不需要加锁，但对于特殊的读（增删改）操作（读到的都是当前的数据，当前读），需要加锁。实际上，事务的隔离级别定义的是当前读的级别，MySQL为了减少锁处理的时间，提升并发能力，引入了快照读的概念。
>
> Serializable隔离级别，读加读锁，写加写锁，读写互斥。

关于事务隔离级别与锁的关系更多请参考：

（推荐）https://segmentfault.com/a/1190000038942146

（后面再读）https://tech.meituan.com/2014/08/20/innodb-lock.html

#### 事务隔离级别案例

1. 读未提交

   client1和client2同时开始事务，同时进行查询，没有问题，表明读不加锁。

   ![image-20220225182927323](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220225182927323.png)

   此时不结束事务，client1将id=1的score值增加5，然后client2去查询，发现在client2查询到了client1未提交事务时修改后的值，体现了读未提交，即存在**脏读**问题。正因为脏读的存在，从client2可知同一事务中两次读取的数据不一致，即存在**不可重复读**的问题。

   ![image-20220225184200726](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220225184200726.png)

   然后，client2也修改该行的值，由于client1未释放该行锁，所以client2刚开始等待，最终超时失败。

   ![2022022501](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022022501.png)

   然后，client2再次输入修改指令并等待，同时client1输入事务提交指令，发现client2的update立即成功了。

   ![image-20220225185900972](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220225185900972.png)

   小结：在读未提交的隔离级别下，两个事务同时读没有问题，且一个事务可以看到另一个事务没有提交的修改（脏读）。如果两个事务同时修改一行记录的某个值，先发生的可以执行，后发生的只能等先发生的事务提交释放锁后才能获取锁并需改该值。

   为了验证幻读的存在，将client2的事务提交。然后重新开启两个事务，先同时进行查询，然后在client1中插入一条记录且不提交事务，在client2中查询发现多了一条记录，即从client2可知同一事务中两次相同条件查询，记录多了，说明存在**幻读**问题。

   ![image-20220226202440361](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220226202440361.png)

   为了验证不存在回滚覆盖，先将client1和client2两个事务都提交，然后重新开启两个事务，先同时进行查询，然后在client1将id=1的值增加1后提交，最后在client2中执行rollback后查询id=1的记录，发现client2的事务回滚并不会撤销client1已经提交的事务，即**不存在回滚覆盖**问题。

   ![image-20220226224614668](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220226224614668.png)

   最后为了验证提交覆盖的存在，重新开启两个事务，先同时进行查询，然后在client1将id=1的值增加2，紧接着在client2将id=1的值也增加2，发现client2会等待，此时将client的事务提交，发现client2更新成功，最后将client2的事务提交后，查询client中id=1的记录发现多了2，即后面事务的提交覆盖了前面已经提交的事务。

   ![2022022601](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022022601.png)

2. 读已提交

   client1和client2同时开始事务，同时进行读没有问题，表明读不加锁。client1将id=1的score加1，然后在client2中查询id=1行的s core值，发现读取到的是旧值（不存在**脏读**的问题），这是MVCC多版本控制的结果。

   ![image-20220301202523794](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220301202523794.png)

   接上面，如果client2也将id=1的score值加1（client1的事务未提交），发现会先等待，最后超时报错。但client2可以成功将id=2的score增加1，这时如果client1也尝试将id=2的score增加1，同样也会先等待，然后超时报错。

   最后，先将client1的事务提交，然后在client2中查询id=1的值，发现score的值为95，与上一次查询的94不同，同一事务两次查询结果不一致，即存在**不可重复读**的问题。

   ![2022030101](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022030101.png)

   最后为了验证幻读的存在，重新开启两个事务，先同时进行查询，然后在client1中插入一行记录并提交，然后在client2中查询发现第二次查询的结果比第一次查询的结果多了id=5行（事务未提交），同一事务中两次查询的数据多了，即存在**幻读**问题。

   ![2022030102](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022030102.png)

3. 可重复读

   client1和client2同时开始事务，同时进行读没有问题，然后client1对id=1增加2并提交事务，在client2查询id=1的score，发现两次查询的结果一致，即可重复读。

   ![image-20220301222022799](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220301222022799.png)

   为了验证幻读的存在，重新开启两个事务，先同时进行查询，然后在client1中插入一行记录并提交，在client2中查询发现并没有多一行记录，这似乎与我们已知的存在幻读的结论相矛盾（RR引入间隙锁部分解决了幻读问题，在某些情况下幻读还是会出现，原因后面再查资料探究）。

   ![image-20220301222737912](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220301222737912.png)

   值得注意的是，我们前面的结论是RR隔离级别下幻读可能会发生，如果在client2中再更新client1中插入的那条记录，然后在client2中再次查询就会发现多了一条记录，即发生了**幻读**。

   ![image-20220301223502689](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220301223502689.png)

4. 串行化

   client1和client2同时开始事务，同时进行读没有问题，然后client1对id=1增加2发现阻塞了，即client1的读会阻塞client2的写（client1的写也会阻塞client2的读）。也就是说，只要涉及到写操作，事务A和事务B必须顺序执行。

### 锁机制和实战

#### 锁分类

MySQL中锁从操作的粒度可以分为：

+ 表级锁：每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用于MyISAM、InnoDB、BDB等存储引擎中。
+ 行级锁：每次操作锁住一行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在InnoDB存储引擎中。
+ 页级锁：每次锁定相邻的一组记录，锁定粒度介于表锁和行锁之间，开销和加锁时间介于表锁和行锁之间，并发度一般。应用于BDB引擎中。

从操作的类型可以分为：

+ 读锁（S锁）：共享锁，针对同一份数据，多个读操作可以同时进行，而不会互相影响（事务A对记录添加了S锁，就对记录进行读操作，但不能做修改；其他事务可以对该记录追加S锁，但是不能追加X锁，如果想追加X锁，需要等记录的S锁全部释放）；
+ 写锁（X锁）：排他锁，当前写操作没有完成前，它会阻断其他的写锁和读锁（事务A对记录添加了X锁，可以对记录进行读和写操作，其他事务不能对记录做读和写操作）。

> IS锁、IX锁：意向读锁、意向写锁，属于表级锁；
>
> S锁、X锁主要针对行级锁，注意：在对表记录添加S或X锁之前，会先对表添加IS或IX锁，便于其他事务粗略判断表中的记录是否加锁，没有IS或IX说明表中的记录都没有加锁，否则记录可能加锁。

从操作的性能可分为：

+ 乐观锁：一般的实现方式是比对记录数据版本，在数据更新提交时才会进行冲突检测，如果发现冲突了，则提示错误信息。

+ 悲观锁：在对一条数据修改时，为了避免同时被其他人修改，在修改数据之前先锁定、再修改的控制方式。

  >  共享锁和排他锁是悲观锁的不同实现，但都属于悲观锁范畴。

#### 行锁原理

在InnoDB引擎中，我们可以使用表锁和行锁，其中行锁又分为共享锁和排它锁。**InnoDB行锁是通过对索引数据页上的记录加锁实现**，行锁的主要实现算法有三种：

+ Record Lock：记录锁，锁定单个行记录的锁。（RC、RR隔离级别都支持）
+ Gap Lock：间隙锁（范围锁），锁定索引记录的间隙，确保索引记录的间隙不变。（RR隔离级别支持）
+ Next-Key Lock：记录锁和间隙锁组合，同时锁住数据和数据前后的范围。（RR隔离级别支持）

在RR隔离级别中，InnoDB对于记录的加锁行为是先采用Next-Key Lock，当SQL操作含有唯一索引时，InnoDB会对Next-Key Lock进行优化，降级为Record Lock，仅锁住索引本身而非范围。

> 下面列举不同SQL的加锁行为：
>
> 1. select ... from 语句：InnoDB引擎采用MVCC机制实现非阻塞读（我的理解是快照读），所以对于普通的select语句，InnoDB不加锁；
> 2. select ... from lock in share mode语句：追加了共享锁，InnoDB会使用Next-Key Lock进行处理，如果扫描发现唯一索引，可以降级为Record Lock。
> 3. select ... from for update语句：追加了排他锁，InnoDB会使用Next-Key Lock进行处理，如果扫描发现唯一索引，可以降级为Record Lock。
> 4. update ... where语句：InnoDB会使用Next-Key Lock进行处理，如果扫描发现唯一索引，可以降级为Record Lock。
> 5. delete ... where语句：InnoDB会使用Next-Key Lock进行处理，如果扫描发现唯一索引，可以降级为Record Lock。
> 6. insert语句：InnoDB会给待插入行设置一个排他的Record Lock。

下面用示例演示Next-Key Lock的存在和特点：

```mysql
# 创建t1表，其中id不能为主键，因为主键存在唯一性，如果执行select ... from for update，会导致Next-Key Lock降级为Record Lock。
mysql> create table t1(
    -> id int,
    -> name varchar(20)) engine=innodb charset=utf8;
Query OK, 0 rows affected (0.01 sec)

mysql> create index index_id on t1(id);
Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0

mysql> insert into t1 values(1,'a');
Query OK, 1 row affected (0.01 sec)

mysql> insert into t1 values(3,'c');
Query OK, 1 row affected (0.01 sec)

mysql> insert into t1 values(5,'e');
Query OK, 1 row affected (0.00 sec)

mysql> insert into t1 values(7,'g');
Query OK, 1 row affected (0.00 sec)

mysql> select * from t1;
+------+------+
| id   | name |
+------+------+
|    1 | a    |
|    3 | c    |
|    5 | e    |
|    7 | g    |
+------+------+
4 rows in set (0.00 sec)

# 接下来，会话1开启事务，然后执行select ... from for update语句
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from t1 where id=5 for update;
+------+------+
| id   | name |
+------+------+
|    5 | e    |
+------+------+
1 row in set (0.01 sec)

# 此时，MySQL该行记录添加了排他锁，InnoDB使用Next-Key Lock锁定了该行数据及其前后的范围（因为没有唯一性索引，因此不会降级为Record Lock）

# 接下来，在另外一个会话开启一个新的事务，
mysql> begin;
Query OK, 0 rows affected (0.00 sec)

mysql> select * from t1 where id=5; # 既然第一个事务已经加了排他锁，为啥这里还可以读呢？我的理解是快照读
+------+------+
| id   | name |
+------+------+
|    5 | e    |
+------+------+
1 row in set (0.00 sec)

mysql> select * from t1 where id=5 for update; # 这里我的理解是当前读
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
mysql> 
mysql> insert into t1 values(2,'b'); # 非间隙锁的锁定范围可以插入数据
Query OK, 1 row affected (0.00 sec)

mysql> insert into t1 values(4,'d'); # 间隙锁的锁定范围不可以插入
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
mysql> 
mysql> insert into t1 values(6,'f'); # 同样是间隙锁的锁定范围
ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
mysql> 
mysql> insert into t1 values(8,'h'); # 非间隙锁的锁定范围
Query OK, 1 row affected (0.00 sec)

```

下面以“update t1 set name='xx' where id=10”为例，分析InnoDB对不同索引的加锁行为（InnoDB的行锁是基于索引记录进行加锁的），以RR隔离级别为例。

+ 主键加锁：前面提到update语句中会加Next-Key Lock锁，但由于id为主键（唯一索引），因此会降级为Record Lock锁，即仅在id=10的主键索引记录上加X锁。

  ![2022022302](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022022302.png)

+ 唯一键加锁：因为id为唯一索引，name为主键索引，因此两者都会降级为Record Lock锁，因此先在唯一索引id=10上加X锁，然后在id=10的主键索引记录上加X锁。

  ![2022022303](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022022303.png)

+ 非唯一键加锁：因为id添加了普通索引，所以update语句会对id=10加Next-Key Lock(锁定记录和间隙），而name添加了主键索引，会降级为Record Lock。也就是说，对满足id=10的索引记录和主键分别加X锁，然后在(6,c)-(10,b)、(10,b)-(10,d)、(10,d)-(11,f)范围分别加Gap Lock。

  ![2022022304](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022022304.png)

+ 无索引加锁：表里所有记录都会加X锁，所有间隙都会加Gap Lock。（当没有索引时，会导致全表锁定，因为InnoDB引擎的锁机制是基于索引实现的记录锁定，说白了就是没有索引树就全表都锁了）

  ![2022022701](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022022701.png)

  为了使用上面创建的t1表验证该结论，先把两个事务都rollback，接下来的操作如下：

  ```mysql
  # 删除掉id上的索引index_id
  mysql> drop index index_id on t1;
  Query OK, 0 rows affected (0.01 sec)
  Records: 0  Duplicates: 0  Warnings: 0
  
  mysql> show index from t1;
  Empty set (0.00 sec)
  
  # 开启新的事务，然后执行select ... from for update语句
  mysql> begin;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> select * from t1 where id=5 for update;
  +------+------+
  | id   | name |
  +------+------+
  |    5 | e    |
  +------+------+
  1 row in set (0.00 sec)
  
  # 再开启一个新的事务，然后执行任何更新/插入语句，发现都报错
  mysql> begin;
  Query OK, 0 rows affected (0.00 sec)
  
  mysql> insert into t1 values(2,'b');
  ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction
  mysql> 
  
  ```

#### 悲观锁

悲观锁指在数据处理过程中，将数据处于锁定状态，一般使用数据库的锁机制实现，从广义上说，读锁、写锁、共享锁、排它锁、表级锁、行级锁等都属于悲观锁范畴。

1. 表级锁：每次操作都锁住整张表，并发度最低。

   ```mysql
   # 手动增加表级锁
   lock table 表名1 read|write, 表名2 read|write;
   # 查看表上加过的锁
   show open tables;
   # 删除表级锁
   unlock tables;
   ```

   + 表级读锁：当前表追加read锁，当前连接（会话）和其他连接都可以进行读操作，但是当前连接进行增删改操作会报错，其他连接进行增删改操作会被阻塞。
   + 表级写锁：当前表追加write锁，当前连接可以对表做增删改查操作，其他连接对该表所有操作都被阻塞（包括查询）。

2. 共享锁（读锁，S锁，属于行级锁）指多个事务对于同一数据可以共享一把锁，都能访问到数据，但只能读不能写（当前事务和其他事务都只能读不能写）。共享锁的使用方法是select    ... lock in share mode，只适用于查询语句。

3. 排他锁（写锁，X锁，属于行级锁）不能与其他锁并存，如一个事务获取了一行数据的排他锁（当前事务可以读和写），其他事务就不能对该行记录进行读和写（被阻塞），也不能获取该行的锁。使用排他锁的方法是在SQL末尾加上for update（InnoDB引擎默认会在update、delete语句加上for update）。

   > 行级锁的实现其实是依靠其对应的索引，如果查询没有用到索引，那么会锁住全表记录及间隙（其他事务的所有操作会被阻塞）。

#### 乐观锁

乐观锁是相对于悲观锁而言的，它不是数据库库提供的功能，需要开发者自己去实现。在进行数据库操作时，乐观地认为这次操作不会导致冲突，因此在数据库操作时并不做任何特殊处理（不会加锁），而是在进行事务提交时再判断是否有冲突（同一条记录是否被多个事务同时修改）。

乐观锁实现的关键点是**冲突的检测**，有如下两种方案：

+ 使用版本字段（version)：先给表增加一个版本字段（version），每操作一次将那条记录的版本号加1。version是用来查看被读的记录有无变化，作用是防止记录在业务处理期间被其他事务修改。

  ![2022022305](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022022305.png)

+ 使用时间戳（timestamp）：与版本字段version类似，同样需要给表增加一个字段，字段类型使用时间戳timestamp。在更新提交时检查当前当前数据库中数据的时间戳和更新前取到的时间戳是否一致，如果一致则提交更新，否则版本冲突(前者时间比后者时间新），取消操作。

下面以下单过程为例，介绍乐观锁的使用

1. 查询商品信息

   ```mysql
   select quantity,version from products where id=1;
   ```

2. 根据商品信息生成订单

   ```mysql
   insert into orders ...
   insert into items ...
   ```

3. 修改商品库存

   ```myssql
   update products set quantity=quantity-1,version=version+1 where id=1 and version=#{version};
   ```

除了自己手动实现乐观锁外，很多数据库访问框架也封装了乐观锁的使用，比如hibernate框架。Mybatis框架大家可以使用OptimisticLocker插件来扩展。

**悲观锁和乐观锁的区别**

两者都可以解决事务写写并发，在使用时可以根据并发处理能力进行选择，对并发率要求高的选择乐观锁，对并发率要求低的可以选择悲观锁。

#### 死锁与解决方案

**常见的死锁现象和解决方案**：

+ 表锁死锁

  + 产生原因：用户A访问表A（锁住了表A），然后又企图访问表B；用户B访问表B（锁住了表B），然后企图访问表A。这时由于用户B已经锁住了表B，用户A必须等待用户B释放表B后才能继续访问，同样用户B要等待用户A释放表A后才能继续访问，这样死锁就产生了。
  + 解决方案：这种死锁比较常见，是由于程序的Bug产生的，除了调整程序的逻辑没有其他的办法。分析程序的逻辑：对于数据库的多表操作时，尽量按照相同的顺序进行处理，尽量避免同时锁定两个资源（我的理解是加A、B两把锁。如果一定要同时锁定两个资源，要保证在任何时刻都按照相同的顺序来锁定资源）。

+ 行级锁死锁

  + 产生原因一：如果一个事务执行了一条没有索引条件的查询，就会引发全表扫描，并把行级锁上升为全表记录锁定（锁定了所有记录及间隙，等价于表级锁，但不同），多个这样的事务执行后，就很容易产生死锁和阻塞，最终应用系统会越来越慢，发生阻塞或死锁。

  + 解决方案：SQL语句中不要使用太复杂的多表关联的查询（降低SQL的复杂度）；使用explain执行计划对SQL语句进行分析，对于有全表扫描的SQL语句，建立相应的索引进行优化。

  + 产生原因二：两个事务分别想拿到对方持有的锁，互相等待，于是产生了死锁，如下图所示。

    ![2022022801](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022022801.png)

  + 解决方案：一个事务尽可能做到一次锁定所需要的所有资源；按照id对资源排序，然后按顺序进行处理。

    ```mysql
    # 事务A
    mysql> begin;
    Query OK, 0 rows affected (0.00 sec)
    
    mysql> select * from dept where deptno=1 for update; # 第一步
    +--------+-------+
    | deptno | dname |
    +--------+-------+
    |      1 | js    |
    +--------+-------+
    1 row in set (0.00 sec)
    
    mysql> update dept set dname='bigdata' where deptno=2; # 第三步
    Query OK, 1 row affected (30.95 sec)
    Rows matched: 1  Changed: 1  Warnings: 0
    
    mysql> commit;
    Query OK, 0 rows affected (0.00 sec)
    
    mysql> select * from dept;
    +--------+---------+
    | deptno | dname   |
    +--------+---------+
    |      1 | js      |
    |      2 | bigdata |
    +--------+---------+
    2 rows in set (0.00 sec)
    
    # 事务B
    mysql> begin;
    Query OK, 0 rows affected (0.00 sec)
    
    mysql> select * from dept where deptno=2 for update; # 第二步
    +--------+--------+
    | deptno | dname  |
    +--------+--------+
    |      2 | python |
    +--------+--------+
    1 row in set (0.00 sec)
    
    mysql> update dept set dname='java' where deptno=1; # 第四步
    ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction
    mysql> commit;
    Query OK, 0 rows affected (0.00 sec)
    
    mysql> select * from dept;
    +--------+---------+
    | deptno | dname   |
    +--------+---------+
    |      1 | js      |
    |      2 | bigdata |
    +--------+---------+
    2 rows in set (0.00 sec)
    ```

+ 共享锁转换为排他锁

  + 产生原因：事务A先查询一条记录，然后再更新该条记录，但此时事务B也更新该条记录（在事务A更新前进行），但由于事务A在查询该条记录对其加了共享锁，因此事务B必须等到事务A释放共享锁后才可以给该条记录加排他锁，因此只能进入加锁队列等待。如果这时事务A再执行更新操作，就会发生死锁（事务A也需要给该条记录加排他锁（共享锁转换为排他锁），但是在其前面事务B已经有一个加排他锁的请求，且正在等待事务A释放其共享锁）。

    ```mysql
    # 事务A
    mysql> begin;
    Query OK, 0 rows affected (0.00 sec)
    
    mysql> select * from dept where deptno=1 lock in share mode; # 第一步，共享锁
    +--------+---------+
    | deptno | dname   |
    +--------+---------+
    |      1 | bigdata |
    +--------+---------+
    1 row in set (0.00 sec)
    
    mysql> update dept set dname='js' where deptno=1; # 第三步，排他锁
    Query OK, 1 row affected (0.00 sec)
    Rows matched: 1  Changed: 1  Warnings: 0
    
    # 事务B
    mysql> begin;
    Query OK, 0 rows affected (0.00 sec)
    
    mysql> update dept set dname='java' where deptno=1;
    ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction # 第二步，由于事务A对该行记录加了共享锁，事务B无法添加排他锁，只能等待(MySQL对死锁进行了优化，第二步执行后等待，第三步执行后报错)
    ```

  + 解决方案：第一，对于按钮等控件，点击后立刻失效，不让用户重复点击，避免引发同时对同一条记录多次操作。第二，使用乐观锁进行控制。乐观锁机制避免了长事务中的数据库加锁开销，大大提升了高并发下的系统性能。需要注意的是，乐观锁机制是在我们的系统中实现的，来自外部系统的用户更新操作不受我们系统的控制，因此可能会造成脏数据被更新到数据库中。

**死锁的排查方案**

MySQL提供了几个与锁有关的参数和命令，可以辅助我们优化锁操作，减少死锁发生。

+ 查看近期死锁日志信息：show engine innodb status \G;，具体用法是先查看近期死锁日志信息，然后使用explain查看SQL执行计划(如果有全表记录的锁定的话)。

+ 查看锁状态变量：show status like 'innodb_row_lock%';，以便分析系统中的行锁的争夺情况。

  + Innodb_row_lock_current_waits：当前正在等待锁的数量；
  + Innodb_row_lock_time：从系统启动到现在锁定的总时长；
  + Innodb_row_lock_time_avg：每次等待锁的平均时间；
  + Innodb_row_lock_time_max：从系统启动到现在等待最长的一次锁的时间；
  + Innodb_row_lock_waits：从系统启动到现在总共等待的次数。

  > 如果等待次数高，且每次等待时间长，需要分析系统中为什么会有如此多的等待，然后着手定制优化。

## MySQL集群架构

### 集群架构设计理念

在集群架构设计时，主要遵从三个维度：可用性、扩展性、一致性

#### 可用性设计

保证高可用的方法是**冗余**（站点高可用，冗余站点；服务高可用，冗余服务；数据高可用，冗余数据），但数据冗余带来的问题是**数据一致性**问题。

实现高可用的方案有以下几种架构模式：

+ 主从模式：简单灵活，能满足多种需求（一般从库挂的比较多，因为它主要用于分担读压力），比较主流的用法，但是写操作高可用需自行处理。
+ 双主模式：互为主从，有双主双写、双主单写两种方式，建议使用双主单写。

#### 扩展性设计

扩展操作分为读操作扩展和写操作扩展两种：

1. 如何扩展以提高读性能
   + 加从库：简单易操作，方案成熟。但从库过多会损耗主库性能（如果采用主从模式，主库需要将Binlog日志推到从库，保证主从数据一致），因此建议不要作为长期的扩展方案，应该设法用良好的设计避免持续加从库来缓解读性能问题。
   + 分库分表：分为垂直拆分和水平拆分，垂直拆分可以缓解部分压力，水平拆分理论上可以无限扩展。
2. 如何扩展以提高写性能：分库分表

#### 一致性设计

一致性主要考虑集群中各个库的数据同步及同步延迟问题，可用采用的方案如下：

+ 不使用从库：扩展读性能问题需要单独考虑，否则容易出现系统瓶颈。
+ 增加路由访问层：可以先得到主从同步最长时间t，在数据发生修改后的t时间内，先访问主库。

### 主从模式

MySQL主从模式指数据可以从一个MySQL数据库服务器（主节点）复制到其他的一个或多个MySQL数据库服务器（从节点）。MySQL默认采用异步复制方式，这样从节点不用一直访问主节点来更新自己的数据。从节点通过设置可以选择复制主节点中的所有数据库、或特定的数据库、或特定的表。

![2022030201](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022030201.png)

上图所示，应用程序的读写直接访问主库，或配置主库和从库的数据源，人为配置读写分离。当主库出现故障时，人为将从库升级为主库，即实现了高可用。这种架构通常适用于轻量级、高可用要求不高的业务场景。通常，在这样的架构的基础上会引入KeepAlive等组件及双主复制，来做一些简单的高可用的切换。

MySQL主从复制的用途：

1. 实时灾备，用于故障切换（高可用）
2. 读写分离（主库写，从库读），提供查询服务（读扩展）
3. 数据库备份，避免影响业务（高可用）

MySQL主从部署的必要条件：

1. 从库服务器能连通主库；
2. 主库开启Binlog日志（设置log-bin参数）
3. 主从库的server-id不同

#### 实现原理

##### 主从复制

![2022030202](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022030202.png)

如主从复制的原理图所示，主从复制整体分为三步：

1. 主库将数据库的变更操作记录到Binlog日志文件中；
2. 从库读取主库中的Binlog日志文件信息，并写入到从库的Relay log中继日志文件中；
3. 从库读取中继日志文件信息，在从库中进行Replay以更新从库数据信息。

在上述三个过程中，涉及到了Master的BinlogDump Thread和Slave的I/O Thread、SQL Thread，它们的作用如下：

+ Master服务器对数据库的更新操作记录在Binlog中，主库接收到从库的read请求后，BinlogDump Thread读取Binlog信息推送给Slave的I/O Thread；
+ Slave的I/O Thread将读取到的Binlog信息写入到本地的Relay log中；
+ Slave的SQL Thread检测到Relay log的变更，读取并解析Relay log中内容在从库上执行，即在从库上Replay。

上述过程都是异步操作，俗称异步复制，存在数据延迟现象，异步复制的时序图如下：

![2020030203](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2020030203.png)

MySQL主从复制存在的问题：

1. 主库宕机后，Binlog可能没有成功同步（推送）到从库，导致数据丢失；
2. 从库只有一个SQL Thread，当主库写压力大时，复制很可能延时。

解决办法：

1. 通过半同步复制解决数据丢失的问题；
2. 通过并行复制解决从库复制延迟的问题。

##### 半同步复制

为了提升数据安全，MySQL让Master在某个时间点等待Slave返回ACK（Acknowledge character)消息，Master接收到ACK消息后才提交事务，这是半同步复制的基础。MySQL从5.5版本开始引入半同步复制机制来降低数据丢失的概率。

在介绍半同步复制之前，先介绍一下MySQL事务写入碰到主从复制时的完整过程，主库事务写入分为4步：

1. InnoDB Redo File Write(Prepare Write)
2. Binlog File Flush & Sync to Binlog File
3. InnoDB Redo File Commit(Commit Write)
4. Send Binlog to Slave

主从复制、半同步复制、增强半同步的区别：

+ 传统的主从复制：Master不需要关注Slave是否接收到Binlog Event；

+ 半同步复制（MySQL 5.5引入）：Master需要在第三步的事务提交后等待Slave返回ACK，然后给客户端返回事务提交成功，即after-commit;（主库在执行完客户端的事务提交后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中（成功后，Slave会向Master返回ACK）才会返回给客户端。）

  > 相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP/IP往返的时间，所以，半同步复制最好在低延时的网络中使用。
  >
  > 
  >
  > 如果采用半同步复制，客户端事务在存储引擎层提交后，在得到从库确认的过程中，主库宕机了，此时可能的情况有两种：
  >
  > 1. **事务还没发送到从库上**：此时客户端会收到事务提交失败的信息，客户端会重新提交该事务到新的主上，当宕机的主库重新启动后，以从库的身份重新加入到该主从结构中，会发现该事务在从库中被提交了两次，一次是之前作为主的时候，一次是被新主同步过来的。
  >
  > 2. **事务已经发送到从库上**：此时从库已经收到并应用了该事务，但是客户端仍然会收到事务提交失败的信息，重新提交该事务到新的主上。
  >
  > 增强半同步针对半同步复制的潜在问题进行了优化。

+ 增强半同步复制（MySQL 5.7引入）：Master需要在第二步后等待Slave返回ACK，然后再进行事务提交，即after-sync。

下面是MySQL官方对于半同步复制的时序图，主库等待从库写入Relay log并返回ACK后才进行Engine Commit。（我感觉这应该是增强半同步吧）

![2022030301](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022030301.png)

##### 并行复制

MySQL的主从复制一直是开发者最关注的问题之一，从MySQL 5.6开始加入了并行复制（Enhanced Multi-threaded Slave，MTS）功能，目的就是改善主从复制延迟问题。

从库中的两个线程（I/O Thread和SQL Thread）执行速度决定了从库进行复制的速度，由于这两个线程都是单线程模式工作，因此就有了延迟问题，采用多线程机制可以减少从库的复制延迟。但I/O Thread多线程意义不大，主要指的是SQL Thread 多线程并行处理Relay log中的事务日志信息。MySQL5.6、5.7、8.0版本都是基于SQL Thread多线程思想，不断优化来降低复制延迟。

**MySQL5.6并行复制原理**

MySQL5.6支持所谓的并行复制，但是其并行只是基于库的。如果用户的MySQL数据库中是多个库，那么对于从库复制的速度的确有比较大的帮助，如下图所示。

![2022030302](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/2022030302.png)

如上图所示，Relay log中有三个待Replay的事务，原来是一个线程顺序执行T1、T2、T3三个事务，现在是三个线程并行处执行三个事务，且不同的事务操作不同的数据库（事务T1操作DB1、事务T2操作DB2、事务T3操作DB3和DB4，这样事务间相互独立，它们操作不同的库，不会同时修改一条数据发生冲突）。

![image-20220303204656027](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220303204656027.png)

当采用了基于库的并行复制时，SQL Thread就变成了Coordinator，然后按库划分，不同库的操作分别进入各自的工作队列，最后由不同的线程执行。



MySQL5.6并行复制的优缺点：

+ 优点：基于库的并行复制，实现相对简单，使用也相对简单；
+ 缺点：基于库的并行复制在单库多表的使用场景就发挥不出优势了，且对事务并行处理的执行顺序也是个大问题（虽然对应不同的库操作，但可能将T1对DB1操作后的数据用于DB2）。

**MySQL5.7并行复制原理**

MySQL5.7是基于组提交的并行复制，这才是真正的并行复制，因为Slave服务器的Replay与Master服务器上的并行执行是一致的，即Master服务器上是怎么并行执行的Slave就是怎样进行Replay的，不再有库的并行复制限制。

**MySQL5.7中组（一组事务）提交的并行复制到底是如何实现的？**

MySQL5.7 将事务进行分组，当事务提交时，如果是单个事务（不能与其他事务同时提交），直接写入到Binlog日志中；如果多个事务能同时提交（组提交的事务间没有冲突，即一定不会修改同一行，因此将来可以在Slave上并行执行），就在主库的Binlog日志中添加组提交信息。

接下来就是找出没有冲突的事务，如何知道哪些事务是没有冲突的呢？所有已经处于prepare阶段的事务都是可以并行提交的（处于这个阶段的事务都是没有冲突的），这样这些当然也可以在从库中并行提交，然后开启对应数量的线程并行Replay即可。

> InnoDB事务提交采用的是两阶段提交，一个阶段是prepare（Redo Log、Undo Log写入和刷盘，执行SQL语句，因此事务间的冲突这个阶段就可以检查出来，没有冲突的事务就可以组提交），另一个是commit（Binlog写入、Undo Log清除、Redo Log提交）。

这是一种新的并行复制思路，完全摆脱了原来为了防止冲突而做的分发算法、等待策略等复杂而又低效的工作。

为了兼容MySQL5.6的基于库的并行复制，MySQL5.7引入了slave_parallel_type新变量，其值可以为DATABASE（默认值，基于库的并行复制）和LOGICAL_CLOCK（基于组提交的并行复制）。

**主库生成的Binlog内容如何告诉Slave哪些事务是可以并行复制的？**

MySQL5.7会将组提交的信息存放在GTID中，为了防止用户没有开启GTID功能（gtid_mode=OFF），MySQL5.7又引入了Anonymous_Gtid二进制日志event类型ANONYMOUS_GTID_LOG_EVENT。

通过mysqlbinlog工具分析binlog日志，就可以发现组提交的内部信息，如下图所示。

![image-20220304105843230](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220304105843230.png)

从上图可以发现，MySQL5.7的Binlog日志相较原来的binlog日志内容多了last_committed和sequence_number，其中last_committed表示事务提交时，上次事务提交的编号（比如last_committed=6就是last-committed=0这一组的最后一个事务的sequence_number）。如果事务具有相同的last_committed，表示这些事务都在一组内，可以并行Replay。

**MySQL8.0并行复制原理**

MySQL8.0是基于write-set的并行复制，MySQL会有一个集合变量，它存储已经执行的事务修改的记录信息（主键哈希值），这样后续所有提交的事务所修改记录的主键值经过hash后都会与那个变量的集合进行对比，如果集合变量中存在当前的主键哈希值，那么说明前面的事务对该记录进行过修改，这样两个事务的操作就冲突了；如果不存在，那么说明当前记录的两个操作就可以并行了。这样粒度就到了row级别了，此时并行的粒度更加精细，并行的速度会更快。

**并行复制配置与调优**

binlog_transaction_dependency_history_size  用于控制集合变量的大小。
binlog_transaction_dependency_tracking  用于控制binlog文件中事务之间的依赖关系，即last_committed值。

+ COMMIT_ORDER：基于组提交机制；
+ WRITESET：基于写集合机制；
+ WRITESET_SESSION：基于写集合，比writeset多了一个约束，同一个session中的事务last_committed按先后顺序递增。

transaction_wirte_set_extraction 用于控制事务的检查算法，可能的值为OFF、XXHASH64、MURMUR32。

master_info_repository 开启MTS功能后，务必将参数master_info_repository设置为TABLE，这样性能可以有50-80%的提升。因为并行复制开启后对元master.info这个文件的更新会大幅提升，资源的竞争也会变大。

slave_parallel_workers 如果该值设置为0，MySQL5.7退化为单线程复制；如果该值设置为1，SQL线程转化为coordinator线程，但是只有1个worker线程进行Replay，也是单线程复制。但这两个性能有区别，因为多了一次coordinator线程的转发，后者的性能反而比前者还要差。为了使用多线程，可以将该值设置为大于等于2。

slave_preserve_commit_order MySQL5.7后的MTS可以实现更小粒度的并行复制，但slave_parallel_type需要设置为LOGICAL_CLOCK，仅仅设置LOGICAL_CLOCK也会存在问题，因为此时在Slave上事务执行的顺序是无序的，和Relay log中记录的事务顺序不一样，这样数据一致性无法保证。为了保证事务是按照Relay log中记录的顺序Replay，就需要开启slave_preserve_commit_order。



如果要开启并行复制其实很简单，设置如下：

```mysql
slave-parallel-type=LOGICAL_CLOCK
slave-parallel-workers=16 
slave_pending_jobs_size_max = 2147483648 
slave_preserve_commit_order=1
master_info_repository=TABLE
relay_log_info_repository=TABLE
relay_log_recovery=ON
```

**并行复制监控**

使用了并行复制后，复制的监控依旧可以使用show slave status \G，但是MySQL5.7的performance_schema库中提供了很多元数据表，可以更详细的监控并行复制过程。

```mysql
show tables like 'replication%';
# 通过该参数可以看到worker进程的工作情况
select * from replicaiton_applier_status_by_worker;
```

> 如果MySQL5.7要使用并行复制功能，建议最少升级到5.7.19版本，修复了很多Bug。

#### 读写分离

### 双主模式

#### 适用场景

#### MMM架构

#### MHA架构

#### 主备切换

### 分库分表

#### 拆分方式

#### 主键策略

#### 分片策略

#### 扩容方案





