---
layout: post 
author: oshacker
title: 为什么说要搞定微服务架构，先搞定RPC框架？
category: dubbo
tags: [geek,dubbo,netty]
excerpt: 白话为什么需要RPC框架？
---


今天开始聊一些微服务的实践，首先聊一聊RPC框架的原理及实践，为什么说搞定微服务架构，先搞定RPC框架呢？

## 需求缘起

服务化的一个好处是**不限定服务的提供方用什么技术选型，能够实现大公司跨团队的技术解耦**，如下图：

![](https://www.coderap.cn/assets/images/2020/05/rpc0.png)

服务A是欧洲团队提供服务，欧洲团队的技术背景是Java，可以用Java实现服务；

服务B是美洲团队提供服务，可以用C++实现服务；

服务C是中国团队提供服务，可以用Go实现服务；

服务的上游调用方，只需要按照接口、协议就能完成对远端服务的调用。

但实际上，99.9%的公司的团队规模有限，技术团队人数也有限，基本是使用同一套技术体系来调用和提供服务的：

![](https://www.coderap.cn/assets/images/2020/05/rpc1.png)

这样的话，如果没有统一的服务框架（RPC框架），**各个团队的服务提供方就需要各自实现一套序列化、反序列化、网络框架、连接池、收发线程、超时处理、状态机等**“业务之外”的重复技术劳动，造成整体的低效。所以，统一RPC框架把上述“业务之外”的技术劳动统一处理，是服务化首要解决的问题。

在达成【“使用统一的RPC框架”是正确的道路】这个一致的前提下，本文期望用简单通俗的言语简述一下一个通用RPC框架的技术点与实现。

## RPC背景与过程

什么是RPC（Remote Procedure Call Protocol）,远程过程调用？

首先，先来看下什么是**本地函数调用**？当我们写下如下代码的时候：
```java
int result=Add(1,2);
```

我们知道，我们传入了1、2两个参数，调用了本地代码段中的一个Add函数，得到了result出参。此时，传入数据、传出数据、代码段在同一个进程空间中，这是**本地函数调用**，如下图。

![](https://www.coderap.cn/assets/images/2020/05/rpc2.png)

那有没有办法，我们能够调用一个跨进程（所以叫“远程”，典型是这个进程部署在另一台机器上）的函数呢？如下图所示

![](https://www.coderap.cn/assets/images/2020/05/rpc3.png)

最容易想到的，**两个进程约定一个协议格式，使用socket通信来传输【入参】、【调用哪个函数】、【出参】**。

假定请求报文是一个11字节的字节流，如下图：

![](https://www.coderap.cn/assets/images/2020/05/rpc4.png)
+ 前3个字节填入函数名
+ 中间4个字节填入第一个参数
+ 末尾4个字节填入第二个参数

同时，可以设计响应报文协议是一个4字节的字节流，即处理结果，如下图

![](https://www.coderap.cn/assets/images/2020/05/rpc5.png)

**调用方的代码**可能变为：
```java
request=MakePacket("add",1,2);
SendRequest_ToService_B(request);
response=RecieveResponse_FromService_B();
int result=unMakePacket(response);
```

简单解释一下：
1. 将传入参数变为字节流；
2. 将字节流发送给服务B;
3. 从服务B接收返回字节流；
4. 将返回字节流变为传出参数。

**服务方的代码**可能变为：
```java
request=RecieveRequest();
args/function=unMakePacket(request);
result=Add(1,2);
response=MakePacket(result);
SendResponse(response);
```

这个过程也很好理解：
1. 服务端收到字节流；
2. 将字节流转为函数名与参数；
3. 本地调用函数得到结果；
4. 将结果转变为字节流；
5. 将字节流发送给调用方。

这个过程用一张图描述如下，调用方和服务方的处理步骤都是非常清晰的。

![](https://www.coderap.cn/assets/images/2020/05/rpc6.png)

这个过程存在的最大的问题是：**调用方太麻烦了，每次都要关注很多底层细节。**
1. 入参到字节流的转化，即序列化应用层协议细节；
2. socket发送，即网络传输协议细节；
3. socket接收
4. 字节流到出参的转化，即反序列化应用层协议细节。

**调用层能不能不关注这些细节呢？**

RPC框架就是解决这个问题的，它能够让调用方“像调用本地函数一样调用远端的函数（服务）”。

## RPC框架的职责

通过上面的讨论，**RPC框架要向调用方屏蔽各种复杂性，也要向服务提供方屏蔽各种复杂性**：
1. 调用方感觉就像调用本地函数一样；
2. 服务提供方就像实现一个本地函数一样来实现服务。

所以，整个RPC框架又分为client部分和server部分，负责把整个非1、2的各类复杂性屏蔽，**这些复杂性就是RPC的职责所在**。

![](https://www.coderap.cn/assets/images/2020/05/rpc7.jpeg)

再细化一些：
+ client端：序列化、反序列化、连接池管理、负载均衡、故障转移、队列管理、超时管理、异步管理等指责；
+ server端：服务端组件、服务端收发包队列、io线程、工作线程、序列化反序列化、上下文管理器、超时管理、异步回调等指责。

howerver，因为篇幅有限，这些细节不做深入展开。

## 结论

RPC框架是架构微服务化的首要基础组件，它能大大降低架构微服务化的成本，提高调用方与服务提供方的研发效率，屏蔽跨进程调用函数（服务）的各类复杂细节；

RPC框架的指责：让调用方感觉就像调用本地函数一样调用远端函数，让服务提供方就像实现一个本地函数一样来实现服务。


参考：58沈剑 架构师之路