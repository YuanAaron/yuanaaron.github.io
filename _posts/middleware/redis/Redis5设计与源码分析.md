---
layout: post 
author: oshacker
title: Redis5设计与源码分析
category: redis
tags: [geek,redis]
excerpt: 深入Redis底层原理
---


在开源界，高性能服务的典型代表是Nginx和Redis，都是基于异步网络I/O机制的。

**为什么学Redis源码？**
+ 性能优势：Redis是一个优秀的高性能分布式缓存服务器，在实际引用场景中，每秒QPS能够达到4.5～5万（官方提供的数据是100000以上的QPS）；
+ 代码质量高：Redis的整体代码结构非常清晰，包括基本数据结构实现、数据类型实现、数据库实现、服务端实现、集群/主从/队列等，基本模块分布清晰，代码质量非常高；
+ 各种类型数据结构设计良好：简单稳定不容易溢出的字符串结构（sds）,快速排序查找的跳跃表（skiplist）,节约内存的压缩列表（ziplist）,基于hash表实现的字典（dict），基于链表（list）和压缩列表（ziplist）实现的快速列表（quicklist）,基于listpac和基数树（Rax）实现的消息队列（stream）等多种优秀数据结构的实现；
+ 各种算法的应用：Hash常用算法times33，物理位置查找算法geohash、高效率的统计算法HyperLogLog等。

## 第一章 引言

**Redis具有高性能的原因**
+ Redis是基于内存的存储数据库，绝大部分的命令处理只是纯粹的内存操作，内存的读写速度非常快；
+ Redis是单进程线程的服务（实际上一个正在运行的Redis Server肯定不止一个线程，但是只有一个线程来处理网络请求），避免了不必要的上下文切换，同时不存在加锁和释放锁等同步操作；
+ Redis使用多路I/O复用模型（select、poll、epoll），可以高效处理大量并发连接；
+ Redis中的数据结构是专门设计的，增删改查等相对简单。

### Redis简介

Redis（Remote Dictionary Server）是一个使用ANSI C编写的、开源的、支持网络的、基于内存的、可选持久化的键值对存储系统。目前的最新版为Redis 5.0.0。Redis的主要版本：
+ 2009.05发布Redis初始版本；
+ 2012发布Redis 2.6.0;
+ 2013.11发布Redis 2.8.0;
+ 2015.04发布Redis 3.0.0，该版本引入了集群；
+ 2017.07发布Redis 4.0.0，该版本引入了模块系统；
+ 2018.10发布Redis 5.0.0，该版本引入了Streams结构。

**Redis在互联网数据存储上的优势**
+ Redis是内存型的数据库，也就是说，Redis中的key-value对是存储在内存中的，因而效率比磁盘型的快；
+ Redis的工作模式为单线程，不需要线程间的同步操作。之所以采用单线程是因为，Redis是基于内存的操作，其瓶颈在机器内存的大小和网络带宽上，而不在CPU，再加上单线程容易实现，那就顺利成章地采用单线程的方案了；
+ Redis中key-value的value不仅可以是字符串，也可以是复杂的数据类型，如列表、集合、散列表等；
+ Redis支持数据持久化，可以采用RDB、AOF、RDB&AOF三种方案。计算机重启后可以从磁盘中数据恢复；
+ Redis支持主从结构，可以利用从实例进行数据备份。

## Redis5.0的新特性

相比Redis4.0，Redis5.0增加的几个较重要的新特性如下，其他可以参考官方文档：
+ 新增Streams数据类型，可以被当作消息队列；
+ 新的模块API、定时器、集群及字典；
+ RDB中持久化存储LFU和LRU的信息；
+ 将集群管理功能完全用C语言集成到redis-cli中，Redis3.x和4.x的集群管理功能是通过Ruby脚本实现的；
+ 有序集合新增ZPOPMIN/XPOPMAX命令；
+ 改进HyperLogLog的实现；
+ 新增Client Unblock和Client ID；
+ Redis主从复制中的从不再称为Slave，改称为Replicas；
+ Redis5.0引入动态哈希，以平衡CPU的使用率和相应性能，可以通过配置文件进行配置。Redis5.0默认使用动态哈希。
+ Redis核心代码进行了部分重构和优化。

# Redis源码概述

Redis核心源码主要存放在src目录下，简单划分如下：
+ 基本的数据结构
  + 动态字符串 sds.c
  + 跳跃表 
  + 整数集合 intset.c
  + 压缩列表 ziplist.c
  + 快速链表 quicklist.c
  + 字典 dict.c
  + Streams的底层实现结构listpack.c和rax.c
+ Redis数据类型的底层实现
  + Redis对象 object.c
  + 字符串 t_string.c
  + 列表 t_list.c
  + 字典 t_hash.c
  + 集合及有序集合 t_set.c和t_zset.c
  + 数据流 t_stream.c
+ Redis数据库的实现
  + 数据库的底层实现 db.c
  + 持久化 rdb.c和aof.c
+ Redis服务端和客户端的实现
  + 事件驱动 ae.c和ae_epoll.c
  + 网络连接 anet.c和networking.c
  + 服务端程序 server.c
  + 客户端程序 redis-cli.c
+ 其他
  + 主从复制 replication.c
  + 哨兵 sentinel.c
  + 集群 cluster.c
  + 其他数据结构 hyperloglog.c、geo.c等
  + 其他功能 pub/sub、lua脚本

## 简单动态字符串

简单动态字符串（Simple Dynamic Strings，SDS）用于存储字符串和整型数据。SDS兼容C语言标准字符串处理函数，并在此基础上保证了二进制安全。

**如何实现一个扩容方便且二进制安全的字符串呢？**
> 二进制安全：通俗地讲，C语言中用"\0"表示字符串的结束，如果字符串中本身就有"\0"字符，字符串就会被截断，即非二进制安全；若通过某种机制保证读写字符串时不损害其内容，则是二进制安全。

Redis 3.2之前的SDS代码如下：
```c
struct sdshdr {
    int len; //buf中已占用空间的长度
    int free; //buf中剩余可用空间的长度
    char buf[]; //数据空间 也可以是char buf[0];
};
```

SDS结构示意图如下，在64位系统下，字段len和字段free各占4个字节，紧接着存放字符串。

![](https://www.coderap.cn/assets/images/2020/05/redis5_1.png)

SDS这样设计的优点如下：
+ 有单独的统计变量len和free（称为头部），可以很方便地得到字符串长度。
+ 内容存放在柔性数组中，SDS对上层暴露的指针不是指向结构体SDS的指针，而是直接指向柔性数组buf的指针。这样，上层可以像读取C字符串一样读取SDS的内容，兼容C语言处理字符串的各种函数。
  > 在C99中，引入了柔性数组，它规定：结构体中的最后一个元素允许是未知大小的数组，这叫做柔性数组成员，但结构体中的柔性数组成员前面必须至少包含一个其他成员。包含柔性数组成员的结构体，通过malloc函数为柔性数组动态分配内存。

  >为什么用柔性数组存放字符串？
  + 柔性数组的地址和结构体是连续的，这样查找内存更快（不需要额外通过指针找到字符串的位置）；
  + 可以很方便地通过柔性数组的首地址偏移得到结构体首地址，进而能很方便地获取其余变量。

  >关于**柔性数组**可以参考皓叔的一篇文章：[C语言结构体里的成员数组和指针](https://coolshell.cn/articles/11377.html)
+ 由于有长度统计变量len的存在，读写字符串时不需要依赖"\0"终止符，保证了二进制安全。

至此，实现了一个基本的动态字符串，但该结构是否有改进空间呢？

**思考：不同长度的字符串是否有必要占用相同大小的头部，即len和free都使用占4个字节的int？**

实际应用中，存放在Redis中的字符串的长度往往没有这么长，每个字符串长度都用4字节的int存储未免太浪费空间。考虑三种情况：
+ 短字符串，len和free各占1个字节就够了；
+ 长字符串，len和free各占2字节或4字节；
+ 更长的字符串，len和free各占8字节。

接下来，**思考：如何区分这3种情况？对于短字符串，头部还是太长了，以长度为1字节的字符串为例，len和free本身就占用了2个字节，能够进一步压缩？**

对于第一个问题，增加一个字段flags来标识类型，用最小的1字节来存储，且把flags加在柔性数组之前，这样虽然多了1个字节，但是通过偏移柔性数组的指针能快速定位flags，以区分类型。

对于第二个问题，由于len已经是最小的1字节了，再压缩只能考虑用位来存储长度了。

综上所述，SDS至少要用3位来存储类型，因为类型有5种（长度小于1字节、1字节、2字节、4字节、8字节），而1个字节有8位，剩余的5位可以用来表示长度小于32的字符串的长度。因此，在Redis 5.0中，存储长度小于32的短字符串的代码如下：
```c
struct __attribute__ ((__packed__)) sdshdr5 { /* 取消字节对齐，结构体按照紧凑排列的方式占用内容 */
    unsigned char flags; /* 低3位存储类型，高5位存储字符串长度 */
    char buf[]; /* 柔性数组，存放实际内容 */
};
```

参考：
+ https://space.bilibili.com/345557916/
+ https://space.bilibili.com/232459430/video?keyword=redis










