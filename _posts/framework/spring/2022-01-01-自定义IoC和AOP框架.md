---
layout: post 
author: oshacker
title: 自定义IoC和AOP框架
category: spring
tags: [framework,spring]
excerpt: Spring
---

## Spring简介

Spring是一个分层的一站式轻量级开源框架，以IoC和AOP为内核，提供了用于展现层的Spring MVC和用于业务层的事物管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，已经成为使用最多的JavaEE企业级应用开源框架。

它由Rod Johnson在其著作中阐述的部分理念和原型衍化而来，2017年发布了Spring的新版本Spring 5.0通用版（GA）。

> Expert One-to-One J2EE Design and Development (2002)：阐述了J2EE使用EJB开发设计的优点和解决方案
>
> Expert One-to-One J2EE Development without EJB(2004)：阐述了J2EE开发不使用EJB的解决方式 （Spring雏形）

**Spring的优势**

+ 方便解耦，简化开发

  > 通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码造成程序过度耦合（Spring帮我们创建对象，不用我们去new对象，这样降低了两个类之间的耦合性）。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更专注于上层的应用。

+ AOP编程的支持

  > 通过Spring的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能通过AOP可以轻松应对。

+ 声明式事物的支持

  > @Transactional，可以将我们从单调烦闷的事物管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高开发效率和质量。

+ 方便程序的测试 

  > 可以用非容器依赖（不用启动容器）的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的事情。

+ 方便集成各种优秀框架

  > Spring可以降低各种框架的使用难度，提供对各种优秀框架（MyBatis、Kafka等）的直接支持 。

+ 降低JavaEE API的使用难度

  > Spring对JavaEE API（比如JDBC、JavaMail、远程调用等）进行了一层薄薄的封装，使这些API的使用难度大为降低。

+ 源码是经典的Java学习范例

  > Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式的灵活运用以及对Java技术的高深造诣。它的源代码无疑是Java技术的最佳实践的范例。

###  Spring的核心架构

![image-20211208185354646](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211208185354646.png)

从上图可知，Spring是一个分层非常清晰，且依赖关系、职责定位非常明确的轻量级框架，它主要包括以下几个模块：

+ Spring核心容器（Core Container）：Spring框架最核心的部分，它管理着Spring应用中bean的创建、配置和管理。在该模块中，包括了Spring bean工厂，它为Spring提供了DI的功能；基于bean工厂，我们还会发现有多种Spring应用上下文的实现。所有的Spring模块都构建于核心容器之上。
+ 面向切面编程（AOP/Aspects）：Spring对面向切面编程提供了丰富的支持，这个模块是Spring应用系统中开发切面的基础。此外，与DI一样，AOP可以帮助应用对象解耦。
+ 数据访问与集成（Data Access/Integration)：Spring的JDBC和DAO模块封装了大量样板代码，这样可以使得数据库代码变得简洁，我们可以更专注于业务，还可以避免数据库资源释放失败而引起的问题。另外，Spring AOP为数据访问提供了事务管理服务，同时Spring还对ORM进行了集成，如MyBatis等。
+ Web模块：提供了Spring MVC框架给Web应用，还提供了多种构建和其他应用交互的远程调用方案。Spring MVC在Web层提升了应用的松耦合水平。
+ Test：为了使得开发者能够很方便的进行测试，Spring提供了测试模块以致力于Spring应用的测试。通过该模块，Spring为使用Servlet、JNDI等编写单元测试提供了一系列的mock对象实现。

### IoC核心思想

> 注意：IoC和Aop在Spring之前就已经存在，只不过更偏向于理论化，Spring在技术层次对这两个思想做了非常好的实现

#### 什么是IoC？

IoC Inversion of Control（控制反转），它描述的是Java开发领域对象的创建、管理的问题。所谓控制指的是对象创建、管理的权利，反转指的是控制权交给IoC容器（Spring框架）了。

> 注意：IoC是一个技术思想，而不是一个技术实现。

比如类A依赖于类B，如果使用传统的开发方式，往往会在类A中new一个B的对象；如果使用IoC思想开发，我们不用自己去new对象了，而是由IoC容器帮我们实例化对象并管理它，我们需要使用哪个对象，去问IoC容器要即可。在上述过程中，我们丧失了创建、管理对象的权利，但获得了一个福报，即不用考虑对象的创建、管理等问题。

![image-20211209103552038](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211209103552038.png)

如果类A实例化时发现依赖于类B（类A中有一个B类型的属性），那么IoC容器会先帮我们去实例化类A、类B，得到a、b两个对象，然后会把b对象注入到a对象中。接下来，如果客户端（main）要使用a对象，那么只需要问IoC容器要即可。也就是说，对象实例化及依赖关系的维护都由Spring框架完成，而不用我们去管。

#### IoC解决了什么问题？

一句话：解决了对象之间的耦合问题。

![image-20211209115041506](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211209115041506.png)

如上图所示，本来Service层应该是面向Dao层的接口开发，即在Service层看到的应该是Dao接口类型，而不应该是其实现类，那么看到其实现类会有什么问题呢？

假如现在UserDao接口的实现变了，即实现类从UserDaoImpl变成了UserDaoImplNew，这时Service层使用的D ao的实现类都要从new UserDaoImpl改为new UserDaoImplNew，这里只需要改两个地方即可，但是在企业开发中可能需要改的地方很多，其工作量是恐怖的，原因是new导致Service层和Dao层耦合性太高。

IoC容器可以帮我们实例化对象，这样当我们在Service层使用Dao层时，只需要声明UserDao接口类型的属性即可，而不用面向具体的实现类，这样就不存在上面那么强的耦合。

#### IoC和DI的区别？

IoC和DI（Dependency Injection，依赖注入）描述的其实是同一件事（对象实例化及依赖关系维护），只不过角度不一样而已。

+ IoC是站在对象的角度，即对象实例化及管理的权利交给（反转）给了容器；
+ DI是站在容器的角度，即容器要把对象依赖的其他对象注入，比如类A中声明了一个B类型的属性，那么A对象实例化过程中就需要容器把B对象注入进来。

### AOP核心思想

#### 什么是AOP?

AOP（Aspect Oriented Programming，面向切面编程），它是OOP的延续。

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211209144218223.png" alt="image-20211209144218223" style="zoom:50%;" />

如上图所示，OOP是一种垂直继承体系，它可以解决大多数的代码重复问题，但是有一些情况是处理不了的，比如在顶级父类Animal的多个方法的相同位置出现了重复代码（横切逻辑代码)，如下图所示。

![1639034008547](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/1639034008547.png)

> 在多个纵向流程中出现的相同子流程代码，我们称为横切逻辑代码，它一般在事务控制、权限校验、日志等场景可能会用到。
>
> 横切逻辑代码存在的问题：
>
> + 横切代码逻辑重复
> + 横切逻辑代码和业务代码混杂在一起，代码臃肿，维护不方便

AOP独辟蹊径提出横向抽取机制，将横向逻辑代码和业务逻辑代码分开，如下图所示。

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211209153431398.png" alt="image-20211209153431398" style="zoom:50%;" />

代码拆分开容易，难点在于不改变业务逻辑的前提下，巧妙的将横切逻辑代码应用到原有的业务逻辑中（AOP通过动态代理实现这一点），达到和分开前一样的效果。

#### AOP解决了什么问题？

在不改变原有业务逻辑的情况下，增强了原有业务逻辑的功能（把横切逻辑代码应用到了原有的业务逻辑中），根本上实现解耦合，避免横切逻辑代码的重复。

#### 为什么叫面向切面编程？

切：指横切逻辑，由于原有业务逻辑代码我们不能动，只能操作横切逻辑代码，所以面向横切逻辑；

面：横切逻辑代码往往影响的是很多方法，每个方法都如同一个点，多个点构成面，因此有一个面的概念在里面。

## 手写IoC和AOP

前面介绍了IoC和AOP思想，接下来，先不要考虑Spring是如何实现这两个思想的，想象一下让你实现你会怎么做？

这里给出一个【银行转账】案例，分析之后找出该案例代码层次存在的问题，然后使用已有的知识解决这些问题（痛点），最终通过这个过程达到手写IoC和AOP的目的。

银行转账案例的sql脚本：

```sql
DROP TABLE IF EXISTS `account`;
CREATE TABLE `account` (
  `name` varchar(255) DEFAULT NULL COMMENT '用户名',
  `money` int(255) DEFAULT NULL COMMENT '账户金额',
  `cardNo` varchar(255) NOT NULL COMMENT '银行卡号',
  PRIMARY KEY (`cardNo`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

银行转账案例的初始代码见[transfer](https://github.com/YuanAaron/JavaTests/tree/master/transfer)























