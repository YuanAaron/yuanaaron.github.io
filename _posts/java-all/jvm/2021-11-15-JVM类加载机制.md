---
layout: post 
author: oshacker
title: JVM类加载机制
category: jvm
tags: [java,jvm]
excerpt: 【JVM理论与实战：第一篇】
---

## 开篇

本JVM系列文章专注于两个角度：

+ 基于大量绘图的方式搞懂JVM底层原理，比如JVM内存模型、类加载、垃圾回收等；

+ JVM生产实践，主要解决JVM生产环境的参数优化，JVM GC问题和JVM OOM问题。

##  Java代码如何运行起来？

一般来说，把".java"后缀的代码打包成".jar"后缀的jar包或".war"后缀的war包，然后jar包通过"java -jar"命令来运行代码，war包通过tomcat容器来部署代码。

在打包的过程中，会把".java"后缀的源文件编译成".class"后缀的字节码文件，这个字节码文件才是可以被运行的。一旦你采用"java -jar"命令，实际上就会启动一个JVM进程，这个JVM就会负责运行这些".class"字节码文件，即相当于运行我们写好的系统，如下图所示。

![image-20210723152251279](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20210723152251279.png)

JVM要运行这些".class"字节码文件中代码，首先要通过类加载器把这些".class"文件中包含的各种类给加载到JVM中，然后JVM基于自己的字节码执行引擎来执行加载到内存里的那些类，如下图所示。

![image-20210723153713336](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20210723153713336.png)

一旦JVM进程启动后，首先代码中包含"main()"方法的类被加载进内存，然后JVM就从"main()"方法开始执行里面的代码。之后，它需要哪个类就使用类加载器加载对应的类到内存里（**JVM加载类的时机**），反正对应的类就在对应的'".class"中。

**思考：**

既然".java"文件可以编译成".class"文件再运行，那么肯定也可以将".class"文件反编译成".java"文件。如果这样的话，编译后的公司核心系统代码被别人拿到，反编译回来，那么源代码不是被窃了吗？

**解决方案：**

编译时可以采用一些小工具对字节码加密或做混淆处理（有第三方公司做商业级的字节码文件加密），然后在类加载时，对加密的类，采用自定义的类加载器来解密文件，这样就可以保证源代码不被人窃取。

## JVM类加载机制

一个类从加载到使用，一般会经历如下过程：

加载 -> 验证 -> 准备 -> 解析 -> 初始化 -> 使用 -> 卸载

**验证阶段**

校验加载进来的".class"文件中的内容是否符合Java虚拟机规范。

**准备阶段**（重要）

给加载进来的类分配内存空间，类变量（static修饰的变量）也分配内存空间，并且设置默认初始值。

**解析阶段**

把符号引用替换为直接引用

**初始化**（核心）

```java
public class ReplicaManager {
  public static int i = Configuration.getInt("xxx");
  static {
    hello();
  }
}
```

在准备阶段，给ReplicaManager类分配好内存空间，给类变量i分配内存空间，并设置默认初始值0。但是Configuration.getInt("xxx")的执行以及赋值给i是在初始化阶段完成的，且static静态代码块也是在这个阶段执行。

类的初始化规则（什么时候会初始化一个类）：

+ 通过new实例化类的对象

+ 包含"main()"方法的主类，必须是立马初始化的；

+ 如果初始化一个类时，发现它的负累还没初始化，必须先初始化它的父类。

## 类加载器和双亲委派机制

Java里的类加载器有以下几种：

+ 启动类加载器：Bootstrap ClassLoader，一旦JVM启动，负责加载“Java安装目录/lib”中的核心类库；

+ 扩展类加载器：Extension ClassLoader，JVM一旦启动，负责加载“Java安装目录/lib/ext”目录中的类；

+ 应用程序类加载器：Application ClassLoader，负责加载ClassPath环境变量指定的路径下的类（你写好的Java代码）；

+ 自定义类加载器

双亲委派机制：假设应用程序类加载器需要加载一个类，首先会委派给自己的父类加载器去加载，最终传导到顶层的类加载器去加载；如果父类加载器在自己负责加载器的范围内，没有找到这个类，就会下推加载权利给自己的子类加载器。

简单一句话：先让父亲去加载，不行的话再由儿子来加载。这样可以避免多层级的加载器结构重复加载某些类。

**思考：**

一般用Java开发的Web系统都是采用tomcat来部署，而tomcat本身又是用Java写的，它自己就是一个JVM。简单的讲，一堆编译好的.class文件放入一个war包，然后在tomcat中来运行。那么，tomcat的类加载机制应该怎样设计，才能把我们动态部署进去的war包中的类加载到tomcat自身运行的JVM中，然后去执行那些我们写好的代码呢？

**解答：**

tomcat自定义了很多类加载器：

+ Common、Catalina、Shared等类加载器，用来加载tomcat自己的一些核心基础类库；

+ WebApp类加载器，负责加载我们部署的Web应用的类；

+ Jsp类加载器

tomcat打破了双亲委派机制：每个WebApp类加载器负责加载自己对应的那个Web应用的class文件，不会传导给上层类加载器去加载。

**拓展：** 深入研究tomcat的类加载机制