---
layout: post 
author: oshacker
title: 老年代GC日志分析
category: jvm
tags: [java,jvm]
excerpt: 【JVM理论与实战：实验】
---

前面通过案例分析了对象是如何进入老年代的，这一篇通过案例分析老年代的GC是如何触发的。

## Full GC日志分析（基础版）

代码如下：

```java
public class App {
    public static void main(String[] args) {
        byte[] arr1 = new byte[4*1024*1024];
        arr1 = null;

        byte[] arr2 = new byte[2*1024*1024];
        byte[] arr3 = new byte[2*1024*1024];
        byte[] arr4 = new byte[2*1024*1024];
        byte[] arr5 = new byte[128*1024];

        byte[] arr6 = new byte[2*1024*1024];
    }
}
```

JVM参数如下：

```
-Xmx20m -Xms20m -Xmn10m -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=3m -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log
```

### 代码执行流程

首先，创建了一个4M的数组对象，它大于大对象阈值，所以会直接进入老年代。接着，arr1指向了null，这样老年代的这个4M对象就变成了垃圾对象。

然后，连续创建了4个数组对象（3个2M和1个128K的数组），它们一直都被引用，因为都小于大对象阈值，所以它们都在Eden区域；

最后，希望再创建一个2M的数组对象，由于Eden区大小为8M，此时放不下这个2M的对象，就会触发一次Young GC。在这次GC后，Eden区的4个数组对象都会存活，Survivor区肯定放不下，所以它们会通过空间分配担保原则进入老年代。但在老年代中已经有一个4M的数组，放不下存活的4个数组对象，所以只有2个2M的数组对象进入老年代，继续放入1个2M和1个128K的数组对象，发现老年代不够了，这时就会触发一次Full GC来回收老年代。

> 注意：这里在CMS进行Full GC之前，就已经触发过一次Young GC了

### GC日志分析 

```java
Java HotSpot(TM) 64-Bit Server VM (25.231-b11) for bsd-amd64 JRE (1.8.0_231-b11), built on Oct  5 2019 03:15:25 by "java_re" with gcc 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)
Memory: 4k page, physical 33554432k(1539544k free)

/proc/meminfo:

CommandLine flags: -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=10485760 -XX:MaxTenuringThreshold=15 -XX:NewSize=10485760 -XX:OldPLABSize=16 -XX:PretenureSizeThreshold=3145728 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC 
0.081: [GC (Allocation Failure) 0.081: [ParNew (promotion failed): 6943K->7393K(9216K), 0.0028531 secs]0.084: [CMS: 8194K->6553K(10240K), 0.0021877 secs] 11039K->6553K(19456K), [Metaspace: 2654K->2654K(1056768K)], 0.0051473 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] 
Heap
 par new generation   total 9216K, used 2130K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)
  eden space 8192K,  26% used [0x00000007bec00000, 0x00000007bee14930, 0x00000007bf400000)
  from space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)
  to   space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)
 concurrent mark-sweep generation total 10240K, used 6553K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)
 Metaspace       used 2661K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K
```

ParNew (promotion failed): 6943K->7393K(9216K)

+ Promotion failed表示担保失败，即在进行新生代GC时，Survivor区放不下存活对象，就需要老年代进行空间分配担保，但在进入老年代时，老年代也放不下存活对象，就发生了担保失败。
+  6943K->7393K：因为发生了担保失败，所以Young GC不能回收已经分配的6M对象（3个2M+1个128K数组），还多出了一些元数据对象。

CMS: 8194K->6553K(10240K)

+ 老年代最开始放入了4M的大对象，但Full GC前老年代使用了8194K，证明在空间分配担保时，2个2M的数组对象进入了老年代。
+ 继续放入1个2M和1个128K的数组对象时，老年代放不下了，发生promotion failed，导致CMS管理的老年代发生了Full GC。在进行Full GC时，4M大对象已经是垃圾对象，所以会被回收，回收会空出的空间就可以存放1个2M和1个128K的数组对象了，所以GC后的老年代为3个2M和1个128K的数组对象，这与6553K是吻合的。

par new generation   total 9216K, used 2130K

+ 表明最后创建的一个2M的数组进入了新生代。

concurrent mark-sweep generation total 10240K, used 6553K

+ 老年代的对象就是老年代GC后存活的6553K对象。

## Full  GC日志分析（进阶版）

代码如下：

```java
public class App {
    public static void main(String[] args) {
        // 第一阶段
        byte[] arr1 = new byte[4*1024*1024];
        arr1 = null;

        byte[] arr2 = new byte[2*1024*1024];
        byte[] arr3 = new byte[2*1024*1024];
        byte[] arr4 = new byte[2*1024*1024];
        byte[] arr5 = new byte[128*1024];

        byte[] arr6 = new byte[2*1024*1024];
      
      	// 第二阶段
        arr6 = new byte[2*1024*1024];
        arr6 = new byte[2*1024*1024];
        arr6 = new byte[128*1024];
        arr6 = null;

        arr2 = null;
        arr3 = null;
        arr4 = null;
        arr5 = null;
        byte[] arr7 = new byte[2*1024*1024];
    }
}
```

JVM参数同上。

### 代码执行流程

**第一阶段**：执行流程跟基础版相同，即在创建arr6对象时，新生代的Eden区不够了，需要执行新生代GC；在执行新生代GC时，Survivor区放不下，需要老年代进行空间分配担保，但老年代也 放不下，所以需要执行老年代GC；

在第一阶段完成后，新生代中有arr6指向2M的数组对象，老年代中有arr[2-5]指向3个2M和1个128K的数组对象（还有一些元数据对象）。

**第二阶段**：继续创建2个2M和1个128K的数组对象，并让arr6指向null，此时Eden区中的6M多的对象（3个2M和1个128K）都是垃圾对象。然后，让arr[2-5]全部指向null，这样老年代 中的6M多（3个2M和1个128K）的对象也都成为了垃圾对象。最后，希望再创建一个2M的数组对象，但新生代Eden区放不下，就会发生一次Young GC。

### GC日志分析

```java
Java HotSpot(TM) 64-Bit Server VM (25.231-b11) for bsd-amd64 JRE (1.8.0_231-b11), built on Oct  5 2019 03:15:25 by "java_re" with gcc 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)
Memory: 4k page, physical 33554432k(2406644k free)

/proc/meminfo:

CommandLine flags: -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=10485760 -XX:MaxTenuringThreshold=15 -XX:NewSize=10485760 -XX:OldPLABSize=16 -XX:PretenureSizeThreshold=3145728 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC 
0.075: [GC (Allocation Failure) 0.075: [ParNew (promotion failed): 6943K->7402K(9216K), 0.0029152 secs]0.078: [CMS: 8194K->6556K(10240K), 0.0022655 secs] 11039K->6556K(19456K), [Metaspace: 2654K->2654K(1056768K)], 0.0052917 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] 
0.081: [GC (Allocation Failure) 0.081: [ParNew: 6307K->6307K(9216K), 0.0000133 secs]0.081: [CMS: 6556K->282K(10240K), 0.0013397 secs] 12864K->282K(19456K), [Metaspace: 2654K->2654K(1056768K)], 0.0014029 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 par new generation   total 9216K, used 2376K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)
  eden space 8192K,  29% used [0x00000007bec00000, 0x00000007bee52050, 0x00000007bf400000)
  from space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)
  to   space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)
 concurrent mark-sweep generation total 10240K, used 282K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)
 Metaspace       used 2661K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K
```

[ParNew (promotion failed): 6943K->7402K(9216K), 0.0029152 secs]0.078: [CMS: 8194K->6556K(10240K), 0.0022655 secs] 11039K->6556K(19456K)：

+ 第一阶段的GC日志和基础版的相同，即老年代空间分配担保失败，触发了一次Full GC，最终老年代中有arr[2-5]指向3个2M和1个128K的数组对象（还有一些元数据对象）。

ParNew: 6307K->6307K(9216K)

+ 按理说第二次Young GC是能够成功的，但是数据显示新生代的对象没有减少。原因是什么呢？
+ 在发生此次GC时，老年代中已经有6M多的对象，还剩不到4M的空闲内存，从空间分配担保规则（参考《垃圾回收》）可知 ：
  + 老年代的空间内存（不到4M）< 新生代的所有对象大小（6M多）；
  + 且小于每次Minor GC后进入老年代对象的平均大小（6M多）；
  + 此时需要先执行一次Full GC，所以新生代的对象大小没有变。

CMS: 6556K->282K(10240K)

+ CMS管理的老年代进行GC，由于arr[2-5]指向的对象全部指向null，即它们都是垃圾对象，所以在GC时会被回收，回收会剩下了282K的元数据对象。

12864K->282K

+ 12863K：在进行老年代GC前，整个堆空间的内存占用：第一次GC后老年代中的6556K+新生成的3个2M和1个128K的数组对象6307K。
+ 261K：在进行老年代GC后，整个堆空间的占用。但让人疑惑的是新生代中的6M多垃圾对象哪里去了？其实这里说明，**在进行Full GC时，不止回收老年代（Old GC），还会回收新生代（Young GC）和元空间**，所以这里就把新生代的垃圾对象一起回收了。

par new generation   total 9216K, used 2376K

+ 证明最后创建的arr7指向的2M的数据对象进入了新生代。

concurrent mark-sweep generation total 10240K, used 282K 

+ 老年代经过垃圾回收，还剩下282K的元数据对象。

## 思考

分析另外一种老年代GC的场景：老年代使用率达到92%时，也会触发Full GC。























