---
layout: post 
author: oshacker
title: ParNew和CMS垃圾回收器
category: jvm
tags: [java,jvm]
excerpt: 【JVM理论与实战：第六篇】
---

## 最常用的新生代垃圾回收器：ParNew

一般情况下，大家线上系统都是使用ParNew垃圾回收器进行新生代的垃圾回收。虽然现在有了最新的G1垃圾回收器，但其实很多线上系统还是用的ParNew。

通常运行在服务器上的Java系统，都能充分利用服务器的多核CPU（以4核CPU为例）优势，如果新生代使用单线程（Serial垃圾回收器）进行垃圾回收，就会导致没法充分利用CPU资源（JVM在进行垃圾回收时，系统程序所有的工作线程都停了，只有一个垃圾回收线程在运行，那么4核CPU的资源根本没法充分利用）。理论上讲，4核CPU可以支持4个垃圾回收线程并行执行，可以提升4倍的性能。所以，新生代的垃圾回收主要使用的是基于多线程垃圾回收机制的ParNew垃圾回收器。

> Serial和ParNew垃圾回收器都是用来回收新生代的，垃圾回收算法也完全相同，两者唯一的区别是前者是单线程，后者是多线程垃圾回收机制。

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211124222237441.png" alt="image-20211124222237441" style="zoom:80%;" />

如上图所示，一旦ParNew垃圾回收器触发Minor GC时，就会把系统程序的所有工作线程都停掉，禁止程序继续创建新的对象，然后自己用多个垃圾回收线程去进行垃圾回收，回收的机制和算法跟跟前面提到的一样。

在系统启动时，如果要【指定】使用ParNew垃圾回收器，只需要添加-XX:+UseParNewGC即可。

一般部署系统的服务器都是多核CPU，为了在垃圾回收时充分利用多核CPU的资源，一旦指定使用ParNew垃圾回收器后，它默认设置的垃圾回收线程的数量就等于CPU核心数。这一点一般不用手动调节，因为线程数跟CPU核数一样，可以充分进行并行处理。如果你一定要自己调节ParNew的垃圾回收线程数，可以通过-XX:ParallelGCThreads参数设置，但是一般不建议动这个参数。

### 思考

1. 到底用单线程垃圾回收好，还是多线程垃圾回收好？到底是Serial垃圾回收器好，还是P arNew垃圾回收器好？

   我们知道，系统启动时是可以区分服务器模式和客户端模式的，启动时加入“-server”就是服务器模式，加入“-client”就是客户端模式。

   如果系统部署在4核8G的Linux服务器上，就应该用服务器模式。服务器模式通常运行电商系统等后台系统之类的大型系统，一般都是多核CPU，所以肯定是用ParNew更好，因为多线程并行垃圾回收，可以充分利用多核CPU资源，提升性能。反之，如果服务器上使用单线程垃圾回收，就有一些CPU被浪费。

   如果Java程序是运行在Windows上的客户端程序，就应该用客户端模式。比如百度云盘的windows客户端等就运行在Windows个人操作系统上，这种操作系统很多都是单核CPU（当然现在很少了），如果还用ParNew来进行垃圾回收，会导致一个CPU运行多个线程，频繁的上下文切换反而加重了性能开销，可能效率还不如单线程好。所以，运行在Windows上的客户端程序建议采用Serial垃圾回收器，单CPU单线程垃圾回收即可，反而效率更高。

   > 其实现在一般很少用Java写客户端程序，主要用来构建复杂的大规模后端业务系统，所以常见的还是用“-server”指定为服务器模式，然后配合ParNew多线程垃圾回收。但你应该清楚单线程和多线程垃圾回收器的适用场景。

2. ParNew+CMS的GC，如何保证只有Minor GC，JVM参数该如何设置？

   理论上的回答：

   + 加大进入老年代的年龄，默认为15，加到30；
   + 修改新生代、老年代的比例，比如改为2:1；
   + 修改e区和s区的比例，比如改成6:2:2。

   最优的回答：

   + 这种问题最好结合线上系统的实际案例来介绍，上线系统后，首先要借助一些工具（后面有案例）观察每秒在新生代里创建多少新对象，然后多长时间触发一次Minor GC，平时每次Minor GC会有多少对象存活，Survivor区是否可以放得下。

     这里的关键点是必须让Survivor区放下，且不能因为动态年龄判断规则直接进入老年代。这样，Minor GC后还是存活这么多对象，依然可以放在另一块Survivor区域，基本就不会有对象升入老年代。

     在上面分析的基础上，合理分配e区和s区的内存大小，合理设置一些检查参数，就可以做到几乎消灭Full GC。具体可以参见【JVM理论与实战：第四篇】。

## CMS垃圾回收器

我们希望对象都分配在新生代的Eden区，每次垃圾回收后存活对象都进入Survivor区，然后下一次垃圾回收后的存活对象都进入另一个Survivor区，这样几乎很少的对象会进入老年代，也就不太会触发老年代的垃圾回收。

> 我们写代码很少考虑垃圾回收，最多有经验的工程师在上线前，按照我前面提到的案例一介绍的方法估算一下系统的内存压力以及垃圾回收的运行模型，合理设置 一下内存各个区域的大小，尽量避免太多对戏那个进入老年代。

但真实的情况是，线上系统很可能会因为各种情况导致很多对象进入老年代，然后频繁触发老年代的Full GC。比如前面的案例提到的，Survivor区太小，放不下每次Minor GC后的存活对象，导致对象频繁进入老年代，频繁触发老年代Full GC。

因此，我们要对老年代的垃圾回收器是如何回收的有一个了解。

### CMS垃圾回收基本原理

一般老年代的垃圾回收使用CMS垃圾回收器，它采用的是【标记-清理】算法，所谓标记-清理算法是先标记出垃圾对象（通过追踪GC Roots的方法看对象是否被GC Root引用了，如果是，那就是存活对象，否则就是垃圾对象），然后把这些垃圾对象清理掉。

这种方法最大的问题是会导致大量的内存碎片。如果内存碎片太多，导致后续对象进入老年代找不到可用的连续内存空间，就会触发Full GC，即太多的内存碎片实际上会导致更加频繁的Full GC，所以，CMS不仅仅使用“标记-清理”算法，还会使用“标记-整理”算法。

当然，这取决于-XX:+UseCMSCompactAtFullCollection参数是否打开，默认是打开的，意思是在Full GC后再次进行“Stop the World”，停止工作线程，然后进行碎片整理（把存活对象挪到一起，空出大片连续内存，避免内存碎片）。

> 还有一个参数是-XX:CMSFullGCsBeforeCompaction，意思是执行多少次Full GC后进行一次内存碎片整理工作，默认值是0，表示每次Full GC之后都会进行一次内存整理。

### CMS一边工作一边垃圾回收

假设先“Stop the World”，停止一切工作线程，然后慢慢执行“标记-清理”算法，会导致系统卡死时间过长，很多响应无法处理。所以，CMS垃圾回收器采取的是垃圾回收线程和系统工作线程尽量同时执行的模式。

CMS进行一次垃圾回收的过程分为4个阶段：

+ 初始标记
+ 并发标记
+ 重新标记
+ 并发清理

CMS垃圾回收的第一个阶段是【初始标记】阶段，这个阶段JVM进入“Stop the World”状态，系统的工作线程全部停止。所谓初始标记是标记出所有GC Roots直接引用的对象。

```java
public class Kafka {
  private static ReplicaManager replicaManager = new ReplicaManager();
}

public class ReplicaManager {
  private ReplicaFetcher replicaFetcher = new ReplicaFetcher();
}
```

如上面的代码，初始标记仅仅会通过replicaManager这个类的静态变量（GC Roots）标记出它直接引用的ReplicaManager对象，而不会管ReplicaFetcher对象，因为ReplicaFetcher是被ReplicaManager类的replicaFetcher成员变量（实例变量）引用的。我们之前提到过，方法的局部变量和类的静态变量是GC Roots，但类的成员变量不是GC Roots。

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211125160633161.png" alt="image-20211125160633161" style="zoom:80%;" />

初始标记虽然会“Stop the World”，暂停一切工作线程，但其实影响不大，因为仅仅标记GC Roots直接引用的那些对象速度很快。

第二个阶段是【并发标记】，这个阶段系统线程可以继续运行，在运行期间可能会创建新的存活对象，也可能会让部分存活对象失去引用变成垃圾对象。与此同时，垃圾回收线程会尽可能地对已有的对象进行GC Roots追踪。

> 所谓GC Root追踪是说，对ReplicaFetcher之类的全部老年代中的对象，会去看它被谁引用了 。比如，ReplicaFetcher对象是被ReplicaManager对象的成员变量（实例变量）引用了，而RepalicaManager对象被Kafka类的静态变量应用了，那么可以认定ReplicaFetcher对象是被GC Roots间接引用的，所以此时就不需要回收 。

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211125174130017.png" alt="image-20211125174130017" style="zoom:80%;" />

并发标记阶段就是对老年代所有对象进行GC Roots追踪，即追踪所有对象是否从根源上被GC Roots引用了，这其实是最耗时的。但是这个最耗时的阶段，是跟系统程序并发运行的，所以这个阶段不会对系统运行造成影响。

第三个阶段是【重新标记】阶段。在第二阶段时，垃圾回收线程在标记存活对象和垃圾对象，但系统线程在不停创建新对象，也可能让老对象变成垃圾对象，因此第二阶段结束后，肯定会有很多存活对象和垃圾对象是该阶段没有标记的，如下图所示。

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211125174239986.png" alt="image-20211125174239986" style="zoom:80%;" />

所以，第三阶段再次进入“Stop the World”状态，让系统线程停下来，然后重新标记第二阶段新创建的一些对象以及一些失去引用变成垃圾的老对象，如下图所示。

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211125174555884.png" alt="image-20211125174555884" style="zoom:80%;" />

重新标记的速度是很快的，因为它就是对第二阶段中被系统程序运行变动过的少数对象进行标记。

重新恢复系统程序的运行后，进入【并发清理】阶段。这个阶段系统程序随意运行，回收线程清理掉之前标记为垃圾的对象，如下图所示。

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211125175407898.png" alt="image-20211125175407898" style="zoom:80%;" />

因为要进行对象的清理，所以这个阶段是很耗时的，但它也是跟系统程序并发运行的，所以其实不会影响系统程序的运行。

### CMS性能分析

从上文可知，CMS垃圾回收器已经尽可能进行性能优化了，因为最耗时的两个阶段（一是对老年代全部对象进行GC Roots追踪并标记出垃圾对象，另一个是从内存中清理各种垃圾对象）都是和系统 程序并发执行的，所以基本这两个阶段对性能影响不大。

第一和第三阶段需要“Stop the World”，但是这两个阶段都是简单的标记而已，速度很快，所以基本上对系统运行影响不大。

### CMS垃圾回收的细节问题

第一个问题是并发回收垃圾机制会导致【CPU资源紧张】。

在并发标记和并发清理两个最耗时的阶段，垃圾回收线程和系统工作线程同时工作，会导致有限的CPU资源被垃圾回收线程占用了一部分：

+ 并发标记：需要对GC Roots进行深度追踪，看所有对象中有多少是存活的，但由于老年代里存活的对象比较多，这个过程会追踪大量的对象，耗时较高；
+ 并发清理：需要把垃圾对象从各钟随机的内存位置清理掉，也比较耗时。

所以，在这两个阶段CMS垃圾回收线程是比较耗费CPU资源的。

CMS默认启动的垃圾回收线程数是（CPU核心数+3）/4。以最普通的2核4G为例，本来CPU资源就有限，此时CMS还会有（2+3）/4=1个垃圾回收线程，占用宝贵的一个CPU。

第二个是【Concurrent Mode Failure】问题。

在并发清理阶段，CMS只不过是回收之前标记好的垃圾对象，但这个阶段系统一直在运行，随着系统的运行可能会让一些对象进入老年代，同时还变成垃圾对象，这种垃圾对象是“浮动垃圾”，如下图所示。

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211125225156397.png" alt="image-20211125225156397" style="zoom:80%;" />

如上图所示，在并发清理期间，系统程序可能先把某些对象分配在新生代，然后可能触发了一次Minor GC，一些对象进入了老年代，然后没多久这些对象又不被引用了。

这种对象就是老年代的“浮动垃圾”，因为它虽然成了垃圾，但是CMS这次只会回收之前标记出来的垃圾对象，需要等到下一次才会回收它们。

在CMS垃圾回收期间，为了保证一些对象可以进入老年代，一般会预留一些内存空间。如果CMS垃圾回收期间，系统程序放到老年代的对象大于预留（可用）内存空间，就会发生Concurrent Mode Failure，意思是并发垃圾回收失败了，一边回收，一边把对象放入老年代，内存都不够了。

> 当老年代内存占用达到一定比例时，就会自动触发GC，这也是CMS垃圾回收（Full GC）的一个触发时机。其中，这个比例可以用-XX:CMSInitiatingOccupancyFraction设置，jdk1.6的默认值为92%，即老年代占用了92%，就自动进行CMS垃圾回收，预留8%的内存空间给并发回收期间，以便系统程序把一些新对象放入老年代。

此时就会自动用Serial Old垃圾回收器替代CMS垃圾回收器，就是强行把系统程序“Stop the World”，不允许新对象产生，重新进行长时间的GC Roots追踪，标记出全部垃圾对象，然后一次性把垃圾对象都回收掉，完事了再恢复系统线程。

所以，在生产实践中，这个自动触发CMS垃圾回收的比例需要合理优化一下，避免“Concurrent Mode Failure”问题。

### 老年代GC触发时机的总结

1. 老年代可用内存大小 < 新生代全部对象的大小，如果没有开启空间担保参数，就会直接触发Full GC，所以一般空间担保参数都会打开。
2. 老年代可用内存大小 < 历次新生代GC后进入老年代的平均对象大小，会提前触发Full GC。
3. 新生代Minor GC后的存活对象大小 大于 Survivor区大小，也大于老年代可用内存大小，就会触发一次Full GC。
4. 如果老年代可用内存大小 > 历次新生代GC后进入老年代的平均大小，但是老年代的内存占用超过了-XX:CMSInitiatingOccupancyFraction设定的比例，也会触发Full GC。

### 思考

**老年代的Full GC为什么比新生代的Minor GC慢很多倍，一般在10倍以上？**

简单分析这两个GC的执行过程：

+ 新生代的Minor GC：新生代的执行速度很快，因为直接从GC Roots出发追踪哪些对象是活的就行了，而新生代存活对象很少，不需要追踪多少对象。然后直接把存活对象放入Survivor中，最后一次性回收Eden和之前使用的Survivor区。

+ 老年代的Full GC：首先，在并发标记阶段，需要去追踪所有存活对象，老年代存活对象很多，这个过程就会很慢；其次，在并发清理阶段，不是一次性回收一大片内存，而是找到零散分布在各个地方的垃圾对象，速度也很慢。最后，完事了还要执行一次内存碎片整理，把大量存活对象挪动到一起，空出来连续内存空间，这个过程还得“Stop the World”，那就更慢了。

  此外，如果并发清理期间，剩余内存空间不足以存放要进入老年代的对象，引发了“Concurrent Mode Failure”问题，就会自动转为Serial Old垃圾回收器，强行把系统程序“Stop the World”，然后重新进行一遍回收，这就更耗时了。

所以，老年代的垃圾回收就是慢。

















