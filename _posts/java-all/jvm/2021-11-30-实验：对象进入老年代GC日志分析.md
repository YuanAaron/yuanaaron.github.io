---
layout: post 
author: oshacker
title: 对象进入老年代GC日志分析
category: jvm
tags: [java,jvm]
excerpt: 【JVM理论与实战：实验】
---

前面分析了一次Young GC的日志 ，并结合GC日志分析了一次Young GC执行的全过程。接下来，通过案例来体验对象是如何从新生代进入老年代的。

前面总结过对象进入老年代的4个常见时机：

+ 在新生代躲过15次GC之后进入老年代 ；
+ 动态年龄判断规则（最常见）：如果Survivor区域内年龄1+年龄2+...+年龄n（n>1）的对象总和大于Survivor区的50%，此时年龄n及以上的对象会进入老年代；
+ 一次Young GC后存活对象太多，无法放入Survivor区，就会直接进入老年代
+ 大对象直接进入老年代

## 动态年龄判断规则

研究JVM运行过程，一定要一步步调试代码。

这里先给出了案例的部分代码，因为我们需要先运行部分代码，通过GC日志来分析这部分代码执行后JVM中的对象分配情况，代码如下：

```java
public class App {
    public static void main(String[] args) {
        byte[] arr1 = new byte[2*1024*1024];
        arr1 = new byte[2*1024*1024];
        arr1 = new byte[2*1024*1024];
        arr1 = null;

        byte[] arr2 = new byte[256*1024];
        byte[] arr3 = new byte[2*1024*1024];
    }
}
```

参数如下：

```
-XX:NewSize=10485760 -XX:MaxNewSize=10485760 -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:SurvivorRatio=8 -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=10485760 -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log
```

### 部分代码GC日志分析

```java
Java HotSpot(TM) 64-Bit Server VM (25.231-b11) for bsd-amd64 JRE (1.8.0_231-b11), built on Oct  5 2019 03:15:25 by "java_re" with gcc 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)
Memory: 4k page, physical 33554432k(585088k free)

/proc/meminfo:

CommandLine flags: -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=10485760 -XX:MaxTenuringThreshold=15 -XX:NewSize=10485760 -XX:OldPLABSize=16 -XX:PretenureSizeThreshold=10485760 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC 
0.065: [GC (Allocation Failure) 0.065: [ParNew: 7071K->570K(9216K), 0.0009925 secs] 7071K->570K(19456K), 0.0010537 secs] [Times: user=0.01 sys=0.01, real=0.00 secs] 
Heap
 par new generation   total 9216K, used 2700K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)
  eden space 8192K,  26% used [0x00000007bec00000, 0x00000007bee14930, 0x00000007bf400000)
  from space 1024K,  55% used [0x00000007bf500000, 0x00000007bf58ea08, 0x00000007bf600000)
  to   space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)
 concurrent mark-sweep generation total 10240K, used 0K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)
 Metaspace       used 2661K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K
```

代码执行流程：首先，连续创建了3个2M的数组，然后把局部变量arr1设为null，这样3个2M的数组就成了垃圾对象。接着，在Eden区创建了一个256K的数组并由arr2来引用。最后，希望在Eden区再次分配一个2M的数组，但由于Eden区中的3个2M的数组和1个256K的数组的总大小超过了6M（Eden总共才8M），不可能让你再创建一个2M的数组，所以一定会触发一次Young GC。GC前后如下图所示

![image-20211201161944432](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211201161944432.png)

查看GC日志可知：

+ GC之前年轻代占用了7071K的内存（6M的3个数组+256K的1个数组+几百M的一些未知对象（附加信息）），一次Young GC过后，剩余存活对象大概是570K（256K+未知的对象）；
+ From Survivor区占据了55%，大概是563K，这就证明Young GC后存活下来的对象都进入了From Survivor区。
+ 在GC过后，Eden区被占了26%，大概是2.08M，即最后一行代码创建的2M的数组对象。

> 注意：Eden区中的570K对象（256K+未知对象）熬过一次GC，年龄为1岁。虽然570K > 1M/2，但由于动态年龄判断是发生在Minor GC后，存活对象移动到From之前（此时S1区为空），因此这570K不会进入老年代。

### 完整代码GC日志分析

接下来，我们把代码完善一下，让其触发第二次Young GC，看看Survivor区域的动态年龄判定规则是否生效。

代码如下：

```java
public class App {
    public static void main(String[] args) {
        byte[] arr1 = new byte[2*1024*1024];
        arr1 = new byte[2*1024*1024];
        arr1 = new byte[2*1024*1024];
        arr1 = null;

        byte[] arr2 = new byte[256*1024];
        byte[] arr3 = new byte[2*1024*1024];

        arr3 = new byte[2*1024*1024];
        arr3 = new byte[2*1024*1024];
        arr3 = new byte[256*1024];
        arr3 = null;

        byte[] arr4 = new byte[2*1024*1024];
    }
}
```

JVM参数同上，GC日志如下：

```java
Java HotSpot(TM) 64-Bit Server VM (25.231-b11) for bsd-amd64 JRE (1.8.0_231-b11), built on Oct  5 2019 03:15:25 by "java_re" with gcc 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)
Memory: 4k page, physical 33554432k(2817004k free)

/proc/meminfo:

CommandLine flags: -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=10485760 -XX:MaxTenuringThreshold=15 -XX:NewSize=10485760 -XX:OldPLABSize=16 -XX:PretenureSizeThreshold=10485760 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC 
0.071: [GC (Allocation Failure) 0.071: [ParNew: 7071K->589K(9216K), 0.0005825 secs] 7071K->589K(19456K), 0.0006554 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
0.072: [GC (Allocation Failure) 0.072: [ParNew: 7149K->0K(9216K), 0.0022201 secs] 7149K->560K(19456K), 0.0022485 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
Heap
 par new generation   total 9216K, used 2212K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)
  eden space 8192K,  27% used [0x00000007bec00000, 0x00000007bee290e0, 0x00000007bf400000)
  from space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)
  to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)
 concurrent mark-sweep generation total 10240K, used 560K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)
 Metaspace       used 2661K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K
```

代码执行流程：完整代码在部分代码的基础上，会再次分配2个2M以及一个256K的数组，然后让arr3变为nul l，最后在Eden区还希望放一个2M的数组，但这肯定也是放不下的，所以必须然会再一次触发Young GC。GC前后如下图所示

![image-20211201165950203](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211201165950203.png)

完整版代码第一次GC日志的分析同上，第二次GC日志的分析如下：

+ GC之前年轻代占据了7149K，GC后的年轻代的内存占用为0K，在这个过程中，Eden区里的3个2M和1个256K的数组被回收了，From区中的589K对象（arr2引用的256K数组和未知对象）再次躲过Minor GC，年龄变为2(不足15岁)，且总大小超过了50%，根据动态年龄判定规则，年龄2及以上的对象进入老年代，因此589K对象全部进入老年代。这一点可以通过From和To区的内存使用为0%证明。
+ 589K与CMS管理的老年代的内存使用空间560K几乎相等，且年龄不足15岁，证明From区中的对象触发了动态年龄判断规则。
+ 第二次GC过后，Eden区被占了27%，大概是2.16M，即最后一行代码创建的2M的数组对象。

## 达到年龄阈值进入老年代

代码如下：

```java
public class App {
    public static void main(String[] args) {
        byte[] arr = new byte[128*1024];

        int cnt = 16;
        while (cnt-->=0) {
            byte[] arr1 = new byte[2*1024*1024];
            byte[] arr2 = new byte[2*1024*1024];
            byte[] arr3 = new byte[2*1024*1024];
        }
    }
}
```

参数为：

```
-Xmx20m -Xms20m -Xmn10m -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=10m -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log
```

### GC日志分析

```java
Java HotSpot(TM) 64-Bit Server VM (25.231-b11) for bsd-amd64 JRE (1.8.0_231-b11), built on Oct  5 2019 03:15:25 by "java_re" with gcc 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)
Memory: 4k page, physical 33554432k(1550884k free)

/proc/meminfo:

CommandLine flags: -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=10485760 -XX:MaxTenuringThreshold=15 -XX:NewSize=10485760 -XX:OldPLABSize=16 -XX:PretenureSizeThreshold=10485760 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC 
0.070: [GC (Allocation Failure) 0.070: [ParNew: 6943K->461K(9216K), 0.0008467 secs] 6943K->461K(19456K), 0.0009408 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
0.072: [GC (Allocation Failure) 0.072: [ParNew: 6765K->540K(9216K), 0.0004360 secs] 6765K->540K(19456K), 0.0004874 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
0.073: [GC (Allocation Failure) 0.073: [ParNew: 6990K->523K(9216K), 0.0004090 secs] 6990K->523K(19456K), 0.0004480 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
0.074: [GC (Allocation Failure) 0.074: [ParNew: 6814K->509K(9216K), 0.0003890 secs] 6814K->509K(19456K), 0.0004369 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
0.075: [GC (Allocation Failure) 0.075: [ParNew: 6805K->538K(9216K), 0.0009157 secs] 6805K->538K(19456K), 0.0009738 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
0.077: [GC (Allocation Failure) 0.077: [ParNew: 6837K->523K(9216K), 0.0003497 secs] 6837K->523K(19456K), 0.0004168 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
0.078: [GC (Allocation Failure) 0.078: [ParNew: 6823K->502K(9216K), 0.0003064 secs] 6823K->502K(19456K), 0.0003360 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
0.079: [GC (Allocation Failure) 0.079: [ParNew: 6804K->544K(9216K), 0.0003429 secs] 6804K->544K(19456K), 0.0003638 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
0.080: [GC (Allocation Failure) 0.080: [ParNew: 6846K->577K(9216K), 0.0003216 secs] 6846K->577K(19456K), 0.0003460 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
0.080: [GC (Allocation Failure) 0.080: [ParNew: 6880K->530K(9216K), 0.0003326 secs] 6880K->530K(19456K), 0.0003547 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
0.081: [GC (Allocation Failure) 0.081: [ParNew: 6833K->509K(9216K), 0.0003480 secs] 6833K->509K(19456K), 0.0003752 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 
0.082: [GC (Allocation Failure) 0.082: [ParNew: 6813K->533K(9216K), 0.0003310 secs] 6813K->533K(19456K), 0.0003577 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
0.083: [GC (Allocation Failure) 0.083: [ParNew: 6837K->544K(9216K), 0.0002975 secs] 6837K->544K(19456K), 0.0003227 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
0.084: [GC (Allocation Failure) 0.084: [ParNew: 6847K->546K(9216K), 0.0002838 secs] 6847K->546K(19456K), 0.0003071 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
0.084: [GC (Allocation Failure) 0.084: [ParNew: 6850K->575K(9216K), 0.0003210 secs] 6850K->575K(19456K), 0.0003480 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
0.085: [GC (Allocation Failure) 0.085: [ParNew: 6879K->0K(9216K), 0.0017243 secs] 6879K->431K(19456K), 0.0017570 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 
Heap
 par new generation   total 9216K, used 6467K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)
  eden space 8192K,  78% used [0x00000007bec00000, 0x00000007bf250f98, 0x00000007bf400000)
  from space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)
  to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)
 concurrent mark-sweep generation total 10240K, used 431K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)
 Metaspace       used 2661K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K
```

代码执行流程：

+ 首先，创建了一个128K的数组对象，且该对象一直被arr1引用，不会成为垃圾对象。
+ 然后，在while循环中每次创建3个2M的数组对象，由于while循环也是以栈桢的方式处理（尽管while循环体中最后没有arr1=null、arr2=null、arr3=null，但一次循环（代码块）后里面所有的局部变量都会回收），所以每一次循环后，这6M对象都会变成垃圾对象。
+ 这样，下次进入while循环时，由于年轻代已经存在6M多的对象（还有些元数据对象），而Eden区只有8M，不能再继续分配一个2M的对象，就需要进行年轻代的GC。

GC日志分析：

+ [ParNew: 6943K->461K(9216K), 0.0008467 secs]
  + 下次进入while循环时，Eden区不够再分配2M的对象，就会进行年轻代GC;
  + 461K：年轻代存活对象，即arr引用的128K的存活对象和一些元数据对象。
+ [ParNew: 6765K->540K(9216K), 0.0004360 secs]
  + 同上，一直执行15次
+ [ParNew: 6879K->0K(9216K), 0.0017243 secs]
  + 这是第16次进行新生代GC，此时arr引用的128K存活对象的年龄为15；
  + 0K：在这次GC执行完后，年轻代中没有存活对象，arr引用的128K存活对象和一些元数据对象进入了老年代。
+ concurrent mark-sweep generation total 10240K, used 431K
  + 431K：老年代中有431K的对象，这也就是在年轻代中连续15次存活下来，在第16次GC进入老年代的对象。
  + 这也证明：对象在新生代躲过15次Minor GC（-XX:MaxTenuringThreshold=15），即达到年龄阈值后，会进入老年代

## Survivor区放不下进入老年代

前面通过案例分析了对象是如何通过动态年龄判断规则进入老年代的，同时通过案例分析了对象达到年龄阈值之后会自动进入老年代。接下来，通过再通过案例分析Young GC后存活对象太多，Survivor区放不下，就直接进入老年代的情况。

代码如下：

```java
public class App {
    public static void main(String[] args) {
        byte[] arr1 = new byte[2*1024*1024];
        arr1 = new byte[2*1024*1024];
        arr1 = new byte[2*1024*1024];

        byte[] arr2 = new byte[128*1024];
        arr2 = null;
        byte[] arr3 = new byte[2*1024*1024];
    }
}
```

参数如下：

```
-Xmx20m -Xms20m -Xmn10m -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=10m -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log
```

### GC日志分析

```java
Java HotSpot(TM) 64-Bit Server VM (25.231-b11) for bsd-amd64 JRE (1.8.0_231-b11), built on Oct  5 2019 03:15:25 by "java_re" with gcc 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)
Memory: 4k page, physical 33554432k(721620k free)

/proc/meminfo:

CommandLine flags: -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=10485760 -XX:MaxTenuringThreshold=15 -XX:NewSize=10485760 -XX:OldPLABSize=16 -XX:PretenureSizeThreshold=10485760 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC 
0.080: [GC (Allocation Failure) 0.080: [ParNew: 6943K->321K(9216K), 0.0015908 secs] 6943K->2371K(19456K), 0.0016627 secs] [Times: user=0.01 sys=0.00, real=0.00 secs] 
Heap
 par new generation   total 9216K, used 2451K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)
  eden space 8192K,  26% used [0x00000007bec00000, 0x00000007bee14930, 0x00000007bf400000)
  from space 1024K,  31% used [0x00000007bf500000, 0x00000007bf5505e8, 0x00000007bf600000)
  to   space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)
 concurrent mark-sweep generation total 10240K, used 2050K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)
 Metaspace       used 2661K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K
```

代码执行流程：

+ 首先，创建了三个2M的数组对象放到Eden区，且arr1指向了最后一个2M的数组对象，即这时前面两个2M的对象已经成了垃圾对象，最后一个2M的对象还存在引用；
+ 然后，创建了一个128K的数组对象也放到了Eden区，且让arr2为null，这时这个128K的对象也成了垃圾对象；
+ 最后，希望再创建一个2M的对象，但我们知道，Eden区总共8M，前面已经创建了3个2M的对象和一个128K的对象，且存在一些元数据对象，这样Eden区的剩余内存空间不够2M，因此需要先进行一次Young GC。

GC日志分析：

+ [ParNew: 6943K->321K(9216K), 0.0015908 secs]
  + 这次GC回收掉了2个2M和1个128K的数组对象，有一个2M的数组对象和一些元数据对象存活下来，由于Survivor区只有1M，因此，存活下来的2M对象会因为Survivor区内存不足而进入老年代，而从GC后年轻代的321K对象可知，元数据对象进入了Survivor区。
+ concurrent mark-sweep generation total 10240K, used 2050K
  + CMS管理的老年代中使用了2050K的内存，证明arr1指向的2M存活对象进入了老年底。
+ from space 1024K,  31% used
  + Survivor From使用了1024*31%=317K，这也证明元数据对象GC后存活，进入了Survivor From区。
  + 此外，这说明新生代触发Young GC后，如果Survivor区放不下存活对象，并不是这些对象全部进入老年代，而是部分留在Survivor区，部分进入老年代。

## 大对象直接进入老年代

代码如下：

```java
public class App {
    public static void main(String[] args) {
        byte[] arr = new byte[2*1024*1024];
    }
}
```

jvm参数如下：

```
-Xmx20m -Xms20m -Xmn10m -XX:SurvivorRatio=8  -XX:MaxTenuringThreshold=15 -XX:PretenureSizeThreshold=1m -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:gc.log
```

### GC日志分析

```java
Java HotSpot(TM) 64-Bit Server VM (25.231-b11) for bsd-amd64 JRE (1.8.0_231-b11), built on Oct  5 2019 03:15:25 by "java_re" with gcc 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)
Memory: 4k page, physical 33554432k(2300380k free)

/proc/meminfo:

CommandLine flags: -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=10485760 -XX:MaxTenuringThreshold=15 -XX:NewSize=10485760 -XX:OldPLABSize=16 -XX:PretenureSizeThreshold=1048576 -XX:+PrintGC -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:+UseParNewGC 
Heap
 par new generation   total 9216K, used 835K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)
  eden space 8192K,  10% used [0x00000007bec00000, 0x00000007becd0f68, 0x00000007bf400000)
  from space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)
  to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)
 concurrent mark-sweep generation total 10240K, used 2048K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)
 Metaspace       used 2660K, capacity 4486K, committed 4864K, reserved 1056768K
  class space    used 287K, capacity 386K, committed 512K, reserved 1048576K
```

代码执行流程：创建了一个2M的数组对象，别的什么也没做。但我们这里设置了大对象的JVM参数：-XX:PretenureSizeThreshold=1m，所以这个2M的对象超过了大对象的阈值。

GC日志分析：

+ 这里只是创建了一个2M的对象，不会发生GC，这一点从GC日志中可知；
+ par new generation   total 9216K, used 835K
  + 程序执行完后，新生代中只有835K的对象，但我们创建了一个2M的对象，说明它不在新生代中；
+ concurrent mark-sweep generation total 10240K, used 2048K
  + CMS管理的老年代中使用了2048K，证明了我们创建的那个2M的对象进入了老年代；
  + 这就说明：当设置了大对象的阈值时，如果创建的对象大于这个值，就会直接进入老年代（在老年代中为其分配内存）





























