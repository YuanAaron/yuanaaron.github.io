---
layout: post 
author: oshacker
title: 老年代频繁Full GC案例
category: jvm
tags: [java,jvm]
excerpt: 【JVM理论与实战：第四篇】
---

## 老年代频繁Full GC案例

上一讲分析了什么时候回触发Minor GC，什么时候会让对象从新生代转移到老年代（包括为保证新生代转移到老年代的内存安全，Minor GC之前如何检查老年代的内存空间），什么情况下会触发老年代的Full GC，老年代的垃圾回收算法是什么等。

这一讲用一个生产系统老年代频繁Full GC的案例，透彻分析整个对象分配、转移到老年代以及Minor GC和Full GC的全过程。

### 日处理上亿的数据计算系统

这是一个数据计算系统，日处理数据量在上亿的规模。当然，对系统本身就简化说明，这里重点放在系统的生产环境的JVM相关的东西。

简单来说，数据计算系统会不停地通过SQL语句从MySQL数据库和其他方式从其他数据存储提取数据到内存中来进行计算，大致的生产负载是每分钟要执行500次数据提取和计算任务。由于这是一套分布式运行的系统，生产环境部署了多台机器，每台机器每分钟大概负责100次数据提取和计算任务。每次会提取大概1万条左右的数据到内存里计算，平均每次计算大概耗时10s。每台机器的配置是4核8G，JVM内存给了4G，其中新生代和老年代分别是1.5G的内存空间。

### 系统多快塞满新生代

每台机器上的系统每分钟会执行100次计算任务，每次1万条数据需要计算10s，那么每次1万条数据大概会占用多大内存？

这里的每条数据都是比较大的，每条数据大概包含了20个字段，可以认为每条数据在1KB左右的大小，那么每次计算任务的1万条数据就占用10MB的大小。

如果新生代按照8:1:1的比例来分配Eden和两块Survivor区域，那么Eden区就是1.2G，每个Survivor区在100M左右。如果按照这个内存大小，每次执行一个计算任务，就会在Eden区里分配10M左右的对象，每分钟执行100次计算任务，那么新生代的Eden区，基本上1min就迅速填满了。

### 触发Minor GC时多少对象进入老年代

假设新生代的Eden区1min过后就塞满对象了，接着继续执行计算任务，就需要进行Minor GC回收一部分垃圾对象。

我们知道，在执行Minor GC之前先检查老年代的可用内存是否大于新生代全部对象，此时老年代可用内存空间大概1.5G，新生代的Eden区就算它有1.2G对象好了，这样一次Minor GC过后，即使全部对象都存活，老年代也能放下，那么此时就会直接执行Minor GC了。那么Eden区有多少对象存活呢？

前面提到，每个计算任务（1万条数据）需要10s，假设80个计算任务都执行结束了，还有20个计算任务在计算中，这样200M的对象是存活的，不能被垃圾回收，1G的对象是可以回收的。此时一次Minor GC就会回收掉1G对象，然后200M对象能放入survivor区吗？

不能，因为任何一块survivor区只有100M内存，此时就会通过空间担保机制，让这200M对象直接进入老年代，然后Eden区就清空了。

### 系统运行多久老年代会填满

按照上面的计算，每分钟都是一个轮回，大概每分钟都会把新生代的Eden区填满，然后触发一次Minor GC，大概有200M左右的数据进入老年代。

假设现在2min过去了，老年代有400M内存被占用，只有1.1G的可用内存。如果第3min运行完毕，又要进行Minor GC，检查发现老年代可用空间小于新生代全部对象，那么此时就得看“-XX:HandlePromotionFailure”参数是否被打开了。

如果该参数打开了（一般都打开），就看老年代可用空间是否大于历次Minor GC过后进入老年代的对象的平均大小。此时老年代的可用空间（1.1G）大于每次Minor GC后进入老年代对象的平均大小（200M），此时就会尝试执行一次Minor GC，然后又是200M对象进入老年代。

转折点在运行了7min后，7次Minor GC后大概有1.4G对象进入老年代，此时老年代剩余空间不到100M，几乎快满了。

### 系统运行多久，老年代会触发一次Full GC?

大概在第8min运行结束时，新生代又满了，在执行Minor GC之前，发现老年代可用内存（只有100M）小于每次Minor GC后进入老年代对象的平均大小（200M），此时就会直接触发一次Full GC。

Full GC会把老年代的垃圾对象都回收了，假设老年代被占据的1.4G内存都是可以回收的对象，此时一次性就会把这些对象都给回收了。

接着就会执行Minor GC，又有200M对象进入老年代。由此可见，这里的Full GC就是为新生代本次Minor GC要进入老年代的对象准备的。

按照这个运行模型，基本上平均七八分钟进行一次Full GC，频率相当高了。因为每次Full GC速度都是很慢的，性能很差（后面会介绍为什么Full GC时会严重影响性能）

### 该案例如何进行JVM优化？

因为系统是数据计算系统，每次Minor GC时都会有一批数据没有计算完毕，按照现有的模型，最大的问题是survivor区域放不下存活对象。

你可以增加新生代的内存比例，比如3GB的堆内存，其中2G分配给新生代，1G留给老年代，这样survivor区大概就是200M，每次刚好能放下Minor GC过后存活的对象，等到下一次Minor GC时，这个Survivor区域（s1）的对象对应的计算任务早就结束了，都是可以回收的。如果Eden区的1.6G被占满了，然后s1有200M上一轮Minor GC后存活的对象，此时执行Minor GC就会把这两部分都回收掉，然后Eden区中剩余的200M存活对象会放入s2中（Eden区增大了，怎么每次存活对象还是200M？？？），这样基本上就很少有对象会进入老年代。

优化后生产系统老年代Full GC的频率从几分钟一次降到了几个小时，大幅提升了系统的性能。这里的优化只是一个示例，意思是增加survivor区的大小，让Minor GC后的对象进入survivor区，避免进入老年代。因为这样优化会产生新的问题，即满足动态年龄判定进入老年代的规则，即survivor区中的同龄对象大小超过survivor区内存的一半，就要直接进入老年代。

为了避免动态年龄判断规则把survivor区中的对象直接升入老年代，如果新生代内存有限，可以调整“-XX:SurvivorRatio=8”这个参数（默认Eden区为80%），降低Eden区的比例，给两块survivor区更多内存，让每次Minor GC后的对象进入survivor区，还可以避免动态年龄判断规则直接把他们他们升入老年代。









