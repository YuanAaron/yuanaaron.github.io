---
layout: post 
author: oshacker
title: 垃圾回收器
category: jvm
tags: [java,jvm]
excerpt: 【JVM理论与实战：第五篇】
---

## 垃圾回收器

### 垃圾回收器简介

新生代和老年代垃圾回收时都要用垃圾回收器进行回收，不同的区域用不同的垃圾回收器。

【Serial和Serial Old】垃圾回收器：分别用来回收新生代和老年代的垃圾对象

> 单线程运行，垃圾回收时停止我们系统的其他工作线程，让我们的系统直接卡死不动，然后进行垃圾回收。现在一般写后台Java系统几乎不用。

【ParNew和CMS】垃圾回收器：一般分别用在新生代和老年代

> 多线程并发机制，性能更好，现在一般是线上生产系统的标配组合。

【G1】垃圾回收器：统一收集新生代和老年代

> 采用了更加优秀的算法和设计机制

### 新生代GC

新生代内存分为Eden区和两个survivor区，系统不停的运行，当Eden区满了，就会触发Minor GC。我们知道，进行垃圾回收是有专门的垃圾回收线程的，且不同的内存区域会有不同的垃圾回收器，即垃圾回收线程和垃圾回收器配合起来，使用自己的垃圾回收算法，对指定的内存区域进行垃圾回收，如下图所示。

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211124001506452.png" alt="image-20211124001506452" style="zoom:50%;" />

垃圾回收一定会通过一个后台运行的垃圾回收线程来执行具体的逻辑：

比如新生代我们会用ParNew垃圾回收器来进行回收，该回收器对新生代采用复制算法进行垃圾回收。Eden区满了，就会触发一次Minor GC，它先把Eden区中的存活对象都标记出来，然后全部转移都s1去，最后一次性清空掉Eden区的垃圾对象。接着，系统继续运行，新对象继续分配在Eden区中，如下图所示。

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211124062544206.png" alt="image-20211124062544206" style="zoom:50%;" />

当Eden区再次塞满时，就会再次触发Minor GC，此时仍然是垃圾回收线程运行ParNew垃圾回收器中的复制算法逻辑，先标记出Eden和s1中的存活对象，然后一次性把存活对象转移到s2中，最后把Eden和s1中的垃圾对象都回收掉，如下图所示。

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211124063555261.png" alt="image-20211124063555261" style="zoom:50%;" />

### GC时还能继续创建新对象吗？

假设GC时允许系统继续在新生代的Ede区里创建新对象，会是一个什么样的场景？

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211124065625246.png" alt="image-20211124065625246" style="zoom:50%;" />

如上图所示，垃圾回收器正在做的是把Eden和s2中的存活对象标记出来，然后转移到s1中，最后把这两块内存的垃圾对象都清理掉。这时如果系统程序不停地在Eden里创建新对象，而这些新对象有的很快成了垃圾对象，有的是还被人引用的存活对象，是不是全乱套了？

+ 怎么让垃圾回收器持续去追踪新对象的状态？
+ 怎么在这次垃圾回收中把新对象中的存活对象转移到s2中？
+ 怎么把新对象中的垃圾都给回收了？

如果让垃圾回收器实现这些，会发现十分复杂，成本极高，而且很难做到。所以，目前来看，垃圾回收时，允许Java系统继续在Eden里创建新对象是非常不合适的。

### JVM的痛点：Stop the World

我们平时使用JVM最大的痛点就是在垃圾回收的时候，为了尽可能让垃圾回收器专心工作，此时JVM在后台直接进入“Stop the World”状态（停止Java系统的所有工作线程）。这样，我们的Java系统就不再继续创建新对象，同时让垃圾回收线程尽快完成垃圾回收工作（标记Eden和s2的存活对象，转移到s1中，然后一次性回收掉这两块内存的垃圾对象）。

一旦垃圾回收完毕，就可以让Java系统的工作线程恢复运行，也就可以继续在Eden创建新对象。

### Stop the World造成系统停顿

我们知道，"Stop the World"会造成系统卡顿，假设Minor GC要运行100ms，可能就会导致系统直接停顿100ms，在这100s内用户发起的所有请求都会出现短暂的卡顿，因为系统的工作线程不在运行，不能处理请求。

以一个Web系统为例，用户点击APP上一个按钮，平时只要几十ms就可以返回响应，但因为Web系统的JVM正在进行Minor GC，暂停了所有工作线程，导致请求过来到响应返回需要等得几百ms。

再比如，前面讲到的案例，因为内存分配不合理，对象频繁进入老年代，导致七八分钟就进行一次Full GC（Full GC是很慢的，有的时候可能要几s，甚至几十s，极端场景下几min也是可能的）。这样，系统每隔七八分钟就卡死30s（系统的JVM正在进行Full GC），在这30s内用户的任何请求都无法处理，然后用户看到的都是【系统超时】之类的提示，这让用户体验极差。

所以，无论是新生代GC还是老年代GC，都尽量不要频率过高，也不要持续时间太长，避免影响系统正常运行，这是使用JVM过程中最大的一个痛点，也是最需要优化的地方。

### 不同垃圾回收器的影响

新生代的回收

+ Serial垃圾回收器用一个线程进行垃圾回收，会暂停系统工作线程，一般服务器程序很少使用；
+ 平时常用的新生代垃圾回收器ParNew，针对多核CPU服务器做了优化，支持多线程进行垃圾回收，大幅提升回收性能，缩短回收的时间。

老年代的回收

+ CMS垃圾回收器：基于多线程，使用一套独特的机制尽可能减少垃圾回收时“Stop the World”的时间，避免长时间卡死系统。

新生代和老年代的回收

+ G1垃圾回收器：采用复杂的回收机制将性能优化到极致，尽可能更多的降低“Stop the World”的时间。

其实JVM本身的迭代演进，就是在不断的优化垃圾回收器的机制和算法，尽可能降低垃圾回收过程对系统运行的影响。我们需要尽可能地搞懂这些垃圾回收器的运行机制和算法，然后合理优化内存分配和垃圾回收，尽可能减少垃圾回收的频率、降低垃圾回收的时间，减少垃圾回收对系统运行的影响。这也就是所谓的JVM优化。

搞懂JVM的运行原理、垃圾回收机制，再加上各种生产故障的排查、定位、分析和解决，就会从本质上提升自己的能力，这样，在公司就可以轻松搞定自己负责的生产系统的JVM故障。



