---
layout: post 
author: oshacker
title: 系统上线部署JVM内存设置
category: jvm
tags: [java,jvm]
excerpt: 【JVM理论与实战：第四篇】
---

## JVM内存核心参数

-Xms：Java堆内存刚开始的大小

-Xmx：Java堆内存的最大大小（**注意**：通常与-Xms设置成一样的）

-Xmn：Java堆内存中新生代大小，扣除新生代剩下的就是老年代的内存大小了

-XX:PermSize：永久代大小（**注意：**jdk1.8后替换为-XX:MetaspaceSize）

-XX:MaxPermSize：永久代最大大小（**注意**：通常与-XX:PermSize设置成一样的；jdk1.8后替换为-XX:MaxMetaspaceSize）

-Xss：每个线程的栈内存大小

> 补充参数：
>
> -XX:MaxTenuringThreshold：躲过多少次Minor GC后进入老年代，默认15岁
>
> -XX:PretenureSizeThreshold：单位byte，超过该值的为大对象，直接在老年代分配内存

## 启动参数设置

IDEA中：点击Edit. Configuration...，在VM options中加入JVM参数；

线上部署系统（springboot）：java -jar -Xms512m -Xmx512m -Xmn256m -Xss1M -XX:PermSize=128m -XX:MaxPermSize=128m -jar App.jar

线上部署系统（tomcat）：在tomcat的bin/catalina.sh的首行添加JAVA_OPTS = " -Xms512m -Xmx512m -Xmn256m -Xss1M -XX:PermSize=128m -XX:MaxPermSize=128m"，然后重启tomcat即可。

**注意**：-Xms之类的参数后面直接跟内存大小，-XX:PermSize这种格式的参数后面需要=。

## JVM内存设置实战

在上线一个生产系统时，根据系统的业务量（预估的并发压力），如何给出一个未经过调优的比较合理的初始值？

根据业务场景分析，各种参数（堆内存，新生代、老年代，永久代，虚拟机栈）在设置时有哪些考虑的点？

下面以一个每日百万交易的支付系统案例为例进行分析。

> 网购流程：商品加到购物车，然后下单，接着对订单进行支付，最后钱从我们的账户进入网站的账户。
>
> 支付系统：是网站/App后台系统非常核心的环节，负责对接用户的支付请求，然后根据用户的付款方式跟第三方的支付渠道对接起来，比如支付宝、微信等。比如用户通过微信付款，他的钱在微信钱包，此时支付系统就得跟微信支付渠道对接，资金从微信划到电商公司账户。

支付的核心业务流程：

![image-20211115073638793](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211115073638793.png)

1. 用户在商城系统提交支付一个订单的请求，商城系统把这个请求提交给支付系统，支付系统就会生成一个支付订单（支付订单状态为“待支付”）；
2. 支付系统引导用户跳转到付款页面，选择一个付款方式；
3. 用户发起实际支付请求，支付系统把实际支付请求转交给第三方支付渠道（微信、支付宝等），它们会去处理支付请求进行资金转移；
4. 微信/支付宝处理完支付后，返回支付结果给支付系统，支付系统更新自己本地的支付订单状态（支付订单状态为“已完成”）。

完整的支付系统还要负责对账及跟商户合作之间的资金清算，包含应用管理、账户管理、渠道管理、支付交易、对账管理、清算管理、结算管理等各种功能模块，当然我们这里只关注最核心的支付流程即可。

支付系统的压力其实有很多方面，比如高并发请问、高性能处理请求、大量的支付订单数据的存储等技术难点，但抛开这些系统架构层面的东西，单单从JVM层面考虑，每日百万交易的【支付系统的压力】集中在哪里呢？

在上述业务流程中，最核心的环节就是用户发起支付请求时，支付系统会生成一个支付订单，这个支付订单需要记录支付是谁发起的、对哪些商品进行支付、支付渠道是啥、发起支付的时间等信息，从JVM的角度考虑，就是每天会在JVM中频繁的创建和销毁一百万个支付订单对象。

为了支撑这么多的支付订单对象在内存中的创建，接下来需要考虑的是：

+ 支付系统需要部署多少台机器？

+ 每台机器需要多大的内存空间？给JVM分配多大内存？
+ 每台机器上启动的JVM需要分配多大的堆内存？

为了回答这几个问题，需要从系统业务量进行分析：

+ 支付系统每秒需要处理多少笔支付订单？（决定堆内存大小的设置）
+ 每个支付订单处理耗时多久？
+ 每个支付订单大概需要多大的内存？

**支付系统每秒需要处理多少笔支付订单？**

假设每天100万个支付订单，用户交易行为一般都会发生在每天高峰期（中午或晚上）的几个小时，将100万平均分配到几个小时，大概是每秒100笔订单左右。假设支付系统部署了3台机器，那么每台机器实际上每秒大概处理30笔订单。

**每个支付订单大概要处理多长时间呢？**

用户发起一次支付请求，支付系统需要在JVM中创建一个支付订单对象，填充进去数据，然后把这个支付订单写入数据库，还可能会处理一些其他事情。假设一次支付请求的处理大概需要1s，每台机器1s接收到30笔支付请求，然后在JVM的新生代中创建30个支付订单的对象，并写入数据库等。1s之后这30个支付订单就处理完毕，然后这些支付订单对象在JVM的新生代里就是不被引用的垃圾对象了。接下来，下1s再来30个支付订单，重复该步骤。

**每个支付订单大概需要多大的内存？**

计算时不用考虑别的，直接根据支付订单类中成员变量的类型计算就可以了。一般来说，支付订单这种核心类按20个实例变量来计算，这样大概一个对象也就几百字节的样子，比如500字节，那么每秒发起的支付请求占用的内存大概是30*500字节=15000字节～15kb，其实是非常非常小的。

支付系统运行起来分析：每秒30个支付请求，创建30个支付订单对象，也就占据kb级别的内存而已，1s后这30个对象就没人引用了，就成了新生代里的垃圾。下一秒系统继续创建支付订单对象，在新生代中再放入30个支付订单，这样新生代里的对象会持续的累积。直到某一刻，新生代中有几十万个对象了，占据了几百M的空间，可能新生代就快满了，然后就会触发Minor GC，把新生代里的垃圾对象回收掉，腾出内存空间，然后继续在内存里分配新对象。

完整系统JVM层面的内存使用模型：除了核心业务流程中的支付订单对象（只是一小部分而已），真实的支付系统上线运行肯定每秒会创建大量其他对象，我们结合这个访问压力及核心对象的内存占用，可以估计整个支付系统每秒会占用核心核心对象的10~20倍的内存，那么每秒创建出来的被局部变量引用的对象大概占用几百kb~1MB的内存空间。然后，下一秒继续来新的请求，创建大概1M的对象在新生代中，接着变成垃圾。循环多次之后，新生代里的垃圾太多了，就会触发Minor GC回收掉这些垃圾。

**支付系统的JVM堆内存设置？**

一般来说这种线上业务系统，常见的机器配置为2核4G或4核8G。

2核4G的机器来部署还是有点紧凑的，虽说机器有4G内存，但是机器本身也要用一些内存，最后JVM进程最多就是2G内存。然后这2G内存还得分给方法区、栈、堆，那么堆内存可能最多就是1G多。堆内存还分为新生代和老年代，因为老年代需要放一些长期存活的对象，怎么也得给几百M的内存，那么新生代可能也就几百M的内存了。从上面可知，完整系统大致每秒会占据1M左右的内存空间。这样，运行几百秒后新生代内存空间就满了，就会触发Minor GC。如此频繁的触发Minor GC，会影响线上系统的性能稳定性。因此，考虑采用4核8G的机器来部署支付系统，那么你的JVM进程至少可以给4G以上内存，新生代里面至少可以分配到2G内存空间，这样将近半小时次新生代才会触发Minor GC，大大降低了GC的频率。

比如：采用4核8G的机器，然后-Xms和-Xmx设置为3G，即整个堆内存3G；-Xmn设置为2G，即新生代2G内存空间。

假设你的业务量更大，可以考虑部署不止3台机器，可以横向扩展部署，比如5台或10台，这样每台机器处理的请求更少，对JVM的压力更小。

## 不合理设置内存的案例

假设支付系统没有经过合理的内存预估，直接选用一台2核4G的虚拟机来部署线上系统，而且只用了一台机器，然后JVM给堆内存只有1G，扣除老年代后，新生代其实就几百M的内存，比如500M。

如果还按照前面的业务压力，每天100万交易，高峰期每秒大概100笔支付交易，每秒创建100个核心的支付订单对象，每个支付订单对象占据500字节左右，总共50kb左右。然后，一笔交易要1s来处理，这样这100个对象在新生代存在1s的期间会被引用，无法被回收。而且按照全局预估的思路，从核心的支付订单对象扩展开来，拓展到系统里其他的对象中去，起码要把内存占用扩大10～20倍，比如20倍，即1s之内总共会创建大概1M左右的对象，无法被回收。

【大促期间，瞬间访问量增加10倍】

其实按照估算出来的内存压力，这么小的新生代在系统正常运行的情况下，其实还问题不大。每秒新增1M对象，几百秒过后新生代满了，自然触发Minor GC，回收掉里面99%的垃圾对象。最多就是发现系统每隔几分钟略微卡顿一下，因为这时在进行垃圾回收，会影响系统性能。一旦搞【大促】活动，很可能导致压力瞬间增大10倍，这时系统压力本身就会很大，线程资源、CPU资源都会几乎打满，内存更是岌岌可危了。

【少数请求需要几十秒处理，导致老年代内存占用变大】

假设【大促】时流量激增，每秒1000笔交易，每秒钟系统占用的内存增加到10M以上，我们再大胆一点，预估每秒占用达到几十M，甚至上百M。

最最怕的一点是，可能本来每秒处理1000笔交易，现在不再是1s就可以处理完了 ，因为压力骤增，导致系统性能下降，可能偶尔出现每个请求处理需要几秒钟，甚至十几秒，这会出现什么问题呢？

假设新生代中积压了很多数据，快满了。然而，因为压力太大，系统性能太差，少数请求突然处理的特别慢，导致内存中有几十M的对象都被引用着。这时如果再次在新生代里分配对象，那么就要导致一次Minor GC，回收掉大量对象，但那少数几十M的对象可能还在。然后，新生代很快继续被填满，再次触发Minor GC，但少数几十M的对象还在，这样多次之后，就会被转移到老年代中。 

【老年代对象越来越多，导致频繁垃圾回收】

如果上述流程反复多次，即时不时少数请求特别慢，创建的对象在新生代反复多次都没有被回收，然后被放到老年代中（后续处理完后，老年代对象不被引用了，成了垃圾对象）。老年代的垃圾对象越来越多，迟早会满，然后就会触发老年代的垃圾回收，而且老年代被占满的频率还很快，可能就会频发触发老年代的垃圾回收。

我们知道，老年代的垃圾回收速度是很慢的（为什么慢后面会介绍），它频繁的垃圾回收，会极大的影响系统的性能。

【总结】

通过一个支付系统内存设置过小，在突发巨大流量、突然性能抖动下，导致新生代的很多对象长期被引用，无法被回收，然后导致很多对象不停迁移到老年代，最后导致老年代频繁被占满，频繁进行垃圾回收。

通过这个线上系统真实案例，你能体会到不合理预估业务系统压力，不合理的设置内存大小，就可能会导致很大的问题。

## 合理设置永久代和栈内存大小

一般刚开始上线一个系统，没太多可以参考的规范，永久代设置个几百M，大体上是够用的。因为里面主要是存放一些类的信息（后面有案例分析什么样的系统容易出现永久代内存溢出）。

栈内存 大小一般也不会特别的去预估，一般默认512KB到1M，就差不多够了。因为这个是每个线程自己的栈内存 ，用来存放线程执行方法期间的各种局部变量（后面也会有案例分析什么时候会发生栈内存溢出）。

## 后记

希望你多思考自己平时负责的系统，按照这个思路去预估业务系统压力，然后给一个合理的内存设置。其实，一个合格的工程师应该在上线系统时对系统压力作出预估，然后对JVM内存、磁盘空间大小、网络带宽、数据库压力作出预估，最后各方面给出合理配置。

