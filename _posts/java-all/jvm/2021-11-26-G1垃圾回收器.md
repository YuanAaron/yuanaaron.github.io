---
layout: post 
author: oshacker
title: G1垃圾回收器
category: jvm
tags: [java,jvm]
excerpt: 【JVM理论与实战：第八篇】
---

## ParNew+CMS组合的痛点

目前，ParNew+CMS带给我们最痛的一个点是“Stop the World”。

无论是新生代垃圾回收，还是老年代垃圾回收，都会或多或少产生“Stop the World”现象，对系统的运行是有一定影响的。所以后面对垃圾回收器的优化，都是朝着减少“Stop the World”去努力。

在这个基础上，G1垃圾回收器就应运而生了，它可以提供比“ParNew+CMS”更好的垃圾回收性能。

## G1垃圾回收器

G1垃圾回收器可以同时回收新生代和老年代对象，不需要两个垃圾回收器配合起来运作。

它把Java堆内存拆分为多个大小相等的Region，还有新生代和老年代的概念（它们【逻辑上】各自包含一些Region）。

G1最大的特点是可以设置一个垃圾回收的【预期停顿时间】，这个可以通过“-XX:MaxGCPauseMills”参数来设定，默认值是200ms。比如设置这个时间是1min/h，那么G1垃圾回收器会保证1小时内垃圾回收导致的“Stop the World”（系统停顿）不会超过1min，相当于我们可以直接控制垃圾回收对系统性能的影响。

我们之前的很多JVM优化思路（对内存合理分配、优化一些参数），就是为了尽可能减少Minor GC和Full GC，尽量减少GC带来的系统停顿，避免影响系统处理请求。

**G1是如何做到对垃圾回收导致的系统停顿可控？**

如果要做到这一点，必须要追踪每个Region的回收价值，搞清楚每个Region里的对象有多少是垃圾，如果对这个Region进行垃圾回收，需要耗费多长时间，可以回收掉多少垃圾。

所以，G1的核心设计思路是：

+ 首先，把内存划分为大量的小Region，
+ 然后，追踪每个Region中可以回收的对象大小和预估时间
+ 最后，在触发垃圾回收时，根据设定的预期停顿时间，选择最少回收时间和最多回收对象的Region进行垃圾回收，保证把“Stop the World”时间控制在指定的范围内，同时回收尽可能多的垃圾对象。

**Region可能属于新生代也可能属于老年代**

刚开始Region谁都不属于，然后分配给了新生代，里面放了很多对象，接着触发了Minor GC回收了这个Region。同一个Region下一次可能被分配给了老年代，用来放长期存活的对象。所以，在G1对应的内存模型中，Region随时会属于新生代也会属于老年代，实际上新生代和老年代各自的内存区域是不停变动的，由G1自动控制。

## G1分代回收原理

G1的堆内存分成了很多大小相等的Region内存区域，那么到底有多少个Region?每个Region的大小是多大？

通过“-Xms”和“-Xmx”给设置堆内存大小，这样JVM启动时发现使用的是G1垃圾回收器（用-XX:+UseG1GC指定使用G1），就会自动用堆大小除以2048（JVM最多可以有2048个Region），且Region的大小必须是2的倍数，比如1M、2M、4M等。

> 比如堆大小是4G，除以2048个Region，那么每个Region的大小就是2M。大概就是这样子决定Region的数量和大小，但保持默认的自动计算和设置就可以。如果要手动方式指定Region大小，则是“-XX:G1HeapRegionSize”。

刚开始时，默认情况下堆内存中新生代的初始占比是5%（按照上面的例子，大概200M左右，对应大概100个Region），这个可以通过“-XX:G1NewSizePercent”来设置，但一般保持默认即可。在系统运行过程中，JVM会不停给新生代增加更多Region，但新生代占比最多不会超过60%，这个可以通过“-XX:G1MaxNewSizePercent”来设置。一旦Region进行了垃圾回收，新生代的Region数量还会减少，这些都是动态的。

G1不仅有有新生代和老年代的区分，也有【Eden和Survivor】的概念，它们各自占据不同的Region，而且通过“-XX:SurvivorRation=8”还可以区分新生代的Region哪些属于Eden，哪些属于Survivor。随着对象不停的在新生代中分配，属于新生代的Region会不断增加，Eden和Survivor对应的Region也会不断增加。

### G1的新生代垃圾回收

G1的新生代垃圾回收的触发机制：

随着不停向新生代的Eden区对应的Region中放入对象，JVM会不停的给新生代增加更多Region，直到新生代占堆的60%（比如在上面的例子中，此时新生代占据了1200Region，其中Eden区占据了1000个Region，每个Survivor区占据100个Region），而且Eden区还满了，这时就会触发新生代的Minor GC，G1就会按照复制算法进行垃圾回收，进入“Stop the World”状态，然后把Eden区对应Region中的存活对象放入S1对应的Region中，最后回收掉Eden区对应的Region中的垃圾对象。

与ParNew不同的是，G1可以设定GC停顿时间，这样，G1就会追踪每个Region可以回收多少对象，回收需要多少时间，然后选择一部分回收，以保证GC停顿时间控制在指定范围内，且尽可能回收更多的对象。

### 对象进入老年代

我们知道，在G1的内存模型下，新生代和老年代各自都会占据一定的Region，默认情况下新生代最多只能占堆内存60%的Region，老年代最多可以占据40%的Region（比如在上面的例子中，大概就是800个左右的Region）。

对象从新生代进入老年代的时机和之前的类似：

+ 对象在新生代躲过了多次垃圾回收，达到了一定年龄（通过"-XX:MaxTenuringThreshold"参数设置），就会进入老年代；

+ 动态年龄判定规则：一旦发现某次新生代GC后，存活对象超过了Survivor的50%。比如年龄为1岁、2岁、3岁、4岁的对象大小总和超过了Survivor的50%，那么4岁及以上的对象就会进入老年代。

+ 如果发生Minor GC时，发现存活对象太多没法放入另一块survior区，这时就会让这些对象进入老年代。

+ 在G1内存模型下，大对象的判定和存放会有所改变。G1中大对象的判断规则是一个对象对象超过了一个Region大小的50%（比如上面的例子中，每个Region是2M，只要一个对象大小超过了1M就是大对象）。此外，G1提供了专门的Region来存放大对象，而不让大对象进入老年底的Region中，而且如果对象太大，可能会横跨多个Region来存放。

  > 【问题1】：堆内存哪些Region用来存放大对象呢？60%的Region给了新生代，40%给了老年代，哪些Region给大对象呢？
  >
  > 这个问题很简单，前面说过在G1中，新生代和老年代是不停变化的，比如新生代现在占了1200个Region，可能一次垃圾回收后里面1000个Region都空了，此时这1000个可以不属于新生代，这里面的很多Region就可以用来存放大对象。
  >
  > 【问题2】：大对象既然不属于新生代和老年代，什么时候触发垃圾回收呢？
  >
  > 新生代和老年代回收时会把大对象Region一起回收，这就是G1内存模型下大对象的回收策略。

### 新生代+老年代的混合垃圾回收

如果老年代占据了堆内存45%（-XX:InitiatingHeapOccupancyPercent，默认值是45%）的Region时，就会尝试触发一个新生代+老年代的混合垃圾回收（Mixed GC）。

Mixed垃圾回收的过程：

+ 初始标记
+ 并发标记
+ 最终标记
+ 混合回收

第一个阶段是【初始标记】，需要进入“Stop the World”，仅仅只是标记一下GC Roots直接引用的对象，这个过程速度是很快的。

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211128134933823.png" alt="image-20211128134933823" style="zoom:80%;" />

如上图所示，先停止系统程序的运行，然后扫描线程栈内存中的局部变量以及方法区中的类静态变量代表的GC Roots，标记出它们直接引用的对象。

第二个阶段是【并发标记】，这个阶段允许系统程序的运行，同时进行GC Roots追踪，从GC Roots开始追踪所有的存活对象，如下图所示。

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211129064140447.png" alt="image-20211129064140447" style="zoom:80%;" />

> GC Roots追踪
>
> ```java
> public class Kafka {
>   private static ReplicaManager replicaManager = new ReplicaManager();
> }
> 
> public class ReplicaManager {
>   private ReplicaFetcher replicaFetcher = new ReplicaFetcher();
> }
> ```
>
> Kafka类的静态成员变量replicaManager就是一个GC Roots对象，初始标记阶段仅仅标记replicaManager这个GC Roots直接关联的对象，即ReplicaManager对象，它肯定是存活的。并发标记阶段会进行GC Roots追踪，从replicaManager这个GC Roots直接关联的ReplicaManager对象开始往下追踪，发现ReplicaManager对象有一个实例变量replicaFetcher，追踪这个replicaFetcher变量可以发现它引用了ReplicaFetcher对象，那么这个ReplicaFetcher对象也要被标记为存活对象。

并发标记是很耗时的，因为要追踪全部的存活对象。但这个阶段可以跟系统程序并发运行，所以对系统程序的影响不太大。此外，JVM会记录并发标记阶段对对象做出的一些修改记录，比如新建了哪个对象，哪个对象失去了引用等。

接下来是【最终标记】阶段，这个阶段会进入“Stop the World”，禁止系统程序运行，但是会根据并发标记阶段记录的哪些对象修改，最终标记一下哪些是存活对象，哪些是垃圾对象，如下图所示。

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211129071408574.png" alt="image-20211129071408574" style="zoom:80%;" />

最后一个阶段是【混合回收】，这个阶段会计算老年代中每个Region中的存活对象数量、占比，还有垃圾回收的预期性能和效率。然后，停止系统程序，全力以赴尽快进行垃圾回收，此时会选择部分Region进行回收，因为垃圾回收的停顿时间必须控制在已经设置的范围内，如下图所示。

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211129071836995.png" alt="image-20211129071836995" style="zoom:80%;" />

> 注意：其实老年代对堆内存占用达到45%时，触发的是混合回收，即此时回收的不仅仅是老年代，还会回收新生代和大对象。至于回收这些区域的哪些Region就要看情况了，因为我们设置了GC停顿时间，所以它会从老年代、新生代和大对象里各自挑选一些Region，保证在指定的时间内回收尽可能多的垃圾，这就是所谓的混合回收。

在混合回收时，会停止所有程序运行，所以说G1是允许执行多次混合回收的。比如先停止系统程序，执行一次混合回收回收掉一些Region，然后恢复系统运行，接着再次停止系统程序，再执行一次混合回收回收掉一些Region。反复回收多次（-XX:G1MixedGCCountTarget，默认值是8次）可以尽可能不让系统程序停顿时间过长，可以在多次回收的间隙也运行一下。

在混合回收时，对Region的回收都是基于复制算法进行的，即把要回收的Region里的存活对象放入其他Region，然后把这个Region中的垃圾对象全部清理掉。这样在回收的过程中，就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%（-XX:G1HeapWastePercent，默认值是5%），就会立即停止混合回收，意味着本次混合回收就结束了。

> G1整体上是基于复制算法进行Region垃圾回收的，不会出现内存碎片问题，不需要像CMS那样标记-清除之后，再进行内存碎片的整理。
>
> 注意：如果把要回收的Region里的存活对象放入其他Region时，发现没有空闲Region可以承载，就会触发一次失败。一旦失败，立马就会切换为停止系统程序，然后采用单线程进行标记、清理和压缩整理，空闲出来一批Region，这个过程是极慢的。

另外，确定要回收的Region必须是存活对象低于85%的（-XX:G1MixedGCLiveThresholdPercent，默认值是85%），如果一个Region的存活对象多余85%，回收也就没有必要了，因为把85%的对象都拷贝到别的Region的成本是很高的。

### 思考 

结合针对ParNew+CMS组合分析过的JVM GC优化思路，思考：

1. G1垃圾回收器使用时有哪些地方是值得优化的？
2. 什么 时候可能会导致G1频繁触发Mixed GC？如何尽量减少Mixed GC的频率？























