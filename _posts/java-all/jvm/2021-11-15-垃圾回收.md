---
layout: post 
author: oshacker
title: 垃圾回收
category: jvm
tags: [java,jvm]
excerpt: 【JVM理论与实战：第三篇】
---

## 为什么要垃圾回收？

一般来说，机器的内存资源是有限的，在一台机器上启动一个Java系统（本质是一个JVM进程），这个JVM进程会占用机器上的部分内存资源，在JVM的堆上创建的对象会占用JVM的内存资源。

JVM本身是有垃圾回收机制的，它是一个后台自动运行的线程。你只要启动一个JVM进程，它就会自带一个垃圾回收的后台线程，这个线程会在后台不断检查JVM堆内存中的各个实例对象。

当没有任何一个局部变量引用Java堆内存里的某个实例对象时，也没有任何一个类的静态变量，常量等引用它，垃圾回收线程就可以把垃圾（这个没人指向的实例对象）回收，从内存里清除掉，避免占用任何内存资源。JVM中的垃圾会定期的被后台的垃圾回收线程清理掉，不断释放内存资源。

![image-20210727155504846](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20210727155504846.png)

**思考：**

Java堆内存里的对象会被回收掉，那么加载到方法区的类会被垃圾回收吗？什么时候被回收？

**解答：**

方法区里的类被回收需要满足的条件：

\+ 该类的所有实例对象都已经从Java堆内存里被回收；

\+ 加载这个类的ClassLoader已经被回收；

\+ 该类对应的java.lang.Class对象没有在任何地方被引用。

## JVM分代模型

接下来，深入学习JVM内存划分的原理细节，及我们创建的对象在JVM中到底是如何分配、如何流动的。

我们要知道，我们的Java代码中创建的大部分对象都是存活周期很短的，分配在J ava堆内存中，使用完后迅速就会被垃圾回收。如下面的replicaManager对象。

```java
```java
public class Kafka {
  public static void main() {
    while(true) {
      loadReplicasFromDisk();
      Thread.sleep(1000);
    }
  }
  
  private static void loadReplicasFromDisk() {
    ReplicaManager replicaManager = new ReplicaManager();
    replicaManager.load();
  }
}
```

如果一个对象被类的静态变量引用，它就会长期停留在Java堆内存中，让程序后续不停地去使用），这个对象的生命周期就很长，轻易不会被垃圾回收，如下面代码所示。

```java
public class Kafka {
  private static ReplicaManager replicaManager = new ReplicaManager();
  
  public static void main() {
    while(true) {
      loadReplicasFromDisk();
      Thread.sleep(1000);
    }
  }
  
  private static void loadReplicasFromDisk() {
    replicaManager.load();
  }
}
```

JVM内存的分代模型：年轻代、老年代、永久代。

从上面两段代码可知，采用不同的方式创建和使用对象，对象的生命周期是不同的。所以JVM把堆内存分为了两个区域：

+ 年轻代：用于存放创建和使用完之后立马就要回收的对象，即用于存放短期存活的对象；

+ 老年代：用于存放创建之后需要长期存在的对象，即用于存放长期存活的对象。

注意：第二段代码中的replicaManager刚开始会在年轻代里，但最终会进入老年代（后面介绍什么时候进入老年代）。

为什么要分成年轻代和老年代？

这跟垃圾回收有关，年轻代里的对象的特点是创建之后很快就会被回收，所以需要用一种垃圾回收算法（后面知道是复制算法）；老年代对象的特点是需要长期存在，所以需要另一种垃圾回收算法（后面知道是标记整理算法）。因此需要分成两个区来放不同的对象。

JVM里的永久代其实就是方法区的实现。

## 对象在JVM内存中的分配和流转

大部分正常对象都优先在新生代分配内存，从上文可知，哪怕是长期存活在内存里的对象，刚开始也是分配在新生代里的。

**什么情况下触发新生代的垃圾回收呢？**

并不是Java堆内存中出现不被引用的实例对象，就一定立即会发生垃圾回收。

我们在代码中创建的大部分对象，其实都是这种使用完后立马就可以回收掉的生存周期极短的对象。可能在新生代里分配了大量的对象，使用完后立马就没人引用了，这时新生代几乎被占满了，如果需要分配新的对象，发现新生代里内存不够了，这时就会触发一次新生代的垃圾回收，即"Minor GC/Yong GC"，它会尝试把新生代里那些没人引用的垃圾对象给回收掉，腾出大量的内存空间。

**长期存活的对象会躲过多次垃圾回收**

随着系统的运行，新生代不停的创建对象，直到新生代满了，就会垃圾回收一次，大量对象被回收掉，但是被静态变量引用对象不会被回收。比如上面Kafka类中replicaManager引用的ReplicaManager对象就一直会存活在新生代里。

JVM规定：一个实例对象在新生代中，经过15次垃圾回收后还没被回收掉（该对象的年龄是15岁，每垃圾回收一次，该对象没有被回收掉，它的年龄就加1），我们就认为它是长期存活的对象，就会把它转移到Java堆内存的老年代中。

**老年代会垃圾回收吗？**

答案是肯定的，因为老年代的对象页可能随着代码的运行，不再被任何变量引用了，就需要垃圾回收。

随着越来越多的对象进入老年代，一旦老年代满了，就要对老年代垃圾回收。具体细节后面学习！

**对象内存分配相关的其他机制**

\+ 新生代垃圾回收后，存活对象太多，导致大量对象进入老年代；

\+ 特别大的对象不经过新生代直接就进入老年代

\+ 动态对象年龄判断机制

\+ 空间担保机制等

**总结**

对象优先分配在新生代；

新生代对象满了会触发Minor GC，回收掉不被引用的垃圾对象；

对象躲过十多次垃圾回收就会进入老年代；

老年代也满了也会触发垃圾回收，回收掉老年代里不被引用的垃圾对象。

##  JVM回收垃圾对象的情况

Java系统运行创建的对象都是优先分配在新生代里的，随着新生代的对象越来越多，快满了，此时就会触发垃圾回收，把新生代不被引用的对象回收掉，释放内存空间，这就是新生代的垃圾回收触发时机。

**被哪些变量引用的对象是不能回收的？**

一旦新生代快满了，那么垃圾回收时，哪些对象是可以回收的，哪些对象是不能回收的呢？

JVM使用了一种可达性分析算法来判定对象是否可以被回收，具体是指对每个对象都分析一下有谁在引用它，然后一层一层往上去判断，看是否有一个GC Roots。只要对象被GC Roots引用了，就不会去回收它。

在JVM规范中，局部变量、类的静态变量等是可以作为GC Roots的。

**Java中不同的引用类型**

强引用、软引用、弱引用、虚引用

强引用代码如下：

```java
public class Kafka {
  public static ReplicaManager replicaManager = new ReplicaManager();
}
```

这就是最普通的代码，一个变量引用一个对象，只要是强引用类型，垃圾回收时绝对不会回收该对象。

------

软引用代码如下：

```java
public class Kafka {
  public static SoftReference<ReplicaManager> replicaManager = new SoftReference<ReplicaManager>(new ReplicaManager());
}
```

ReplicaManager实例对象用一个SoftReference软引用类型的对象包裹起来了，此时replicaManager变量对ReplicaManager对象的引用就是软引用。

正常情况下，不会回收软引用对象，但是如果进行垃圾回收后，发现内存空间还是不够存放新对象（内存快溢出了），此时就会回收软引用指向的对象（哪怕对象被变量引用了，但因为是软引用，所以还是要回收）。

------

弱引用的代码如下：

```java
public class Kafka {
  public static WeakReference<ReplicaManager> replicaManager = new WeakReference<ReplicaManager>(new ReplicaManager());
}
```

弱引用跟没引用类似，如果发生垃圾回收，就会把这个对象回收掉。

------

虚引用暂时忽略，很少使用。

其实最常用的是强引用和软引用，强引用代表绝对不能回收的对象，软引用指有的对象可有可无，如果内存实在不够了，可以回收它。

**finalize()方法的作用**

至此我们知道了，GC Roots引用的对象不能回收，无GC Roots引用的对象可以回收，如果有GC Roots引用，但是引用类型为软引用或弱应用，也可能被回收掉。

思考：假如对象没有GC Roots引用，是否一定立马被回收呢？

其实不是的，finalize()方法可以拯救它自己，代码如下：

```java
public class ReplicaManager {
  public static ReplicaManager instance;
  
  @override
  protected void finalize() throws Throwable {
    ReplicaManager.instance = this;
  }
}
```

假设ReplicaManager对象要被垃圾回收了，但该类重写了Object类的finalize()方法，此时会先尝试调用一下finalize()方法，看是否有GC Roots变量引用了自己这个实例对象（上面的代码中ReplicaManager类的静态变量就引用了其自己），如果GC Roots变量重新引用了自己，那么就不用被回收了。

finalize()很少用，了解即可。

**思考：如果垃圾回收，会回收ReplicaFetcher对象吗？**

```java
public class Kafka {
  public static ReplicaManager replicaManager = new ReplicaManager();
}

class ReplicaManager {
  public ReplicaFetcher replicaFetcher = new ReplicaFetcher();
}
```

解答：

明显不会，因为ReplicaFetcher对象被ReplicaManager对象中的实例变量引用了，而ReplicaManager对象被Kafka类的静态变量引用了。所以垃圾回收时，是不会回收掉ReplicaFetcher的，否则让存活下来的ReplicaManager对象情何以堪？

## 新生代的垃圾回收算法

这里我们可以明确给出答案是复制算法。

### 复制算法的引入

简单来说，首先把新生代的内存分成两块，假设随着代码的运行，大量的对象都分配在了新生代内存的其中一块内存区域（其实也只会分配在这块区域里），而且分配过后，这些对象很快就失去了局部变量或类静态变量的引用，成为了垃圾对象。

这个时候，新生代中这块分配对象的内存区域基本快满了，再次分配对象时，发现里面的内存空间不够了，此时就会触发Minor GC回收掉新生代被使用的内存空间中的垃圾对象。

### 一种不太好的垃圾回收思路

这种垃圾回收思路是标记出哪些对象是可以被垃圾回收的，然后直接对被使用的那块内存区域中的对象进行回收，把内存空出来。

![image-20210813165944128](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20210813165944128.png)

如上图所示，被使用的那块内存区域回收掉了大量的垃圾对象，但保留了一些被引用的存活对象，但是存活对象在内存里东一个西一个，非常凌乱，造成了大量的内存碎片。

内存碎片太多会造成内存浪费，很多内存碎片压根儿是没法使用的。比如现在打算在上图被使用的那块内存区域里去分配一个新对象，如下图所示，可能因为内存碎片太多，虽然所有的内存碎片加起来有很大一块内存，但是因为这些内存都是碎片式分散的，导致没有一块完整的足够的内存空间来分配新对象。

![image-20210813171315993](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20210813171315993.png)

因此，这种直接对一块内存空间回收掉垃圾对象，保留存活对象的方法，绝对是不可取的。

综上，当前垃圾回收思路最大的问题是内存碎片太多，很多内存碎片压根没法使用，造成大量的内存浪费。

### 一种合理的垃圾回收思路

首先，在正在使用的那块内存空间中（内存1）标记出不能被垃圾回收的对象（存活对象），然后把这些存活对象转移到另一块空白的内存中（内存2），这些对象都比较紧凑的排列在内存2里，该内存区域几乎没有什么内存碎片，这样就多出来一大块连续可用的内存空间，此时就可以将新对象分配在这块连续内存空间了。

![image-20211114222838758](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211114222838758.png)

然后，再一次性把内存1中的垃圾对象全部回收掉，空出来内存1整块区域。

所谓“**复制算法**”，就是把新生代内存划分为两块，然后只使用其中一块内存，待内存1快满时，就把里面的存活对象一次性转移到内存2，保证内存2没有内存碎片，然后一次性回收内存1中的垃圾对象，这样就空出来一块内存区域。两块内存区域就这样重复着循环使用。

这样的复制算法的缺点是自始至终只有一半的内存可以用，显然对内存的使用效率太低了。

### 复制算法的优化

JVM内存使用模型：我们的代码不停创建对象，分配在新生代中（一般绝大多数对象存活非常短，随着一些方法执行完毕，很快就不被引用了，成了垃圾对象），一段时间后新生代就满了，此时就会触发一次Minor GC回收掉垃圾对象，空出来的内存给后续对象使用。

一次新生代垃圾回收过后，99%的对象可能都被垃圾回收了，只有1%的对象存活了下来（一些长期存活或还没使用完的对象），所有实际上真正的复制算法会进行优化，把新生代内存区域分为三块：

+ 1个Eden区、2个Survivor区，其中三者的比例是8:1:1。平时可以使用的是Eden区和一块Survior区，相当于90%的内存是可以使用的。
+ 刚开始对象都分配在Eden区，如果Eden区快满了，就会触发Minor GC，把Eden区的存活对象一次性转移到一块空的Survior区（s1）。然后，Eden区就会被清空，之后就可以再次分配新对象到Eden区。
+ 如果Eden区又满了，那么再次触发Minor GC，就会把Eden区和s1区内的存活对象转移到另一块Survior区中（s2）。最后，一次性把Eden区和s1中的垃圾对象全部回收掉。
+ 接下来，新对象继续分配在Eden区和后来被使用的Survior区(s2)，始终保持一块Survior区是空着的，就这样一直循环使用这三块内存区域。

优化后的复制算法，无论垃圾回收的性能，内存碎片的控制，还是内存使用率都非常好。

### 思考

1. 如果垃圾回收过后，存活下来的对象超过了10%的内存空间，在另一块Survior区放不下咋办？
2. 如果突然分配了一个超级大的对象，新生代找不到连续内存来存放，怎么办？

## 老年代的垃圾回收算法

### 新生代对象什么情况下会进入老年代？

前面提到，系统中的有些对象是长期存在的，它是不会轻易被回收掉的。比如，下面的代码：

```java
public class Kafka {
  private static ReplicaManager replicaManager = new ReplicaManager();
}
```

只要Kafka类存在，它的静态变量replicaManager就会长期引用ReplicaManager对象，所以无论新生代怎么垃圾回收，这种对象都不会被回收掉。

这种对象每次在新生代里躲过一次Minor GC（被转移到一块Survivor区中），它的年龄就会增长一岁。默认情况下，躲过15次Minor GC时就会转移到老年代中。

> -XX:MaxTenuringThreshold：躲过多少次Minor GC后进入老年代，默认15岁

### 动态对象年龄判断

正常情况下，年轻代空间里边的对象熬过MaxTenuringThreshold才会进入老年代，但是如果在一个survivor空间中 年龄1+年龄2+年龄3+...年龄n（年龄1到n逐渐增大，n>1）这些对象大小的总和超过了该survivor空间的一半，那么年龄大于或等于该年龄n的对象就会直接进入老年代，不需要熬过那么多年。这就是所谓的【动态年龄判断】规则，这条规则会让一些新生代的对象进入老年代。

> 验证请参考：[实验: 动态对象年龄判定 ](https://www.cnblogs.com/mushishi/p/14546665.html)

其实，无论是15岁的规则，还是动态年龄判断的规则，都是希望那些可能是长期存活的对象尽早进入老年代。

> 【注意】：动态年龄判断的触发是在新生代GC后，要转移存活对象进入S0或S1前。所以，第一次新生代GC后两块Survivor区肯定都是空闲的，不满足动态年龄判断的，所以只要能满足放入Survivor的条件，第一次新生代GC后的存活对象不会进入老年代。

### 大对象直接进入老年代

另一个对象进入老年代的规则：如果创建一个大于指定大小的对象（比如一个超大的数组），就直接把这个大对象放到老年代里，压根不会经过新生代。

> 这里的指定大小可以通过-XX:PretenureSizeThreshold设定

这样做可以避免新生代中出现大对象，然后多次躲过Minor GC，还得把它在两个survivor区域来回复制多次之后才能进入老年代，耗费时间。

### Minor GC后的对象太多无法放入survivor区

如果在发生Minor GC时，发现存活对象太多，没办法放入另一块survior区，这时就必须把这些对象直接转移到老年代中。

### 老年代空间分配担保规则

上面提到，如果新生代中有大量对象存活下来，survivor区放不下了，就必须转移到老年代去。那如果老年代的空间也不够放这些对象，怎么办呢？

在执行任何一次Minor GC前，JVM会先检查【老年代可用的内存空间是否大于新生代所有对象的总大小】。

> 之所以检查是因为，在最极端的情况下，新生代发生Minor GC后，可能所有对象都存活下来了，survivor区放不下，那岂不是新生代所有对象都要进入老年代？

+ 如果老年代内存大小 > 新生代的所有对象的总大小，此时就可以对新生代发起一次Minor GC（即使Minor GC后所有对象都存活，survivor区放不下了，也可以转移到老年底去）。
+ 如果老年代可用内存 < 新生代的全部对象大小，看是否设置了-XX:HandlePromotionFailure
  + 如果有这个参数，看看老年代内存大小是否大于之前每次Minor GC后进入老年代的对象的平均大小
    + 如果老年代内存大小 < 每次Minor GC后进入老年代对象的平均大小，直接触发一次Full GC，然后再执行Minor GC
    + 如果老年代大小满足，尝试进行Minor GC，有以下三种结果：
      1. Minor GC过后，剩余存活对象的大小小于survior区的大小，此时存活对象进入survivor区域即可；
      2. Minor GC过后，剩余存活对象的大小，大于survivor区域的大小，但小于老年代可用内存大小，此时直接进入老年代即可；
      3. 很不幸，Minor GC过后，剩余存活的对象大小，大于survivor区域的大小，也大于老年代可用空间的大小（老年代放不下这些对象，发生“Handle Promotion Failure”），这时就会触发一次Full GC。
  + 如果没有这个参数，直接触发一次Full GC，然后再执行Minor GC

Full GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，此时就会导致OOM内存溢出（内存实在不够了，还要不停往里面放对象，当然就崩溃了）。

> Full GC，就是对老年代进行垃圾回收，尽量腾出一些内存空间，同时一般也会对新生代进行垃圾回收。因为必须得把老年代中不被引用的对象回收掉，Minor GC后剩余的存活对象才可能进入老年代里。

### 老年代的垃圾回收算法

从上文可知，Minor GC之前要对老年代空间进行检查，因此出现了老年代触发Full GC的时机：

+ 在Minor GC之前，一通检查发现很可能Minor GC后要进入老年代的对象太多了，老年代放不下，此时需要提前触发Full GC，给老年代腾出一些空间，然后再进行Minor GC
+ 在Minor GC之后，发现剩余对象太多，放入老年代内存不够，也会触发Full GC。

老年代的垃圾回收采用的是【标记整理算法】。

这个过程比较简单，首先标记出老年代当前存活的对象（这些对象可能东一个西一个）；然后让这些存活对象在内存里进行移动，把存活对象紧凑的靠在一起，避免垃圾回收过后出现过多的内存碎片；最后再一次性把垃圾对象都回收掉。

> 注意：老年代的垃圾回收速度至少比新生代的垃圾回收速度慢10倍，如果系统频繁出现老年代的Full GC，会导致系统出现频繁卡顿的情况，严重影响系统性能。
>
> 后面会用各种案例分析，在各种业务系统生产故障下，到底为什么频繁的Full GC，然后怎样一步步调整JVM的各种参数进行优化。

至此，你应该明白：

所谓JVM优化就是尽可能让对象都在新生代里分配和回收，同时给系统充足的内存大小，避免新生代频繁进行垃圾回收；尽量别让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收。

GC的全流程：

+ 什么时候触发Minor GC？
+ 触发Minor GC之前如何检查老年代大小？
+ 什么时候在Minor GC之前就提前触发一次Full GC?
+ Full GC的算法是什么？
+ Minor GC过后可能对应哪几种情况？
+ 哪些情况下Minor GC后的对象会进入老年代？

希望你最好通过画图的形式，把这个过程梳理出来，对这个过程的透彻理解是后续进行JVM优化实战的核心基石。







