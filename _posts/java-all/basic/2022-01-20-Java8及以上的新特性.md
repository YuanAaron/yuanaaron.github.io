---
layout: post 
author: oshacker
title: Java8及以上的新特性
category: basic
tags: [java,basic]
excerpt: 归纳整理一些实用的新特性
---

# Java8

## Lambda 表达式

- [ ] [关于 Java Lambda 表达式看这一篇就够了](https://mp.weixin.qq.com/s/TddZZEyMispsB2PqZyFQMw)

## Java8 中的 Stream

先贴上几个案例，水平高超的同学可以挑战一下：

+ 从员工集合中筛选出 salary 大于 8000 的员工，并放置到新的集合里。
+ 统计员工的最高薪资、平均薪资、薪资之和。
+ 将员工按薪资从高到低排序，同样薪资者年龄小者在前。
+ 将员工按性别分类，将员工按性别和地区分类，将员工按薪资是否高于 8000 分为两部分。

用传统的迭代处理也不是很难，但代码就显得冗余了，跟 Stream 相比高下立判。

### Stream 概述

Java8 新增的 Stream，配合同版本出现的 Lambda，给我们操作集合（Collection）提供了极大的便利。

Stream 将要处理的元素集合看作一种流，借助 Stream API 对流中的元素进行操作，比如：筛选、排序、聚合等。

Stream 可以由数组或集合创建，对流的操作分为两种：

1. 中间操作：每次返回一个新的流，可以有多个中间操作；
2. 终端操作：每个流只能进行一次终端操作，终端操作结束后流无法再次使用。终端操作会产生一个新的集合或值。

另外，Stream 有几个特性：

1. Stream 不存储数据，而是按照特定的规则对数据进行计算，一般会输出结果；
2. Stream 不会改变数据源，通常情况下会产生一个新的集合或值；
3. Stream 具有延迟执行特性，只有调用终端操作时，中间操作才会执行。

### Stream 的创建

1. 通过 java.util.Collection.stream() 方法用集合创建流

   ```java
   String[] strs = {"a", "b", "c"};
   List<String> list = Arrays.asList(strs);
   // 创建一个顺序流
   Stream<String> stream = list.stream();
   // 创建一个并行流
   Stream<String> parallelStream = list.parallelStream();
   ```

2. 通过 java.util.Arrays.stream(T[] array) 方法用数组创建流

   ```java
   int[] ints = {1, 3, 5, 6, 8};
   String[] strs = {"a", "b", "c"};
   IntStream stream1 = Arrays.stream(ints);
   Stream<String> stream2 = Arrays.stream(strs);
   ```

3. 使用 Stream 的静态方法：of()、iterate()、generate()

   ```java
   int[] ints = {1, 2, 3, 4, 5, 6};
   Integer[] arr = {1, 2, 3, 4, 5, 6};
   Stream<int[]> stream1 = Stream.of(ints);
   Stream<Integer> stream2 = Stream.of(arr);
   
   Stream<Integer> stream3 = Stream.iterate(0, (x) -> x + 3).limit(4);
   //stream3.forEach(x -> System.out.println(x));
   stream3.forEach(System.out::println);
   
   //Stream<Double> stream4 = Stream.generate(() -> Math.random()).limit(3);
   Stream<Double> stream4 = Stream.generate(Math::random).limit(3);
   stream4.forEach(System.out::println);
   ```

> 1. Stream 和 ParallelStream 的简单区分：Stream 是顺序流，由主线程按顺序对流执行操作；ParallelStream 是并行流，内部以多线程并行执行的方式对流进行操作，前提是流中的数据处理没有顺序要求，比如筛选集合中的奇数，两者的不同在于：
>
> ![image-20220120232213844](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20220120232213844.png)
>
> 如果流中的数据量足够大，并行流可以加快处理速度。
>
> 2. 除了直接创建并行流，还可以通过 Parallel() 把顺序流转换成并行流：
>
> ```java
> List<Integer> list = Arrays.asList(1, 2, 3, 5, 9, 7, 4, 3, 8, 6, 2, 5);
> Optional<Integer> first = list.stream().parallel().filter(x -> x > 6).findFirst();
> System.out.println(first.get());
> ```

### Stream的使用

在使用 Stream 之前，先理解一个概念：Optional。

> Optional 类是一个可以为 null 的容器对象。如果值存在，则 isPresent() 方法会返回 true，调用 get() 方法会返回该对象。

**案例使用的员工类**

```java
class Person {
	private String name;  // 姓名
	private int salary; // 薪资
	private int age; // 年龄
	private String sex; //性别
	private String area;  // 地区

	// 构造方法
	public Person(String name, int salary, int age,String sex,String area) {
		this.name = name;
		this.salary = salary;
		this.age = age;
		this.sex = sex;
		this.area = area;
	}
	// 省略了get和set，请自行添加

}
```

#### 遍历/匹配 （foreach/find/match）

Stream 也是支持类似集合的遍历和匹配元素的，只是 Stream 中的元素以 Optional 类型存在。Stream 的遍历、匹配非常简单。

```java
List<Integer> list = Arrays.asList(7, 6, 9, 3, 8, 2, 1);

// 遍历输出符合条件的元素
list.stream().filter(x -> x > 6).forEach(System.out::println);

// 匹配第一个
Optional<Integer> first = list.stream().filter(x -> x > 6).findFirst();
// 匹配任意（适用于并行流）
Optional<Integer> any = list.parallelStream().filter(x -> x > 6).findAny();
// 是否包含特定条件的元素
boolean b = list.stream().anyMatch(x -> x > 6);
System.out.println("匹配第一个值：" + first.get());
System.out.println("匹配任意一个值：" + any.get());
System.out.println("是否存在大于6的值：" + b);
```

#### 筛选（filter）

筛选是按照一定的规则校验流中的元素，将符合条件的元素提取到新的流中的操作。

**案例一：筛选出 Integer 集合中大于 7 的元素，并打印出来**

```java
public static void main(String[] args) {
    List<Integer> list = Arrays.asList(6, 7, 3, 8, 1, 2, 9);
    list.stream().filter(x -> x > 7).forEach(System.out::println);
}
```

**案例二：筛选员工中工资高于 8000 的人，并形成新的集合（形成新集合依赖 collect（集合），后文有详细介绍）。**

```java
public static void main(String[] args) {
    List<Person> personList = new ArrayList<Person>();
    personList.add(new Person("Tom", 8900, 23, "male", "New York"));
    personList.add(new Person("Jack", 7000, 25, "male", "Washington"));
    personList.add(new Person("Lily", 7800, 21, "female", "Washington"));
    personList.add(new Person("Anni", 8200, 24, "female", "New York"));
    personList.add(new Person("Owen", 9500, 25, "male", "New York"));
    personList.add(new Person("Alisa", 7900, 26, "female", "New York"));

//    List<String> filterList = personList.stream().filter(x -> x.getSalary() > 8000).map(person -> person.getName()).collect(Collectors.toList());
    List<String> filterList = personList.stream().filter(x -> x.getSalary() > 8000).map(Person::getName).collect(Collectors.toList());
    System.out.println("高于8000的员工姓名：" + filterList);
}
```

#### 聚合（max/min/count）

在MySQL中，我们常用max、min、count进行数据统计，Java Stream 中也引入了这些概念和用法，极大地方便了我们对集合、数组的数据统计工作。 

**案例一：获取 String 集合中最长的元素。**

```java
public static void main(String[] args) {
  	List<String> list = Arrays.asList("adnm", "admmt", "pot", "xbangd", "weoujgsd");

//    Optional<String> max = list.stream().max(Comparator.comparing(x -> x.length()));
//        Optional<String> max = list.stream().max(Comparator.comparing(String::length));

//        Optional<String> max = list.stream().max(new Comparator<String>() {
//            @Override
//            public int compare(String o1, String o2) {
//                return o1.length() - o2.length();
//            }
//        });
//        Optional<String> max = list.stream().max((o1, o2) -> o1.length() - o2.length());
  	Optional<String> max = list.stream().max(Comparator.comparingInt(String::length));

  	System.out.println("最长的字符串是：" + max.get());
}
```

**案例二：获取 Integer 集合中的最大值**

```java
public static void main(String[] args) {
    List<Integer> list = Arrays.asList(7, 6, 9, 4, 11, 6);

//        Optional<Integer> max = list.stream().max(Comparator.comparing(x -> x));

//        Optional<Integer> max = list.stream().max(new Comparator<Integer>() {
//            @Override
//            public int compare(Integer o1, Integer o2) {
//                return o1.compareTo(o2);
//            }
//        });
//        Optional<Integer> max = list.stream().max((o1, o2) -> o1.compareTo(o2));
    Optional<Integer> max = list.stream().max(Integer::compareTo);
  
    System.out.println(max.get());
}
```

**案例三：获取员工工资最高的人**

```java
public static void main(String[] args) {
    List<Person> personList = new ArrayList<Person>();
    personList.add(new Person("Tom", 8900, 23, "male", "New York"));
    personList.add(new Person("Jack", 7000, 25, "male", "Washington"));
    personList.add(new Person("Lily", 7800, 21, "female", "Washington"));
    personList.add(new Person("Anni", 8200, 24, "female", "New York"));
    personList.add(new Person("Owen", 9500, 25, "male", "New York"));
    personList.add(new Person("Alisa", 7900, 26, "female", "New York"));

//        Optional<Person> max = personList.stream().max(Comparator.comparing(person -> person.getSalary()));
  Optional<Person> max = personList.stream().max(Comparator.comparing(Person::getSalary));

//        Optional<Person> max = personList.stream().max(new Comparator<Person>() {
//            @Override
//            public int compare(Person o1, Person o2) {
//                return o1.getSalary() - o2.getSalary();
//            }
//        });
//        Optional<Person> max = personList.stream().max((o1, o2) -> o1.getSalary() - o2.getSalary());
//        Optional<Person> max = personList.stream().max(Comparator.comparingInt(Person::getSalary));
    System.out.println(max.get().getSalary());
}
```

**方案四：计算 Integer 集合中大于 6的元素的个数**

```java
public static void main(String[] args) {
    List<Integer> list = Arrays.asList(7, 6, 4, 8, 2, 11, 9);
    long count = list.stream().filter(x -> x > 6).count();
    System.out.println("大于6的元素个数：" + count);
}
```

#### 映射（map/flatMap）

映射可以将一个流的元素按照一定的映射规则映射到另一个流中，分为 map 和 flatMap：

+ map：接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素；
+ flatMap：接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流。

**案例一：将英文字符串数组的元素全部改为大写；整数数组每个元素 + 3。**

```java
public static void main(String[] args) {
    String[] strArr = {"abcd", "bcdd", "defde", "fTr"};
    List<String> strList = Arrays.stream(strArr).map(String::toUpperCase).collect(Collectors.toList());
    System.out.println("每个元素大写：" + strList);

    List<Integer> intList = Arrays.asList(1, 3, 5, 7, 9, 11);
    List<Integer> intListNew = intList.stream().map(x -> x + 3).collect(Collectors.toList());
    System.out.println("每个元素 + 3：" + intListNew);
}
```

**案例二：将员工的薪资全部增加1000**

```java
public static void main(String[] args) {
    List<Person> personList = new ArrayList<Person>();
    personList.add(new Person("Tom", 8900, 23, "male", "New York"));
    personList.add(new Person("Jack", 7000, 25, "male", "Washington"));
    personList.add(new Person("Lily", 7800, 21, "female", "Washington"));
    personList.add(new Person("Anni", 8200, 24, "female", "New York"));
    personList.add(new Person("Owen", 9500, 25, "male", "New York"));
    personList.add(new Person("Alisa", 7900, 26, "female", "New York"));

    // 不改变原来员工集合的方式
    List<Person> personListNew = personList.stream().map(person -> {
      Person personNew = new Person(person.getName(), person.getSalary(), 0, null, null);
      personNew.setSalary(person.salary + 1000);
      return personNew;
    }).collect(Collectors.toList());
    System.out.println("一次改动前：" + personList.get(0).getName() + "--->" + personList.get(0).getSalary());
    System.out.println("一次改动后：" + personListNew.get(0).getName() + "--->" + personListNew.get(0).getSalary());

    // 改变原来员工集合的方式
    List<Person> personListNew1 = personList.stream().map(person -> {
      person.setSalary(person.getSalary() + 1000);
      return person;
    }).collect(Collectors.toList());
    System.out.println("二次改动前：" + personList.get(0).getName() + "--->" + personList.get(0).getSalary());
    System.out.println("二次改动后：" + personListNew1.get(0).getName() + "--->" + personListNew1.get(0).getSalary());

}
```

**案例三：map 和 flatMap 比较**

```java
public static void main(String[] args) {
  	List<String> list = Arrays.asList("Hello Java","Hello Python");
    List<String> list2 = list.stream().flatMap(str -> {
      // 将每个元素转换成一个Stream
      String[] strArr = str.split(" ");
      return Arrays.stream(strArr);
    }).collect(Collectors.toList());
    list2.forEach(System.out::println);
  
   	// 如果使用 map 则需要这样写
    List<Stream<String>> list1 = list.stream().map(str -> {
      // 将每个元素转换成一个Stream
      String[] strArr = str.split(" ");
      return Arrays.stream(strArr);
    }).collect(Collectors.toList());

    //list1.forEach(System.out::println); //并非所预期的结果
    list1.forEach(x -> x.forEach(System.out::println)); //预期的结果
}
```

#### 归约（reduce）

归约（缩减）是把一个流缩减成一个值，能实现对集合求和、乘积和最值操作。

**案例一：求 Integer 集合的元素之和、乘积和最大值。**

```java
public static void main(String[] args) {
    List<Integer> list = Arrays.asList(1, 3, 2, 8, 11, 4);
    // 求和方法一：未定义初始值，从而第一次执行的时候reduce的第一个参数的值是Stream的第一个元素，第二个参数是Stream的第二个元素
//        Optional<Integer> sumOptional = list.stream().reduce((x, y) -> x + y);
    Optional<Integer> sumOptional = list.stream().reduce(Integer::sum);
    System.out.println(sumOptional.get());
    // 求和方法二：定义了初始值，从而第一次执行的时候reduce的第一个参数的值是初始值，第二个参数是Stream的第一个元素
    Integer sum2 = list.stream().reduce(0, Integer::sum);
    System.out.println(sum2);

    // 求乘积
    Optional<Integer> productOptional = list.stream().reduce((x, y) -> x * y);
    System.out.println(productOptional.get());

    // 求最大值
    Optional<Integer> maxOptional = list.stream().reduce((x, y) -> x > y ? x : y);
    System.out.println(maxOptional.get());
//        Integer max = list.stream().reduce(0, (x, y) -> x > y ? x : y);
    Integer max = list.stream().reduce(0, Integer::max);
    System.out.println(max);
}
```

**案例二：求所有员工的工资之和与最高工资**

```java
public static void main(String[] args) {
    List<Person> personList = new ArrayList<Person>();
    personList.add(new Person("Tom", 8900, 23, "male", "New York"));
    personList.add(new Person("Jack", 7000, 25, "male", "Washington"));
    personList.add(new Person("Lily", 7800, 21, "female", "Washington"));
    personList.add(new Person("Anni", 8200, 24, "female", "New York"));
    personList.add(new Person("Owen", 9500, 25, "male", "New York"));
    personList.add(new Person("Alisa", 7900, 26, "female", "New York"));

    // 求工资之和方式1
//        Optional<Integer> sumOptional = personList.stream().map(person -> person.getSalary()).reduce((x, y) -> x + y);
    Optional<Integer> sumOptional = personList.stream().map(Person::getSalary).reduce(Integer::sum);
    System.out.println(sumOptional.get());
		// 求工资之和方式2
//        Integer sumSalary = personList.stream().reduce(0, (sum, p) -> {
//            sum += p.getSalary();
//            return sum;
//        }, (sum1, sum2) -> {
//            return sum1 + sum2;
//        });
//        Integer sumSalary = personList.stream().reduce(0, (sum, p) -> sum += p.getSalary(), (sum1, sum2) -> sum1 + sum2);
    Integer sumSalary = personList.stream().reduce(0, (sum, p) -> sum += p.getSalary(), Integer::sum);
    System.out.println(sumSalary);

  	// 求最高工资
//        Integer maxSalary = personList.stream().reduce(0, (max, p) -> max = max >= p.getSalary() ? max : p.getSalary(), (max1, max2) -> max1 >= max2 ? max1 : max2);
  	Integer maxSalary = personList.stream().reduce(0, (max, p) -> max = max >= p.getSalary() ? max : p.getSalary(), Integer::max);
  	System.out.println(maxSalary);
}
```

> 有三个参数的reduce()方法如下：
>
> ```java
> <U> U reduce(U identity,
>                  BiFunction<U, ? super T, U> accumulator,
>                  BinaryOperator<U> combiner);
> ```
>
> 通过对比，对reduce方法的第三个参数有更加深入的理解：
>
> ```java
> Integer sumRes = personList.stream().reduce(0, (sum, p) -> {
>         System.out.println("sum= " + sum + " name=" + p.getName() + " salary=" + p.getSalary());
>         sum += p.getSalary();
>         System.out.println("sum= " + sum);
>         return sum;
>       }, (sum1, sum2) -> {
>         System.out.println("sum1=" + sum1 + " sum2=" + sum2 + " sum1+sum2=" + (sum1+sum2));
>         return sum1 + sum2;
>       });
> System.out.println(sumRes);
> 
> // 使用stream()的结果为：
> sum= 0 name=Tom salary=8900
> sum= 8900
> sum= 8900 name=Jack salary=7000
> sum= 15900
> sum= 15900 name=Lily salary=7800
> sum= 23700
> sum= 23700 name=Anni salary=8200
> sum= 31900
> sum= 31900 name=Owen salary=9500
> sum= 41400
> sum= 41400 name=Alisa salary=7900
> sum= 49300
> 49300
>   
> // 将stream()换成ParallelStream()的结果为：
> sum= 0 name=Tom salary=8900
> sum= 0 name=Alisa salary=7900
> sum= 0 name=Owen salary=9500
> sum= 9500
> sum= 0 name=Lily salary=7800
> sum= 7800
> sum= 0 name=Jack salary=7000
> sum= 0 name=Anni salary=8200
> sum= 8200
> sum= 7000
> sum= 7900
> sum1=9500 sum2=7900 sum1+sum2=17400
> sum= 8900
> sum1=8200 sum2=17400 sum1+sum2=25600
> sum1=7000 sum2=7800 sum1+sum2=14800
> sum1=8900 sum2=14800 sum1+sum2=23700
> sum1=23700 sum2=25600 sum1+sum2=49300
> 49300
> ```
>
> 从上面两个结果对比可以知道：使用stream()方法时，reduce()的第三个参数不会执行；使用parallelStream()时，reduce()方法的第三个参数会执行，原因是[如果使用了parallelStream，reduce操作是并发进行的，为了避免竞争，每个reduce方法都会有独立的result，combiner的作用是合并每个线程的result得到最终结果](https://www.zhihu.com/question/35451347?q=Stream%20%E7%9A%84%20reduce)。

#### 收集（collect）

collect（收集）就是把一个流收集起来，最终收集成一个值/新集合。collect 主要依赖 java.util.stream.Collectors 类内置的静态方法。

##### 归集（toList/toSet/toMap）

因为流不存储数据，那么在流中的数据完成处理后，需要将流中的数据重新归集到新集合中。toList、toSet、toMap比较常用，另外还有toCollection、toConcurrentMap等复杂一些的用法。

```java
public static void main(String[] args) {
    List<Integer> list = Arrays.asList(1, 6, 3, 4, 6, 7, 9, 6, 20);
    List<Integer> listNew = list.stream().filter(x -> x % 2 == 0).collect(Collectors.toList());
    System.out.println("toList:" + listNew);
    Set<Integer> set = list.stream().filter(x -> x % 2 == 0).collect(Collectors.toSet());
    System.out.println("toSet:" + set);

    List<Person> personList = new ArrayList<>();
    personList.add(new Person("Tom", 8900, 23, "male", "New York"));
    personList.add(new Person("Jack", 7000, 25, "male", "Washington"));
    personList.add(new Person("Lily", 7800, 21, "female", "Washington"));
    personList.add(new Person("Anni", 8200, 24, "female", "New York"));

    Map<String, Integer> map = personList.stream().filter(p -> p.getSalary() > 8000)
      .collect(Collectors.toMap(Person::getName, Person::getSalary));
    System.out.println("toMap:" + map);
}
```

##### 统计（count/averaging）

Collectors 提供了一系列用于数据统计的静态方法：

+ 计数：counting;
+ 平均值：averagingInt、averagingLong、averagingDouble
+ 最值：maxBy、minBy
+ 求和：summingInt、summingLong、summingDouble
+ 统计以上所有：summarizingInt、summerizingLong、summarizingDouble

**案例：统计员工人数、平均工资、最高工资、工资总额**

```java
public static void main(String[] args) {
    List<Person> personList = new ArrayList<Person>();
    personList.add(new Person("Tom", 8900, 23, "male", "New York"));
    personList.add(new Person("Jack", 7000, 25, "male", "Washington"));
    personList.add(new Person("Lily", 7800, 21, "female", "Washington"));

    // 求总数
//        Long count = personList.stream().collect(Collectors.counting());
    Long count = personList.stream().count();
    System.out.println(count);

    // 求平均工资
    Double average = personList.stream().collect(Collectors.averagingDouble(Person::getSalary));
    System.out.println(average);

    // 求最高工资
//        Optional<Integer> max = personList.stream().map(Person::getSalary).collect(Collectors.maxBy((s1, s2) -> (s1 - s2)));
//        Optional<Integer> max = personList.stream().map(Person::getSalary).max((s1, s2) -> (s1 - s2));
    Optional<Integer> max = personList.stream().map(Person::getSalary).max(Comparator.comparingInt(s -> s));
    System.out.println(max.get());

    // 求工资之和
//        Integer sum = personList.stream().collect(Collectors.summingInt(Person::getSalary));
    Integer sum = personList.stream().mapToInt(Person::getSalary).sum();
    System.out.println(sum);

    // 一次性统计所有信息
    DoubleSummaryStatistics summary = personList.stream().collect(Collectors.summarizingDouble(Person::getSalary));
    System.out.println(summary);
}
```

##### 分组（partitioningBy/groupBy）

分区：将 Stream 按条件分为两个 Map，比如员工按薪资是否高于8000分为两部分；

分组：将集合分为多个Map，比如员工按性别分组，有单级分组和多级分组。

**案例：将员工按薪资是否高于8000分为两部分；将员工按性别和地区分组。**

```java
public static void main(String[] args) {
    List<Person> personList = new ArrayList<>();
    personList.add(new Person("Tom", 8900, 23,"male", "New York"));
    personList.add(new Person("Jack", 7000, 24, "male", "Washington"));
    personList.add(new Person("Lily", 7800, 25, "female", "Washington"));
    personList.add(new Person("Anni", 8200, 26, "female", "New York"));
    personList.add(new Person("Owen", 9500, 27, "male", "New York"));
    personList.add(new Person("Alisa", 7900, 28, "female", "New York"));

    // 将员工按薪资是否高于8000分区
//        Map<Boolean, List<Person>> part = personList.stream().collect(Collectors.partitioningBy(x -> x.getSalary() > 8000));
    Map<Boolean, List<Integer>> part = personList.stream().map(Person::getSalary).collect(Collectors.partitioningBy(x -> x > 8000));
    System.out.println(part);

    // 将员工先按性别分组，再按照地区分组
    Map<String, Map<String, List<Person>>> group = personList.stream().collect(Collectors.groupingBy(Person::getSex, Collectors.groupingBy(Person::getArea)));
    System.out.println(group);
}
```

##### 接合（joining）

joining 可以将 Stream 中的元素用特定的连接符（没有的话，则直接连接）连接成一个字符串。

```java
public static void main(String[] args) {
    List<Person> personList = new ArrayList<Person>();
    personList.add(new Person("Tom", 8900, 23, "male", "New York"));
    personList.add(new Person("Jack", 7000, 25, "male", "Washington"));
    personList.add(new Person("Lily", 7800, 21, "female", "Washington"));

    String names = personList.stream().map(Person::getName).collect(Collectors.joining("-"));
    System.out.println(names);
}
```

##### 归约（reducing）

Collectors 类提供的 reducing 方法，相比于 stream 本身的 reduce 方法，增加了对自定义归约的支持。

```java
public static void main(String[] args) {
    List<Person> personList = new ArrayList<Person>();
    personList.add(new Person("Tom", 8900, 23, "male", "New York"));
    personList.add(new Person("Jack", 7000, 25, "male", "Washington"));
    personList.add(new Person("Lily", 7800, 21, "female", "Washington"));

    // 所有员工去起征点后的薪资之和
    // Collectors的reducing
//        Integer sum = personList.stream().collect(Collectors.reducing(0, Person::getSalary, (sum1, sum2) -> sum1 + sum2 - 5000));
    // stream的reduce
    Integer sum = personList.stream().map(Person::getSalary).reduce(0, (sum1, sum2) -> sum1 + sum2 - 5000);
    System.out.println(sum);
}
```

#### 排序（sorted)

sorted，中间操作，有两种排序：

+ sorted()：自然排序，流中元素需实现 Comparable 接口；
+ sorted(Comparator com)：Comparator排序器自定义排序

**案例：将员工按工资由高到低排序（如果工资一样，则按年龄由大到小排序）**

```java
public static void main(String[] args) {
    List<Person> personList = new ArrayList<Person>();
    personList.add(new Person("Sherry", 9000, 25, "female", "New York"));
    personList.add(new Person("Tom", 8900, 22, "male", "Washington"));
    personList.add(new Person("Jack", 9000, 24, "male", "Washington"));
    personList.add(new Person("Lily", 8800, 26, "male", "New York"));
    personList.add(new Person("Alisa", 9000, 26, "female", "New York"));

    // 按工资升序排序（自然排序）
//        List<String> newList1 = personList.stream().sorted((p1, p2) -> p1.getSalary() - p2.getSalary()).map(Person::getName).collect(Collectors.toList());
    List<String> newList1 = personList.stream().sorted(Comparator.comparing(Person::getSalary)).map(Person::getName).collect(Collectors.toList());
    System.out.println(newList1);

    // 按工资降序排序
//        List<String> newList2 = personList.stream().sorted((p1, p2) -> p2.getSalary() - p1.getSalary()).map(Person::getName).collect(Collectors.toList());
    List<String> newList2 = personList.stream().sorted(Comparator.comparing(Person::getSalary).reversed()).map(Person::getName).collect(Collectors.toList());
    System.out.println(newList2);

    // 先按工资再按年龄升序排序
//        List<String> newList3 = personList.stream().sorted((p1, p2) -> (p1.getSalary() - p2.getSalary() == 0) ? p1.getAge() - p2.getAge() : p1.getSalary() - p2.getSalary()).map(Person::getName).collect(Collectors.toList());
    List<String> newList3 = personList.stream().sorted(Comparator.comparing(Person::getSalary).thenComparing(Person::getAge)).map(Person::getName).collect(Collectors.toList());
    System.out.println(newList3);

    // 先按工资再按年龄降序排序
    List<String> newList4 = personList.stream().sorted((p1, p2) -> (p1.getSalary() - p2.getSalary() == 0) ? p2.getAge() - p1.getAge() : p2.getSalary() - p1.getSalary()).map(Person::getName).collect(Collectors.toList());
    System.out.println(newList4);
}
```

#### 提取/组合

流也可以进行合并、去重、限制、跳过等操作。

```java
public static void main(String[] args) {
    Stream<String> stream1 = Stream.of("a", "b", "c", "d");
    Stream<String> stream2 = Stream.of("d", "e", "f", "g");

    // concat用于合并两个流，distinct用于去重
    List<String> newList1 = Stream.concat(stream1, stream2).distinct().collect(Collectors.toList());
    System.out.println(newList1);

    // limit用于从流中获取前n个数据
    List<Integer> newList2 = Stream.iterate(1, x -> x + 2).limit(10).collect(Collectors.toList());
    System.out.println(newList2);

    // skip用于跳过前n个数据
    List<Integer> newList3 = Stream.iterate(1, x -> x + 2).skip(1).limit(5).collect(Collectors.toList());
    System.out.println(newList3);
}
```

#### Optional 类

- [ ] https://www.runoob.com/java/java8-optional-class.html

# Java11



# 参考资料

- [x] [Java8 Stream：2万字20个实例，玩转集合的筛选、归约、分组、聚合](https://blog.csdn.net/mu_wind/article/details/109516995)
- [ ] [Java8常用方法，让你的代码更简化](https://blog.csdn.net/IT_hejinrong/article/details/89007056)
- [ ] [从 Java8 到 Java11 再到 Java17 的新特性（1）](https://blog.csdn.net/u012809062/article/details/121230755?spm=1001.2014.3001.5502)
- [ ] [A categorized list of all Java and JVM features since JDK 8 to 17](https://advancedweb.hu/a-categorized-list-of-all-java-and-jvm-features-since-jdk-8-to-17/)
