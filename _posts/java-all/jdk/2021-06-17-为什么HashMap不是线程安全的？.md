---
layout: post 
author: oshacker
title: 为什么HashMap不是线程安全的？
category: jdk
tags: [java,jdk]
excerpt: idea调试
---

HashMap树化：tab.length >= 64 & 链表的长度达到8

红黑树的5个特性：

+ 结点是红色或黑色。

+ 根结点是黑色。

+ 所有叶子都是黑色。（叶子是NIL结点）

+ 每个红色结点的两个子结点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色结点）

+ 从任一节结点到其每个叶子的所有路径都包含相同数目的黑色结点。

## 第一种情况

下面用如下代码调试：

![image-20211215094036749](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215094036749.png)

启动HashMapTest调试，然后选择thread-0线程，Shift+F7调试到如下图所示；thread-1同理。

![image-20211215094122889](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215094122889.png)

接下来，按F8让thread-1先执行resize方法，此时的变量如下图：

![image-20211215094228379](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215094228379.png)

继续让resize方法执行完，此时HashMap中各个变量的值如下图：

![image-20211215094315277](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215094315277.png)

然后选择thread-0线程，同样按F8执行resize方法，此时的变量如下图：

![image-20211215094412352](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215094412352.png)

继续让resize方法执行完，此时HashMap中各个变量的值如下图：

![image-20211215094511981](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215094511981.png)

HashMap中的table值由{HashMap$Node[8]@656}变成了{HashMap$Node[16]@657}，即table实际指向的是后者。

继续让thread-0的put方法执行完，执行完成的结果如下图：

![image-20211215094727100](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215094727100.png)

继续让thread-1的put方法执行完，结果如下图：

![image-20211215094827324](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215094827324.png)

从上图可以看出，hashmap的size=2，但是table中只有一对{1,"1"}，而没有{9,"9"}。

**总结**：
当table==null(没有元素)时，同时插入两个元素，会各自创建一个tab（在resize中实现），且分别在这两个tab中插入元素，但是只有一个tab（后创建的）赋值给了HashMap中的table（在resize中实现），这就出现了线程不安全的行为。

## 第二种情况

下面用如下代码调试：

![image-20211215095015036](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215095015036.png)

采用同样的方法进行调试，thread-0、thread-1先后均调试到如下图所示：

![image-20211215095058979](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215095058979.png)

接下来，按F8让thread-0先执行一步，HashMap的各变量如下：

![image-20211215095150163](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215095150163.png)

同理，按F8让thread-1也执行一步，HashMap的各变量如下：

![image-20211215095239306](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215095239306.png)

接下来，让thread-1的put方法执行完，此时HashMap各变量如下图：

![image-20211215095328588](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215095328588.png)

让thread-0的put方法也执行完，此时HashMap各变量如下图：

![image-20211215095409554](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215095409554.png)

从上图可知，hashmap的size=3，但是只有{17,"17"}和{9,"9"}，而没有{1,"1"}。

**结论**：
当table[i]有元素时，同时在i位置再插入两个元素，可能会导致一个元素被挤掉。

## 第三种情况

下面用如下代码调试：

![image-20211215095515125](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215095515125.png)

导致线程不安全的点如下图所示：

![image-20211215095556482](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215095556482.png)

具体的调试方法和情况2一样，这里不在赘述

**结论**：
当table!=null且table[i]这个下标的位置没有元素，同时在i位置插入两个元素，可能会导致其中一个被挤掉。

## 第四种情况

下面用如下代码调试：

![image-20211215095725862](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215095725862.png)

导致线程不安全的点如下图所示：

![image-20211215095759793](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215095759793.png)

两个线程都调试到上图所示，此时HashMap中的各变量如下：

![image-20211215095848024](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215095848024.png)

直接按F8让thread-0扩容后的HashMap中各变量的值如下：

![image-20211215095940704](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215095940704.png)

再按F8让thread-1扩容后HashMap中各变量的值如下：

![image-20211215100024849](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215100024849.png)

从上面两张图可知，8个元素扩容了两次（32），但实际上只需要扩容一次（16）就可以了，但是数据没有出现问题。

**结论**：
当元素的数量已经达到了扩容门槛时，再同时插入两个元素，可能会导致扩容两次。

## 第五种情况

同样是上面的代码，但是运行到上面的线程不安全点后，不要直接按F8，而是进入resize方法，还有另一个不安全点，两个线程都调试到这里如下图：

![image-20211215100213788](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215100213788.png)

也会进行两次扩容，但table的容量为16，没有出现32，继续让thread-0的put方法执行完，结果与情况四中thread-0的put方法执行完时类似，接下来，让thread-1的put方法执行完，结果是table的所有元素都为null（thread-0的resize方法执行完后，oldTab中的数据被转移到了thread-0的newTab中，且oldTab被清空，因此oldTab中的元素无法转入thread-1的newTab，而该newTab又最终赋给了HashMap的table，因此导致整个HashMap被清空）。最终打印的结果为{}，即map中没有任何元素。

**结论**：

当元素的数量已经达到了扩容门槛时，再同时插入两个元素，可能会导致整个map被清空。

此外，还会有其他线程不安全的点，可以自己多调试。
