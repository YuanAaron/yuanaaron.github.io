---
layout: post 
author: oshacker
title: 基本调试方法
category: jdk
tags: [java,jdk]
excerpt: idea调试
---

很久以前，在学习C++时，听侯捷说过这样一句话：「源码之前，了无秘密」。可见，如果能读懂源码，各种难题就将迎刃而解，自己的能力也会有本质的提升。但读懂源码确实是一个难题，接下来，我将按照彤哥的思路，采用调试的方法尝试去学习、读懂、甚至学透源码。更进一步，希望自己能够掌握剖析一些面试难题的方法，解决生产级和框架级的bug，掌握一些基本的性能调优的方法。

具体的讲，先介绍调试方法、断点类型，以及IDEA调试面板的功能，然后介绍各种调试技巧（学习JUC必备的多线程调试方法），最后，精选几道面试难题，实战调试来掌握他们的底层原理。

## 常用的调试方法

**断点调试**

重点 关键点：在哪里打断点，怎么打断点

**日志调试**

**远程调试**

让本地编辑器和远程服务器联动，即在本地编辑器打断点，当远程收到请求时，它会把请求直接转到你本地的编辑器，然后你可以在本地编辑器中进行调试，主要用于解决一些生产中比较难以复现的bug。

## 断点类型有哪些？

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211214233419873.png" alt="image-20211214233419873"  />

断点类型如上图所示，主要有以上四种。

## IDEA的调试面板

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211214233600748.png" alt="image-20211214233600748"  />

下面给出面板中各个按钮的用法（与上图中的编号对应）：

1. 快捷键F9:代码直接运行到下一个断点的位置;

2. 打开断点面板

3. 让断点失效

4. 方法栈（main方法、test方法），此外可以在这里切换线程用于多线程调试

5. 快捷键F8：程序运行到下一行

6. 快捷键F7：进入到方法的内部

7. 调试JDK或框架源码时，直接按F7无法进入，这时可以使用Option+Shift+F7进入。其中，当一行中有多个方法时，Shift+F7可以选择进入哪个方法（前提是该方法的前面的方法中没有断点，比如现在就无法选择进入println方法，因为test方法中有断点）

8. 快捷键Shift+F8:退出当前的方法，回到它的上一个方法（前提是当前方法的对应行后面没有断点，否则就退不出去，而是会断到下一个断点，即不能有上图箭头标记的方法）

9. drop frame: 弹出栈顶的栈帧，如上图，会将test方法栈弹出，相当于从main方法中的断点重新执行。

10. 快捷键Option+F9：如果箭头位置没有断点，且光标停留在该行，点击该按钮代码就会执行到该行。

最后，还有很重要的一点，那就是条件断点，如下图所示，其中红框部分表示是所有线程挂起，还是按照线程挂起。

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211214233844203.png" alt="image-20211214233844203"  />

## 最常用的断点调试

```java
public class ArrayListTest {

public static void main(String[] args) {
        List<Integer> list = new ArrayList<>();
        for (int i = 7; i>0; i--) {
            list.add(i);
        }
        System.out.println(list); // [7, 6, 5, 4, 3, 2, 1]
        System.out.println(list.get(2)); // 5
        Integer index = 2;
        list.remove(index);
        System.out.println(list); // [7, 6, 5, 4, 3, 1]
    }
}
```

remove方法本想删除索引为2的位置上的元素，但结果确是删除了值为2的元素，与我的需求不符。接下来，在remove行打断点调试找原因。

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211214235928493.png" alt="image-20211214235928493"  />

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215000025433.png" alt="image-20211215000025433"  />

通过上面的debug，我们知道了当index为Integer类型时，调用的是按值移除的remove(object o)方法，那么如何移除索引为2的元素呢？答案是只需要将index的类型改成int，这样就会调用按索引移除的remove(int index)方法，如下图。此外，观察发现该方法的执行逻辑和按值移除基本一样。

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215000129317.png" alt="image-20211215000129317"  />

用彤哥的话讲，没有条件断点，看源码将寸步难行。假如用下面的代码演示HashMap的put方法的执行流程。

```java
public class HashMapTest {
    public static void main(String[] args) {
        Map<Integer,String> map = new HashMap<>();
        map.put(1, "1");
        map.put(2, "2");
        map.put(3, "3");
        map.put(4, "4");
        map.put(5, "5");
        map.put(6, "6");
        map.put(7, "7");
        map.put(8, "8");
        System.out.println(map);
    }
}
```

接下来，直接在put方法中打断点，启动执行后如下图，发现key和value并非我们所期望的1，按F9执行多次发现key和value仍不是我们想要的（key和value的内容好像与JVM有关系，观察调用栈发现很多loadClass字样，至于这些是什么，目前不去理会，但这些对于我们调试阅读put源码都是干扰因素），那么如何调试得到key和value都是1呢？

![image-20211215000314342](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215000314342.png)

一种方法是在HashMapTest的map.put(1,"1")行打断点，然后F7/Shift+F7进入put方法(在阅读一些框架，比如spring和netty时，调试时里面有很多干扰因素。spring启动时会启动很多bean，如果想看指定的bean的初始化过程，就没办法使用这种常规的断点方式去进行调试；netty中有很多自带的定时器在定时执行任务，采用常规的断点方式可能经常会和预期的不一样，这时最好使用条件断点进行调试)；另一种方法是在put方法中使用条件断点，条件为key.equals(1)。

接下来，按F7会让你选择putVal和hash（Tab可以左右选择），选中hash后F7进入（HashMap的key可以为null），然后F8回到put方法，继续F7进入putVal方法，一直F8就可以看到putVal的执行流程。

## 不想断下来，只想看看代码有没有经过这里

```java
//忽略掉包引入

/**
 * 二叉树的层序遍历
 *      3
 *     / \
 *   9   20
 *      /  \
 *     15   7
 */
public class LevelOrder {
    static class TreeNode {
        private int val;
        private TreeNode left;
        private TreeNode right;

        public TreeNode(int val) {
            this.val = val;
        }

        public TreeNode(int val, TreeNode left, TreeNode right) {
            this.val = val;
            this.left = left;
            this.right = right;
        }
    }

    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> resultList = new ArrayList<>();
        if (root == null) return resultList;

        Queue<TreeNode> queue = new LinkedList<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            List<Integer> result = new ArrayList<>();
            int size = queue.size();
            for (int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                result.add(node.val);
                if (node.left != null) {
                    queue.offer(node.left);
                }
                if (node.right != null) {
                    queue.offer(node.right);
                }
            }
            resultList.add(result); //第50行
        }
        return resultList;
    }

    public static void main(String[] args) {
        TreeNode node1 =  new TreeNode(3);
        TreeNode node2 = new TreeNode(9);
        TreeNode node3 = new TreeNode(20);
        TreeNode node4 = new TreeNode(15);
        TreeNode node5 = new TreeNode(7);
        node1.left = node2;
        node1.right = node3;
        node3.left = node4;
        node3.right = node5;
        new LevelOrder().levelOrder(node1); //第65行

//        new LevelOrder().levelOrder(new TreeNode(3,
//                new TreeNode(9),new TreeNode(20,
//                new TreeNode(15),new TreeNode(7))));

    }
}
```

需求是在断点处不断下来的情况下，将每次经过断点时result的值输出到控制台。具体做法是在resultList.add(result);一行添加断点，然后右键断点，将suspend勾选去掉，页面变成下图所示（因为要观察result的值，所以勾选evaluate and log，并添加result）。

<img src="https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215000937692.png" alt="image-20211215000937692"  />

不用写System.out.println();，也不用打log，这时调试执行，在控制台输出的日志如下：

```
[3]
[9, 20]
[15, 7]
```

在此基础上，再勾选上"breakpoint hit" message，在此调试执行，发现会打印出断点的位置，控制台输出的日志如下：

```java
Breakpoint reached at LevelOrder.levelOrder(LevelOrder.java:50)
[3]
Breakpoint reached at LevelOrder.levelOrder(LevelOrder.java:50)
[9, 20]
Breakpoint reached at LevelOrder.levelOrder(LevelOrder.java:50)
[15, 7]
```

如果去掉"breakpoint hit" message，勾选Stack trace，重新调试执行，发现会打印线程栈信息，控制台输出的日志如下：

```java
Breakpoint reached
	at LevelOrder.levelOrder(LevelOrder.java:50)
	at LevelOrder.main(LevelOrder.java:65)
[3]
Breakpoint reached
	at LevelOrder.levelOrder(LevelOrder.java:50)
	at LevelOrder.main(LevelOrder.java:65)
[9, 20]
Breakpoint reached
	at LevelOrder.levelOrder(LevelOrder.java:50)
	at LevelOrder.main(LevelOrder.java:65)
[15, 7]
```

下了断点但又不让它断下来，且又要观察每次经过断点时某些对象的值。在上面的案例中只需要自己添加System.out.println(result);就可以了，这种下断点的方式似乎显得多余，那么它到底有什么用呢？当我们在读开源框架源码时，一般情况下我们是无法修改代码的，这时候我们就可以通过这种方式观察某些对象值的变化。比如，当我们看spring初始化的源码时，我想看spring初始化过程中到底创建了哪些bean，这时就可以找到spring中相关的代码并下断点，使用上面的方式打印出bean的name，这样当spring启动完成时，就可以在控制台看到spring初始化过程中创建的所有bean。

## 日志调试

**使用场景**

1. 生产环境出现问题时，如果问题只能在生产环境复现，通过添加日志、重启服务来定位bug；

2. 在性能测试环境中，不能本地连接到性能测试环境，那么只能通过添加日志的方式观察每一步的耗时情况，最终定位到性能的瓶颈。

下面使用例子模拟演示，完整代码在https://github.com/YuanAaron/code-snippet/deliver_demo下，演示结果如图

![image-20211215065217545](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215065217545.png)

如果发现一个接口大部分情况下都很慢，那么我们该如何定位呢？答案就是输出日志

```java
public Boolean deliver(Long id) {
    long  start = System.currentTimeMillis();

    // 检查权限
    checkPrivilege();
    long m1 = System.currentTimeMillis();
    log.info("check privilege elapse = {}", m1-start);

    // 检查订单是否存在
    Order order = checkOrder(id);
    long m2 = System.currentTimeMillis();
    log.info("check order elapse = {}", m2 - m1);

    // 更新订单状态为发货中
    updateOrder(order);
    long m3 = System.currentTimeMillis();
    log.info("update status to delivering elapse = {}", m3 - m2);

    // 远程调用物流接口发货
    logisticsService.deliver(order);
    long m4 = System.currentTimeMillis();
    log.info("remote call logistics deliver api elapse = {}", m4-m3);

    // 更新订单状态为发货完成
    updateOrder(order);
    long m5 = System.currentTimeMillis();
    log.info("update status to delivered elapse = {}", m5 - m4);

    log.info("finished one order delivering elapse = {}", m5 - start);

    return true;
}
```

输出的日志如下：

![image-20211215065531133](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215065531133.png)

封装TimeWatchUtil类，优化日志的输出方式，且输出订单号和业务(实际生产中非常复杂，可能某些订单有问题，而有些没有问题，这时就需要打印订单id，这个是利用slf4j的MDC将订单id等添加到日志的上下文实现的)，代码和结果如下：

```java
public Boolean deliver(Long id) {
    TimeWatchUtil timeWatch = new TimeWatchUtil(log);

    // 检查权限
    checkPrivilege();
    timeWatch.log("check privilege");

    // 检查订单是否存在
    Order order = checkOrder(id);
    timeWatch.log("check order");

    // 更新订单状态为发货中
    updateOrder(order);
    timeWatch.log("update status to delivering");

    // 远程调用物流接口发货
    logisticsService.deliver(order);
    timeWatch.log("remote call logistics deliver api");

    // 更新订单状态为发货完成
    updateOrder(order);
    timeWatch.log("update status to delivered");

    timeWatch.logTotal("finished one order delivering");

    return true;
}
```

输出的日志如下：

![image-20211215065744392](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215065744392.png)

## 远程调试

将上一节的deliver_demo打包上传到服务器，然后跑起来，保证本地能够访问。

IDEA中的配置如下图：

![image-20211215070028005](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215070028005.png)

然后远程服务器添加虚拟机参数 -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005，重启服务器。但这里有个坑，使用java -jar xxx.jar vm_paramter命令重启服务，启动日志如下图：

![image-20211215070112009](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215070112009.png)

这时使用IDEA远程调试报错如下：

![image-20211215070212144](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215070212144.png)

这个问题我在stackoverflow找到了答案，参见https://stackoverflow.com/questions/40576115/unable-to-open-debugger-port-through-intellij，具体原因没有去深究，使用java -jar xxx.jar vm_paramter再次重启服务，启动日志如下：

![image-20211215070306477](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215070306477.png)

此时，使用IDEA远程调试启动成功，然后本地访问http://IP:8080/order/deliver/123456789，发现就能进入自己本地的断点（将对服务器的请求转到了对本地的请求），至此就能进行远程调试了。

这种方式适用于本地无法直接连接生产的数据库时。

这种调试方式有两方面的限制：

1. 本地的代码必须和服务器中运行的代码保持完全一致，不一致的话断点会错位；

2. 远程服务器允许你本地直接连接，这样你才能通过TCP(socket)连接远程服务器进行调试。比如服务器关闭5005端口的访问权限。但是估计大部分公司都不会允许，哈哈。

## 断点打在成员变量上

如果你在某个成员变量上添加了断点，当该变量被访问或修改时，IDEA就会自动在使用行或修改行添加Field断点，即成员变量断点。默认情况下，只有在该变量修改时IDEA会这样做，如果想在访问该变量时IDEA也这样做，可以右键你添加的Field断点，然后勾选Field Access即可。

![image-20211215070441896](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215070441896.png)

使用场景是读框架的源码时追溯一个变量被访问或者被修改的情况（直接使用F9即可）

比如，跟踪spring启动时都有哪些地方使用到了singletonObjects变量（该变量存放了spring中所有的单利bean），如下图所示，发现很多地方都使用到了该对象，那么就无法找到spring启动时哪些地方使用了该变量，这时就可以使用成员变量断点。

![image-20211215070557208](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215070557208.png)

注意，在该行添加断点时有Java Field Wathchpoint和Java Line Breakpoint（因为这里有对singletonObjects初始化的操作），这里选择前者即可，然后启动项目。

![image-20211215070816745](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215070816745.png)

![image-20211215070843574](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215070843574.png)

接下来，不断按F9调试即可。调试过程中发现，singletonObjects的使用基本在containsSingleton、registerSingleton、addSingleton、getSingleton这几个方法间来回切换。接下来，如果想观察某个单利bean的创建过程，那么可以着重在这几个方法中打断点，然后再进行进一步调试。

## 异常断点

```java
static class ListNode {
    public int val;
    public ListNode next;

    public ListNode(int val) {
        this.val = val;
    }

    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}

/**
 * 反转链表
 */
public class ReverseList {
    // 1->2->3->4->5 1<-2<-3<-4<-5
    // 我的写法
    public static ListNode reverseList(ListNode head) {
        ListNode cur = head, prev = null, n1 = null;
        while (cur != null) {
             n1 = cur.next;
             cur.next = prev;
             prev = cur;
             cur = n1;
        }
        return prev;
    }
    
    // 彤哥用于演示异常断点
    public static ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode prev = head, cur = head.next, n1 = cur.next;
        prev.next = null;
        while (cur != null) {
            cur.next = prev;
            
            prev = cur;
            cur = n1;
            n1 = cur.next;
        }
        return prev;
    }
}
```

使用快捷键command+shift+F8调出view breakpoint...，然后添加nullPointException异常，无需在代码中打断点，debug运行即可，如下图所示。

![image-20211215071048724](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215071048724.png)

调试结果如下图：

![image-20211215071130006](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215071130006.png)

修改：如果cur不为null, 然后n1 = cur.next。

一个小的应用场景：提前将各种常见异常（nullPointException、ArrayIndexOutOfBoundsException等）或自定义异常添加上，然后刷题时/项目中的自定义异常触发时就能直接定位问题。

## 调试时热部署（热更新）代码？

![image-20211215071306670](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215071306670.png)

1. 第一个断点：发现分母为0，需要修改代码，在这行上面添加if (n2 == 0) return 0;，接下来不用重启，只需要按住ctrl+shift+F9热更新代码，然后Drop Frame（在IDEA调试面板中）丢掉当前的方法栈，再次调试即可。

2. 第二个断点：如果发现应该是nums[i]=nums[i]-1，修改后同样按住ctrl+shift+F9热更新代码，同样Drop Frame丢掉当前的方法栈，然后再次调试发现结果是{1,2}，而非我们想要的是{0,1}。这是因为像数组这样的引用类型（String除外），在第一次进入该方法后已经将原数组改为了{2,3}(这个再次调试时就能验证)，那么再次调试的结果自然就是{0,1}。热部署的第一个弊端：对方法中参数的修改不能影响到方法外面的地方。

3. 第三个断点：如果发现应该是num / 2，修改后同样热更新，然后Drop Frame当前的方法栈，然后再次调试发现结果是2/2=1，而非1/2=0，这与数组类似，在第一次进入该方法后已经将num改为了1，那么再次调用的结果自然就是1了。热部署的第二个弊端：不能对类本身的静态属性(非静态也类似)进行修改。

4. 第四个断点：如果发现应该是num + x(x为新增加的静态变量，值为1)，修改后同样热更更新，然后Drop Frame当前的方法栈，发现断在了System.out.println(test3());而非System.out.println(test4());，这有点奇怪，忽略后再次调试发现代码直接结束了，无法进入到test4中，最终打印的结果仍然是2（不修改打印的结果是2）。热部署的第三个弊端：不能修改类的结构（成员变量、方法的签名）。

基于以上热部署的三点弊端，我个人认为最好不要使用热部署，哈哈！

## 多线程调试法

生产者消费者模式：生产者、消费者、缓冲区，生产者将数据（任务）发送到缓冲区，消费者从缓冲区取数据（任务）进行消费。

在分布式系统中，缓冲区一般由Kafka等消息中间件充当，在一个简单的生产者消费者模式中，就不用引入Kafka等如此复杂的中间件了。那么到底用什么来作为我们的缓冲区呢？一般来说，生产者消费者都是在多线程环境下，每个生产者（消费者）都是一个单独的线程，多个线程向一个缓冲区（共享内存）中写数据，这时必须进行控制，否则出现数据不一致、数据混乱，因此缓冲区必须是并发安全的容器。一般来说，我们采用阻塞队列（BlockingQueue）作为缓存区（其他并发安全的容器也可以，比如ConcurrentLinkedQueue，并发安全的list也可以，但一般使用队列来进行实现）。

生产者消费者模式的原理其实核心是阻塞队列的原理，只需要明白下面两个问题：

1. 如果队列为空，这时候消费者去取数据，它怎么工作？

2. 如果队列为满，这时候生产者还往里面放数据，它又是如何工作的？

下面使用如下代码进行调试来解答上面的疑问，代码如下：

```java
public class ProductorConsumer {
    // 一个快递点
    private static final BlockingQueue<Integer> queue = new ArrayBlockingQueue<>(100);

    public void productor() {
        //4个大卡车
        for (int i = 0; i < 4; i++) {
            final int num = i; //lambda表达式中不能直接使用i，必须为final类型
            //每辆卡车运100件商品到快递点
            new Thread(() -> {
                try {
                    for (int j = 0; j < 100; j++) {
                        //使用put符合当前场景，即快递站没地方放了，大卡车只能稍等一会，等快递小哥运出一部分，再从卡车上卸货
                        queue.put(num * 100 + j); //断点1
                    }
                    System.out.println("productor-" + num +"已卸完货！");
                }catch(InterruptedException e){
                    e.printStackTrace();
                }
            },"productor-"+i).start();
        }
    }

    public void consumer() {
        // 5个快递小哥
        for (int i = 0; i < 5; i++) {
            //假设每个快递小哥都能不停的送货
            new Thread(() -> {
                try {
                    while (true) {
                        Integer data = queue.take(); //断点2
                        System.out.println(data);
                    }
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            },"consumer-" + i).start();
        }
    }


    public static void main(String[] args) throws IOException {
        ProductorConsumer pc = new ProductorConsumer();
        pc.productor();
        pc.consumer();
        System.in.read();
    }
}
```

+ add: 当队列满时，抛出异常，remove同理

+ offer: 当队列满时，返回一个特殊值（false或null），poll同理

+ put: 当队列满时，当前线程会阻塞直到put操作成功，take同理

+ offer（含timeout）:当队列满时，当前线程阻塞一段时间，poll（含timeout）同理

![image-20211215071629151](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215071629151.png)

首先解答第一个疑问，程序启动后，4个生产者断在了断点1（注意：多线程调试中使用的都是Thread挂起断点，这个可以通过右键断点修改），5个消费者断在了断点2。接下来，从Frames调试面板选取一个消费者（比如consumer-0），然后按Shift+F7进入take方法，继续按几次F8后，如下图所示。

![image-20211215071712075](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215071712075.png)

接下来，再次按F8，如下图所示，consumer-0线程阻塞进入了WAIT状态，即当阻塞队列为空时，继续从该队列中取数据，当前线程会阻塞。

![image-20211215071805161](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215071805161.png)

接下来，从Frames调试面板选取一个生产者（比如product-1）,按F9向队列中添加一个元素。然后切换回consumer-0线程，如下图所示，发现该线程被唤醒（如果有多个消费者线程被阻塞，唤醒哪个不确定），且从Frame调试面板知道，该线程回到了RUNNING状态。

![image-20211215071926977](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215071926977.png)

接下来，由于count==1，不满足count==0，继续调试进入dequeue方法（让队列中刚放入的100出队），具体如下图所示

![image-20211215072020201](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215072020201.png)

以上演示了队列为空时阻塞队列的工作原理，总结如下：

当队列为空时，如果消费者继续从该队列中取数据，那么该消费线程在notEmpty.await()处会阻塞，进入WAIT状态；当生产者线程向该队列中放入一个数据后，会发送一个notEmpty.signal()信号，唤醒阻塞的消费线程（如果有很多阻塞的消费线程，唤醒哪个不确定），然后消费线程继续while循环，发现count==0不再成立，这时就会跳出while循环，进入dequeue出队方法（元素出队，队列元素数减1），这时队列又为空了。

接下来，解答第二个疑问，根据前面的原理，我们大致可以猜测为当队列满时，继续向队列中放入一个元素，当前生产者线程会阻塞，直到消费者线程从队列中取走一个元素，然后生产者线程才能将元素放入到队列中，这时队列又满了，调试代码进行验证。

首先，程序重新启动后，在断点2的下面一行增加断点3，从Frames调试面板中选择一个生产者线程（比如product-0）,然后临时取消断点2，按F9后断在断点3，此时队列中放入了0...99这100个元素，接下来，恢复断点2，从Frames调试面板中再选择一个生产者线程（比如product-1）,按Shift+F7尝试向队列再添加一个元素,如下图所示

![image-20211215072113752](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215072113752.png)

接下来，再次按F8，如下图所示，product-1线程阻塞进入了WAIT状态，即当阻塞队列满时，继续向该队列中添加数据，当前线程会阻塞。

![image-20211215072202096](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215072202096.png)

接下来，从Frames调试面板选取一个消费者（比如consumer-0）,按F9从队列中取出一个元素。然后切换回product-1线程，如下图所示，发现该线程被唤醒（如果有多个生产者线程被阻塞，唤醒哪个不确定），且从Frame调试面板知道，该线程回到了RUNNING状态。

![image-20211215072251612](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215072251612.png)

接下来，由于count==99，不满足count==items.length，继续调试进入enqueue方法（将100放入到队列中），具体如下图所示

![image-20211215072334923](https://cdn.jsdelivr.net/gh/YuanAaron/BlogImage/2021/image-20211215072334923.png)

enqueue和dequeue的代码逻辑类似，不再详细介绍。

以上演示了队列满时，继续向队列中添加元素，阻塞队列的工作原理，总结如下：

当队列为满时，生产者继续向队列中放数据，那么该生产线程会在notFull.await处阻塞，进入WAIT状态，直到队列不为满时，即消费线程从队列中取出一个元素后，会发送一个notFull.signal()信号，唤醒阻塞的生产线程（如果有很多阻塞的生产线程，唤醒哪个不确定），然后该生产线程继续while循环，发现count==items.length不再成立，这时就会跳出while循环，进入enqueue入队方法（元素入队，队列元素数加1），这时队列又为满了。

多线程调试法同样适用于线程池空和满时的调试。

**调试的一个大坑**：https://blog.csdn.net/AUBREY_CR7/article/details/106331490
